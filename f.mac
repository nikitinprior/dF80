; z80dasm 1.1.3
; command line: ./z80dasm -a -l -t -s f.sym -o f.mac -b f.blocks F.COM

FALSE   equ 0
TRUE    equ NOT FALSE

DBG     SET 1
TRACE   SET 1

V3.44   equ FALSE       ;; F80 v3.4
;;V3.44 equ TRUE        ;; F80 v3.44

        .z80
        aseg
        org 100h

BDOS    equ 0005h   ; CP/M BDOS entry point
TPATOP  equ BDOS+1  ; Top of user TPA (address at 6,7)
CCPbuf  equ 080h

.drv    equ 1
.nam    equ 8
.ext    equ 3

FCBlen  equ 33      ; Length of FCB
reclng  equ 128
;
;   Number of records
;
SRClen  equ 4       ; Source buffer
RELlen  equ 2       ; REL buffer
LSTlen  equ 4       ; List buffer

CMDLEN  equ 80
;
;   Equates for non graphic characters
;
null    equ 00h
bell    equ 07h
.bell   equ 87h
tab     equ 09h     ; TAB character
.tab    equ 89h
lf      equ 0ah     ; Line Feed
.lf     equ 8ah
ff      equ 0ch
.ff     equ 8ch
cr      equ 0dh     ; Carriage Return
eof     equ 1ah     ; End Of File mark

NoMSB   equ 01111111b
MSB     equ 10000000b

        jp main     ;0100

TopMem: dw 0    ;0103   Top of memory
TopDat: dw 0    ;0105   Top of data

PosStm: db 0    ;0107
;
;   FORTRAN program line
;                            First character 'C' - Comment Card
l0108h: ds 5    ;0108   1-5  Field for statement label(number).
l010dh: db 0    ;010d     6  Continuation character field (any character, except 0)
        ds 66   ;010e  7-72  Statement (program code) Field
l0150h: ds 8    ;0150 73-80  Field identification codes

Column: db 0    ;0158
l0159h: db 0    ;0159   REL byte
        db 0    ;015a
NumSrc: dw 0    ;015b   Line number source file
;
StartZ:                 ;** Start of zeroed area **
DataID: dw 0    ;015d
l015fh: dw 0    ;015f

l0161h: dw 0    ;0161
        dw 0    ;0163
;
ScopeID:db 0    ;0165
BlkDat: db 0    ;0166   Flag Block data 1-BLOCK DATA
l0167h: dw 0    ;0167
l0169h: dw 0    ;0169
;
l016bh: dw 0    ;016b
l016dh: dw 0    ;016d
l016fh: dw 0    ;016f
;
l0171h: dw 0    ;0171
l0173h: db 0    ;0173
EntryID:dw 0    ;0174
l0176h: dw 0    ;0176
l0178h: dw 0    ;0178
incflg: db 0    ;017a
;
IncBuf: ds 28h  ;017b   Buffer for include file name
;
l01a3h: db 0    ;01a3

l01a4h: dw 0    ;01a4   [66c6]
l01a6h: dw 0    ;01a6
l01a8h: db 0    ;01a8
l01a9h: db 0    ;01a9
l01aah: dw 0    ;01aa

SegmID: db 0    ;01ac   Flag Address mode 0-CSEG, 2-DSEG
DO_Flg: db 0    ;01ad   Flag DO Termination

l01aeh: dw 0    ;01ae

l01b0h: dw 0    ;01b0   [66c6]
l01b2h: dw 0    ;01b2

l01b4h: dw 0    ;01b4
l01b6h: dw 0    ;01b6
SizeID: db 0    ;01b8   Size Variable
l01b9h: db 0    ;01b9

l01bah: dw 0    ;01ba
l01bch: dw 0    ;01bc
l01beh: dw 0    ;01be

conflg: db 0    ;01c0   Log device flag [0 is printer]
ErrCnt: dw 0    ;01c1   Error counter
l01c3h: db 0    ;01c3

l01c4h: dw 0    ;01c4
l01c6h: dw 0    ;01c6
DatSiz: dw 0    ;01c8   Data size

l01cah: db 0    ;01ca
l01cbh: db 0    ;01cb
l01cch: dw 0    ;01cc
l01ceh: db 0    ;01ce
l01cfh: dw 0    ;01cf
l01d1h: db 0    ;01d1
;
l01d2h: db 0    ;01d2   1
l01d3h: db 0    ;01d3   2
l01d4h: db 0    ;01d4   3
l01d5h: db 0    ;01d5   4
l01d6h: db 0    ;01d6   5
l01d7h: db 0    ;01d7   6
l01d8h: db 0    ;01d8   7 l01d8h
l01d9h: db 0    ;01d9   8
;
l01dah: db 0    ;01da   1
l01dbh: db 0    ;01db   2
l01dch: db 0    ;01dc   3
l01ddh: db 0    ;01dd   4
l01deh: db 0    ;01de   5
l01dfh: db 0    ;01df   6
l01e0h: db 0    ;01e0   7
l01e1h: db 0    ;01e1   8
;
l01e2h: db 0    ;01e2   1
        db 0    ;01e3   2
        db 0    ;01e4   3
        db 0    ;01e5   4
        db 0    ;01e6   5
l01e7h: db 0    ;01e7   6
        db 0    ;01e8   7
        db 0    ;01e9   8
;
l01eah: db 0    ;01ea
l01ebh: db 0    ;01eb
TypeID: db 0    ;01ec   Type variable
l01edh: db 0    ;01ed
l01eeh: db 0    ;01ee
;
; Table type definitions variables
; 0 - INTEGER,INTEGER*2
; 1 - REAL
; 2 - LOGICAL, BYTE
; 3 - DOUBLE PRECISION, REAL*8
; 4 - INTEGER*4
;
TypeDef:db 0    ;01ec   1 'A'
        db 0    ;01ed   1 'B'
        db 0    ;01ee   1 'C'
        db 0    ;01ef   1 'D'
        db 0    ;01f0   1 'E'
        db 0    ;01f1   1 'F'
        db 0    ;01f2   1 'G'
        db 0    ;01f3   1 'H'
        db 0    ;01f4   0 'I'
        db 0    ;01f5   0 'J'
        db 0    ;01f6   0 'K'
        db 0    ;01f7   0 'L'
        db 0    ;01f8   0 'M'
        db 0    ;01f9   0 'N'
        db 0    ;01fa   1 'O'
        db 0    ;01fb   1 'P'
        db 0    ;01fc   1 'Q'
        db 0    ;01fd   1 'R'
        db 0    ;01fe   1 'S'
        db 0    ;01ff   1 'T'
        db 0    ;0200   1 'U'
        db 0    ;0201   1 'V'
        db 0    ;0202   1 'W'
        db 0    ;0203   1 'X'
        db 0    ;0204   1 'Y'
        db 0    ;0205   1 'Z'
;
l0209h: dw 0    ;0209   [FA04]

KindID: db 0    ;020b   0-?, 1-Constant, 2-Label, 3-Variable, 4-Array, 5-Routine, 6-Common

l020ch: dw 0    ;020c   [FA04]
l020eh: db 0    ;020e
l020fh: dw 0    ;020f
l0211h: dw 0    ;0211
l0213h: dw 0    ;0213
HeapEnd:dw 0    ;0215   [FA04]
l0217h: dw 0    ;0217   [66c6]
HeapPtr:dw 0    ;0219   [66c6]

l021bh: db 0    ;021b
PrgSiz: dw 0    ;021c   Program size
l021eh: dw 0    ;021e
l0220h: dw 0    ;0220

l0222h: db 0    ;0222
l0223h: db 0    ;0223
        db 0    ;0224
        db 0    ;0225
        db 0    ;0226
        db 0    ;0227
        db 0    ;0228
        db 0    ;0229
        db 0    ;022a

i_Type: db 0    ;022b

l022ch: dw 0    ;022c   4 and 3 bytes statement
l022eh: db 0    ;022e   2 byte statement
l022fh: db 0    ;022f   1 byte statement

l0230h: db 0    ;0230
l0231h: db 0    ;0231
l0232h: db 0    ;0232
NumDim: db 0    ;0233   Number of dimension declarators

;MnCode:dw 0    ;V3.4

NumIO:  db 0    ;0234   Number of parameters statement READ or WRITE
l0235h: dw 0    ;0235

l0237h: dw 0    ;0237
l0239h: dw 0    ;0239

l023bh: dw 0    ;023b
l023dh: dw 0    ;023d
l023fh: dw 0    ;023f
l0241h: dw 0    ;0241

l0243h: db 0    ;0243

l0244h: dw 0    ;0244
l0246h: dw 0    ;0246
l0248h: dw 0    ;0248
l024ah: dw 0    ;024a

l024ch: db 0    ;024c
l024dh: db 0    ;024d
l024eh: db 0    ;024e

l024fh: dw 0    ;024f
l0251h: dw 0    ;0251

SubrFlg:db 0    ;0253   Flag Subroutine 1-Subroutine, 0-Function
        db 0    ;0254
        db 0    ;0255
        db 0    ;0256
        db 0    ;0257
        db 0    ;0258
        db 0    ;0259

l025ah: dw 0    ;025a
l025ch: dw 0    ;025c
l025eh: dw 0    ;025e
l0260h: dw 0    ;0260

l0262h: db 0    ;0262
MainFlg:db 0    ;0263   Flag module 0-Main program, 1-Subprogram

l0264h: dw 0    ;0264
CurAdr: dw 0    ;0266 + Address current program Processing statement
l0268h: dw 0    ;0268
l026ah: dw 0    ;026a ?Two-dimensional array
l026ch: db 0    ;026c ?Three-dimensional array (dw)
l026dh: db 0    ;026d ++ Error

l026eh: dw 0    ;026e
l0270h: dw 0    ;0270 ?One-dimensional array
l0272h: dw 0    ;0272 ?Two-dimensional array
l0274h: dw 0    ;0274 ?Three-dimensional array
l0276h: dw 0    ;0276

l0278h: db 0    ;0278
l0279h: db 0    ;0279
l027ah: db 0    ;027a
l027bh: db 0    ;027b

l027ch: dw 0    ;027c
l027eh: dw 0    ;027e
l0280h: dw 0    ;0280

l0282h: db 0    ;0282

l0283h: dw 0    ;0283
l0285h: dw 0    ;0285

l0287h: db 0    ;0287

l0288h: dw 0    ;0288
l028ah: dw 0    ;028a
l028ch: dw 0    ;028c
tmpvar:
l028eh: dw 0    ;028e
l0290h: dw 0    ;0290
l0292h: dw 0    ;0292
NumArg: dw 0    ;0294   Number of arguments to transfer
l0296h: dw 0    ;0296

l0298h: db 0    ;0298
l0299h: db 0    ;0299
l029ah: db 0    ;029a

l029bh: dw 0    ;029b
l029dh: dw 0    ;029d
l029fh: dw 0    ;029f
l02a1h: dw 0    ;02a1   [fa36]

l02a3h: db 0    ;02a3
l02a4h: db 0    ;02a4

l02a5h: dw 0    ;02a5
l02a7h: dw 0    ;02a7
l02a9h: dw 0    ;02a9
l02abh: dw 0    ;02ab
WrnCnt: dw 0    ;02ad   Warning counter
l02afh: dw 0    ;02af
l02b1h: dw 0    ;02b1
l02b3h: dw 0    ;02b3
EndZ:                               ;** End of Zeroed Area **

l02b5h: db 0    ;02b5    1
l02b6h: db 0    ;02b6    2
        db 0    ;02b7    3
        db 0    ;02b8    4
        db 0    ;02b9    5
        db 0    ;02ba    6
        db 0    ;02bb    7
        db 0    ;02bc    8
        db 0    ;02bd    9
        db 0    ;02be   10
        db 0    ;02bf   11
        db 0    ;02c0   12
        db 0    ;02c1   13
        db 0    ;02c2   14
        db 0    ;02c3   15
        db 0    ;02c4   16
        db 0    ;02c5   17
        db 0    ;02c6   18
        db 0    ;02c7   19
l02c8h: db 0    ;02c8   20
        db cr   ;02c9

l02cah: db 'ESLAF'  ;02ca "FALSE"
l02cfh: db '.EURT'  ;02cf "TRUE."
l02d4h: db 'ITCNUF' ;02d4 "FUNCTI"
l02dah: db '=RRE'   ;02da "ERR="
l02deh: db '=DNE'   ;02de "END="
l02e2h: db '=CER'   ;02e2 "REC="
l02e6h: db 'NIAM$'  ;02e6 "$MAIN"
l02ebh: db 'TINI$'  ;02eb "$INIT"
;
; Type variables
;          ;- Length string
           ;    ;- String
           ;    ;    ;- ID_Type
           ;    ;    ;
Type_b: db 03h,'YTE',2                 ;02f0 "bYTE"
Type_i: db 06h,'NTEGER',0              ;02f5 "iNTEGER"
Type_d: db 0eh,'OUBLEPRECISION',3      ;02fd "dOUBLEPRECISION"
Type_l: db 06h,'OGICAL',2              ;030d "lOGICAL"
Type_r: db 03h,'EAL',1                 ;0315 "rEAL"

NumMod: db 0            ;031a   Number of compiled program modules
l031bh: dw 0            ;031b   [fa04]
l031dh: dw 0            ;031d   [fa66]
l031fh: dw 0            ;031f   [fc75]

l0321h: db 'FOR'        ;0321
l0324h: dc 'Line: '     ;0324
;
;   Statement table
;      ;- Statement
       ;      ;- Offset
       ;      ;    ;- Type statement
       ;      ;    ;
l032ah:
    db 'ASSI',001h,9        ;032a   ASSIgn
    dw PrAssign             ;0330

    db 'BACK',003h,0ah      ;0332   BACKspace
    dw PrBackspace          ;0338
 
    db 'BYTE',000h,1        ;033a   BYTE
    dw PrByte               ;0340

    db 'BLOC',008h,0        ;0342   BLOCkdata
    dw PrBlockdata          ;0348

    db 'CALL',000h,9        ;034a   CALL
    dw PrCall               ;0350

    db 'COMM',00dh,4        ;0352   COMMon
    dw PrCommon             ;0358

    db 'CONT',00fh,9        ;035a   CONTinue
    dw PrContinue           ;0360

    db 'DATA',000h,6        ;0362   DATA
    dw PrData               ;0368

    db 'DIME',013h,1        ;036a   DIMEnsion
    dw PrDimension          ;0370

    db 'DOUB',018h,1        ;0372   DOUBleprecision
    dw PrDouble             ;0378   trap_ms

    db 'ENCO',023h,0ah      ;037a   ENCOde(
    dw PrEncode             ;0380

    db 'ENDF',026h,0ah      ;0382   ENDFile
    dw PrBackspace          ;0388

    db 'EQUI',029h,5        ;038a   EQUIvalence
    dw PrEquivalence        ;0390

    db 'EXTE',030h,1        ;0392   EXTErnal
    dw PrExternal           ;0398

    db 'DECO',023h,0ah      ;039a   DECOde(
    dw PrEncode             ;03a0

    db 'FORM',034h,9        ;03a2   FORMat
    dw PrFormat             ;03a8

    db 'FUNC',036h,0        ;03aa   FUNCtion
    dw PrFunction           ;03b0

    db 'GOTO',000h,9        ;03b2   GOTO
    dw PrGoto               ;03b8

    db 'IF( ',000h,9        ;03ba   IF(
    dw PrIf                 ;03c0

    db 'INCL',03ah,9        ;03c2   INCLude
    dw PrInclude            ;03c8

    db 'IMPL',03dh,1        ;03ca   IMPLicit
    dw PrImpicit            ;03d0

    db 'INTE',041h,1        ;03d2   INTEger
    dw PrIneger             ;03d8   trap_ms

    db 'LOGI',044h,1        ;03da   LOGIcal
    dw PrByte               ;03e0

    db 'PAUS',047h,0ah      ;03e2   PAUSe
    dw PrPause              ;03e8

    db 'PROG',048h,0        ;03ea   PROGram
    dw PrProgram            ;03f0

    db 'READ',04bh,0ah      ;03f2   READ(
    dw PrRead               ;03f8

    db 'RETU',04ch,9        ;03fa   RETUrn
    dw PrReturn             ;0400

    db 'REAL',000h,1        ;0402   REAL
    dw PrReal               ;0408   trap_ms

    db 'REWI',04eh,0ah      ;040a   REWInd
    dw PrBackspace          ;0410

    db 'STOP',000h,0ah      ;0412   STOP
    dw PrPause              ;0418

    db 'SUBR',050h,0        ;041a   SUBRoutine
    dw PrSubroutine         ;0420

    db 'WRIT',056h,0ah      ;0422   WRITe(
    dw PrRead               ;0428
;
;   Continuation of Statements
;
l042ah:
    dc 'GN'             ;042a  1    assiGN
    dc 'SPACE'          ;042c  2    backSPACE
    dc 'KDATA'          ;0431  3    blocKDATA
    dc 'ON'             ;0436  4    commON
    dc 'INUE'           ;0438  5    contINUE
    dc 'NSION'          ;043c  6    dimeNSION
    dc 'LEPRECISION'    ;0441  7    doubLEPRECISION
    dc 'DE('            ;044c  8    encoDE(, decoDE(
    dc 'ILE'            ;044f  9    endfILE
    dc 'VALENCE'        ;0452 10    equiVALENCE
    dc 'RNAL'           ;0459 11    exteRNAL
    dc 'AT'             ;045d 12    formAT
    dc 'TION'           ;045f 13    funcTION
    dc 'UDE'            ;0463 14    inclUDE
    dc 'ICIT'           ;0466 15    implICIT
    dc 'GER'            ;046a 16    inteGER
    dc 'CAL'            ;046d 17    logiCAL
    dc 'E'              ;0470 18    pausE
    dc 'RAM'            ;0471 19    progRAM
    dc '('              ;0474 20    read(
    dc 'RN'             ;0475 21    retuRN
    dc 'ND'             ;0477 22    rewiND
    dc 'OUTINE'         ;0479 23    subrOUTINE
    dc 'E('             ;047f 24    writE(
;
;   Table Arithmetic Operators
;
        db '+-*/,)'     ;0481
l0487h: db '='          ;0487
;
;   Table Logical operations
;
        db '.EG'        ;0488   "GE." 10
        db '.EL'        ;048b   "LE."  9
        db '.EN'        ;048e   "NE."  8
        db '.TL'        ;0491   "LT."  7
        db '.TG'        ;0494   "GT."  6
        db '.QE'        ;0497   "EQ."  5
        db 'ROX'        ;049a   "XOR"  4
        db '.RO'        ;049d   "OR."  3
        db 'DNA'        ;04a0   "AND"  2
l04a3h: db 'TON'        ;04a3   'NOT'  1
;
;       (l0243h) (l01b4h)
;       db   0    0             0 "+"
l04a6h: db 001h, 00bh   ;04a6   1 "-"
        db 003h, 00bh   ;04a8   2 "*"
        db 002h, 00ch   ;04aa   3 "/"
        db 004h, 00ch   ;04ac   4 ","
        db 006h, 00eh   ;04ae   5 ")"
        db 00ch, 00fh   ;04b0   6 "="
        db 007h, 001h   ;04b2   7 "GE."
        db 00dh, 009h   ;04b4   8 "LE."
        db 00eh, 009h   ;04b6   9 "NE."
        db 00fh, 009h   ;04b8  10 "LT."
        db 010h, 009h   ;04ba  11 "GT."
        db 011h, 009h   ;04bc  12 "EQ."
        db 012h, 009h   ;04be  13 "XOR"
        db 008h, 003h   ;04c0  14 "OR."
        db 009h, 003h   ;04c2  15 "AND"
        db 00ah, 005h   ;04c4  16 "NOT"
        db 00bh, 007h   ;04c6  17 "**"
        db 005h, 00dh   ;04c8  18
;
l04cah: db 000h     ;04ca   00  . 
        db 00bh     ;04cb   0b  . 
        db 00ch     ;04cc   0c  . 
        db 00bh     ;04cd   0b  . 
        db 00ch     ;04ce   0c  . 
        db 00dh     ;04cf   0d  . 
;
l04d0h: db 00eh     ;04d0   0e  . 
        db 001h     ;04d1   01  . 
        db 003h     ;04d2   03  . 
        db 003h     ;04d3   03  . 
        db 005h     ;04d4   05  . 
        db 007h     ;04d5   07  . 
;
l04d6h: db 00fh     ;04d6   0 
        db 009h     ;04d7   1 
        db 009h     ;04d8   2 
        db 009h     ;04d9   3
        db 009h     ;04da   4 
        db 009h     ;04db   5 
        db 009h     ;04dc   6
        db 00eh     ;04dd   7 
        db 00dh     ;04de   8 
        db 00fh     ;04df   9 
        db 011h     ;04e0  10  a
        db 010h     ;04e1  11  b
        db 012h     ;04e2  12  c
        db 010h     ;04e3  13  d
        db 011h     ;04e4  14  e
        db 012h     ;04e5  15  f
        db 00dh     ;04e6  16 10
        db 00eh     ;04e7  17 11
        db 00fh     ;04e8  18 12
;*
;*    ENTRY Reg  A - SIZ (SizeID)
;*          Reg HL - ADR
s_04e9h:
    add a,6             ;04e9
    push af             ;04eb \ Save SIZ+6
    push hl             ;04ec \
    call ChkMem         ;04ed   Test Allocate A bytes of memory
    pop de              ;04f0 /                 de=ADR
    ld hl,(HeapEnd)     ;04f1   hl=(HeapEnd)
    ex de,hl            ;04f4   hl=ADR          de=(HeapEnd)
    call subHL.DE       ;04f5   hl=ADR-(HeapEnd)
    ld b,h              ;04f8
    ld c,l              ;04f9   bc=ADR-(HeapEnd)
    pop af              ;04fa / Restore SIZ+6
    cpl                 ;04fb
    ld l,a              ;04fc
    ld h,0ffh           ;04fd   hl= -(SIZ+6)
    inc hl              ;04ff   hl=1-(SIZ+6)
    push de             ;0500 \ Save (HeapEnd) ----------------+
    ex de,hl            ;0501   hl=(HeapEnd)    de=1-(SIZ+6)   ;
    add hl,de           ;0502                                  ;
    ld (HeapEnd),hl     ;0503   (HeapEnd)=(HeapEnd)-(SIZ+6)+1  ;
    push hl             ;0506 \                        -----+  ;
    ld hl,(l020ch)      ;0507                               ;  ;
    add hl,de           ;050a                               ;  ;
    ld (l020ch),hl      ;050b   (l020ch)=(l020ch)+1-(SIZ+6) ;  ;
    pop hl              ;050e / hl=(HeapEnd)-(SIZ+6)+1  ----+  ;
    pop de              ;050f / de=(HeapEnd)   ----------------+
;                               bc=ADR-(HeapEnd)
    ld a,b              ;0510
    or c                ;0511   test bc
    jp z,l051fh ;-----; ;0512   if ADR-(HeapEnd).eq.0 --> ...
l0515h:          ;<-; ;
      inc hl        ; ; ;0515   hl=hl+1
      inc de        ; ; ;0516   de=de+1
      ld a,(de)     ; ; ;0517
      ld (hl),a     ; ; ;0518   (hl)=(de)
      dec bc        ; ; ;0519   bc=bc-1
      ld a,b        ; ; ;051a
      or c          ; ; ;051b
      jp nz,l0515h;-+ ; ;051c   if bc.ne.0 --> ...
l051fh:         ;<----+
    ld (l0209h),hl      ;051f   (l0209h)=
    ret                 ;0522
;*
;*  (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
;*    ENTRY Reg HL -
;*
s_0523h:
    ld (l01d6h),hl      ;0523   (l01d6h)=
    ld hl,00000h        ;0526
    ld (l01d8h),hl      ;0529   (l01d8h)=0
    xor a               ;052c
    ld (TypeID),a       ;052d   (TypeID)=0 (INTEGER)
    inc a               ;0530
    ld (KindID),a       ;0531   (KindID)=1 (Constant)
    ld a,4              ;0534
    ld (SizeID),a       ;0536   (SizeID)=4
    jp s_055ah          ;0539   --> ...
;*
;*  Processing ASSIGN (ASSIGN label TO int_var)
;*
PrAssign:
    call PrLabel        ;053c   Processing label
    ld a,'T'            ;053f
    call ch.chr         ;0541   Check character (a character for check)
    call g_n_chr        ;0544   Get next character
    ld a,'O'            ;0547
    call ch.chr         ;0549   Check character (a character for check)
    call s_1479h        ;054c   cd 79 14
    call s_2598h        ;054f   Processing integer constant with error checking & Test (KindID).ne.1
    ld a,7              ;0552   a=7
    call s_147ah        ;0554   cd 7a 14
    jp l09ebh           ;0557   --> Clear (l029ah) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_055ah:
    ld bc,l0649h                ;055a   Point to l0649h
    push bc                     ;055d \ Save to return                                                          SP=l0649h
    ld hl,(l031dh)              ;055e   hl=[fa66]
    ld (l01cfh),hl              ;0561   (l01cfh)=(l031dh)
l0564h:         ;<--; <-----;
    call Locate     ;       ;   ;0564   Locate a symbol in the symbol table from l01dbh-(SizeID)
    jp z,l05d6h ;---)-----; ;   ;0567   if eq.0 (Name found) --> ...
l056ah:      ;<-----)---; ; ;
    call s_0669h    ;   ; ; ;   ;056a   Calculate address next Symbol in Symbol stable
                    ;   ; ; ;           (l01cfh)=(l01cfh)-(SizeID)-6
    ex de,hl        ;   ; ; ;   ;056d                                                               de=(l01cfh)  SP=l0649h
    ld hl,(l0209h)  ;   ; ; ;   ;056e                                                   hl=(l0209h)
    call cmpHL.DE   ;   ; ; ;   ;0571   Compare HL with DE
    ex de,hl        ;   ; ; ;   ;0574                                                   hl=(l01cfh) de=(l0209h)
    jp c,l0564h ;---+   ; ; ;   ;0575   if (l0209h) < (l01cfh) --> Locate a symbol in the symbol table
    ld bc,l05b1h        ; ; ;   ;0578   Point to l05b1h
    push bc             ; ; ;   ;057b \ Save to return                                  hl=(l01cfh) de=(l0209h) SP=l05b1h->l0649h
    ld a,(l0262h)       ; ; ;   ;057c
    cp 8                ; ; ;   ;057f
    ret c          ;--; ; ; ;   ;0581   if (l0262h) < 8             Return to l05b1h                            SP=l0649h
    ld a,(KindID)     ; ; ; ;   ;0582
    cp 6              ; ; ; ;   ;0585
    ret z          ;--; ; ; ;   ;0587   if (KindID).eq.6 (Common)   Return to l05b1h
    dec a             ; ; ; ;   ;0588
    ret z          ;--; ; ; ;   ;0589   if (KindID).eq.1 (Constant) Return to l05b1h
    dec a             ; ; ; ;   ;058a
    ret z          ;--; ; ; ;   ;058b   if (KindID).eq.2 (Label)    Return to l05b1h
    ld a,(l0299h)     ; ; ; ;   ;058c
    cp '('            ; ; ; ;   ;058f
    ret nz         ;--; ; ; ;   ;0591   if (l0298h).ne.'('          Return to l05b1h
    ex (sp),hl        ; ; ; ;   ;0592                                                   hl=l05b1h               SP=(l01cfh)
    ld hl,(l031fh)    ; ; ; ;   ;0593
    ld (l01cfh),hl    ; ; ; ;   ;0596   (l01cfh)=(l031fh)
l0599h:       ;<--;   ; ; ; ;
    call Locate   ;   ; ; ; ;   ;0599   Locate Symbol in the Symbol table from l01dbh-(SizeID)
    jp z,l05d2h ;-)-; ; ; ; ;   ;059c   if a.eq.0 (name found) --> ...
    call s_0669h  ; ; ; ; ; ;   ;059f   Calculate address next Symbol in Symbol stable
                  ; ; ; ; ; ;           (l01cfh)=(l01cfh)-(SizeID)-6
    ex de,hl      ; ; ; ; ; ;   ;05a2                                                               de=(l01cfh)
    ld hl,(l031dh); ; ; ; ; ;   ;05a3   hl=[fa66]                                       hl=(l031dh)
    call cmpHL.DE ; ; ; ; ; ;   ;05a6   Compare HL with DE
    ex de,hl      ; ; ; ; ; ;   ;05a9                                                   hl=(l01cfh) de=(l031dh)
    jp c,l0599h ;-+ ; ; ; ; ;   ;05aa   if (l031dh) < (l01cfh) --> ...
    pop hl          ; ; ; ; ;   ;05ad /                                                 hl=(l01cfh)             SP=l0649h
    ld (l01cfh),hl  ; ; ; ; ;   ;05ae   (l01cfh)=(l01cfh) old value
l05b1h:         ;<--)-+ ; ; ;
    ld (EntryID),hl ;   ; ; ;   ;05b1   (EntryID)=
    ld a,(SizeID)   ;   ; ; ;   ;05b4   3a b8 01
    call s_04e9h    ;   ; ; ;   ;05b7   cd e9 04
    xor a           ;   ; ; ;   ;05ba
    ld (ScopeID),a  ;   ; ; ;   ;05bb   (ScopeID)=0
    ld (SegmID),a   ;   ; ; ;   ;05be   (SegmID)=0 (CSEG)
    ld h,a          ;   ; ; ;   ;05c1
    ld l,a          ;   ; ; ;   ;05c2
    ld (DataID),hl  ;   ; ; ;   ;05c3   (DataID)=0
    call PutAttr    ;   ; ; ;   ;05c6   Put Attributes in Symbol table
    ld a,(KindID)   ;   ; ; ;   ;05c9
    cp 5            ;   ; ; ;   ;05cc
    ret z           ;   ; ; ;   ;05ce   if (KindID).eq.5 (Routine) Return to l0649h
                    ;   ; ; ;
    jp l061eh   ;---)-; ; ; ;   ;05cf   --> ...
                    ; ; ; ; ;
l05d2h:      ;<-----+ ; ; ; ;
    pop bc            ; ; ; ;   ;05d2   Balansig SP
    jp l061bh    ;----)-)-)-)-; ;05d3   --> ...
                      ; ; ; ; ;
l05d6h:       ;<------)-)-+ ; ;         Symbol found
    ld a,(KindID)     ; ;   ; ; ;05d6
    dec a             ; ;   ; ; ;05d9
    ld hl,(l01cfh)    ; ;   ; ; ;05da
    dec hl            ; ;   ; ; ;05dd                                   hl=(l01cfh)-1
    ld a,(hl)         ; ;   ; ; ;05de                                   Load byte from (l01cch)-1
    jp nz,l05efh ;--; ; ;   ; ; ;05df   if (KindID).ne.1 (Constant) --> ...
    rra             ; ; ;   ; ; ;05e2
    rra             ; ; ;   ; ; ;05e3
    rra             ; ; ;   ; ; ;05e4                                   Shift 3 bits to the left
    and 00000111b   ; ; ;   ; ; ;05e5                                   Select 3 low bits
    ld b,a          ; ; ;   ; ; ;05e7                                   b=type variable from Symbols table
    ld a,(TypeID)   ; ; ;   ; ; ;05e8                                   Load value type variable
    cp b            ; ; ;   ; ; ;05eb                                   Compare with value from Symbol table
    jp nz,l056ah ;--)-)-+   ; ; ;05ec   if (TypeID).ne.b --> Calculate address next symbol in the Symbols table
l05efh:       ;<----+ ;     ; ;
    and 00000111b     ;     ; ; ;05ef                                   Select 3 low bits (a=name_id from Symbol table)
    inc hl            ;     ; ; ;05f1                                   hl=(l01cfh)
    ld c,a            ;     ; ; ;05f2   c=name_id from Symbol table
    ld a,(KindID)     ;     ; ; ;05f3
    sub 5             ;     ; ; ;05f6
    jp z,l060eh  ;--; ;     ; ; ;05f8   if (KindID).eq.5 (Routine) --> ...
    dec a           ; ;     ; ; ;05fb
    jp nz,l0608h;-; ; ;     ; ; ;05fc   if (KindID).ne.6 (Common)  --> ...
    ld a,c        ; ; ;     ; ; ;05ff                                   a=name_id from Symbol table
    cp 5          ; ; ;     ; ; ;0600
    jp nc,l060eh;-)-; ;     ; ; ;0602   if name_id from Symbol table >= 5 (Routine) --> ...
    jp l0564h ;---)-)-)-----+ ; ;0605   --> Locate symbol in the symbol table
                  ; ; ;     ; ;
l0608h:       ;<--+ ; ;     ; ;
    ld a,c          ; ;     ; ; ;0608                                   a=name_id from Symbol table
    cp 6            ; ;     ; ; ;0609
    jp z,l0564h ;---)-)-----+ ; ;060b   if name_id from Symbol table.eq.6 (Common) --> Search name in Symbols table
l060eh:      ;<-----+ ;       ;
    ld a,(KindID)     ;       ; ;060e                                   a=(KindID)
    add a,c           ;       ; ;0611                                   a=(KindID)+name_id from Symbol table
    cp 0bh            ;       ; ;0612
    jp nz,l061bh ;-;  ;       ; ;0614   if (KindID)+name_id from Symbol table.ne.0bh --> Skip error message
    call err.msg   ;  ;       ; ;0617   warning (2)
    db 2           ;  ;       ; ;061a   Block Name = Procedure Name
                   ;  ;       ;
l061bh:         ;<-+<-)-------+
    call s_54c8h      ;         ;061b   Extract Attributes from the symbol table, entry( l01cfh)
l061eh:         ;<----+
    cp 3                        ;061e
    ret nz        ;---;         ;0620   if (KindID).ne.3 (Variable) Return to l0649h
    ld a,(l0262h)     ;         ;0621
    cp 8              ;         ;0624
    ret c         ;---;         ;0626   if(l0262h) < 8    Return to l0649h
    ld hl,(CurAdr)    ;         ;0627   hl=Address current program Processing statement
    ld de,PrCall      ;         ;062a   de=Address program Processing CALL
    call cmpHL.DE     ;         ;062d
    ret z         ;---;         ;0630   if(CurAdr).eq.PrCall Return to l0649h
    ld a,(l01d9h)     ;         ;0631   3a d9 01
    cp 02ah           ;         ;0634
    ret z         ;---;         ;0636   if(l01d9h).eq.2ah Return to l0649h
    ld a,(l0243h)     ;         ;0637
    or a              ;         ;063a
    jp nz,s_0cffh     ;         ;063b   if(l0243h).ne.0 --> ...
    ld a,(l0299h)     ;         ;063e
    cp '('            ;         ;0641
    jp nz,s_0cffh     ;         ;0643   if(l0299h).ne.'(' --> ...
    jp s_0a10h        ;         ;0646   --> ...
                      ;
l0649h:         ;<----+
    ld hl,(l01cfh)              ;0649   2a cf 01
    ret                         ;064c   
;*
;*  Locate Symbol in the Symbol table from DataID-(SizeID)
;*    ENTRY Reg HL - ADDR
;*    EXIT  Zero set - if the name found in the symbols table
;*
Locate:
    ld a,(hl)           ;064d   Load byte from (ADDR)
    and 7fh             ;064e   Clear high bit (a=(SIZ))
    ld b,a              ;0650   b=(SIZ)
    ld a,(SizeID)       ;0651
    cp b                ;0654
    ret nz              ;0655   if (SizeID).ne.(SIZ) Return
    push af             ;0656 \ Save (SizeID)
    cpl                 ;0657
    ld c,a              ;0658
    ld b,0ffh           ;0659   bc = -(SizeID)
    ex de,hl            ;065b                       de=ADDR
    ld hl,l01dbh        ;065c   hl=l01dbh
    add hl,bc           ;065f   hl=l01dbh-(SizeID)
    ex de,hl            ;0660   hl=ADDR             de=l01dbh-(SizeID)
    sub 4               ;0661
    ld c,a              ;0663   c=(SizeID)-4
    add hl,bc           ;0664   hl=ADDR-(SizeID)-4
    pop bc              ;0665 / b=(SizeID)
    jp cmpstr           ;0666   --> Compare strings ^HL:^DE with length in B
;*
;*  Calculate address next symbol in the Symbols table (l01cfh)=(l01cfh)-(SizeID)-6
;*
s_0669h:
    ld hl,(l01cfh)      ;0669
    ld a,(hl)           ;066c   Load byte from (l01cfh)
    and 7fh             ;066d   Clear high bit (a=(SizeID))
    cpl                 ;066f
    sub 005h            ;0670
    ld c,a              ;0672
    ld b,0ffh           ;0673
    add hl,bc           ;0675
    ld (l01cfh),hl      ;0676   (l01cfh)=(l01cfh)-(SizeID)-6
    ret                 ;0679
;*
;*  Compare strings ^HL:^DE with length in B
;*
cmpstr:
l067ah:         ;<--;
    ld a,(de)       ;   ;067a   
    cp (hl)         ;   ;067b   
    ret nz          ;   ;067c   if(de).ne.(hl) returm
    inc de          ;   ;067d   de=de+1
    inc hl          ;   ;067e   hl=hl+1
    dec b           ;   ;067f   b=b-1
    jp nz,l067ah ;--+   ;0680   if b.ne.0 compare next letter
    ret                 ;0683
;
;-------------------------------------------------- bred
    ld bc,02f3ah        ;0684   01 3a 2f 
l0687h:
    sub 00ah            ;0687   d6 0a
    inc b               ;0689   04
    jp nc,l0687h        ;068a   d2 87 06 
    add a,c             ;068d   81
    ld c,a              ;068e   4f
    ret                 ;068f
;---------------------------------------------- end bred
;*
;*  BLOCK DATA [subprogram-name]
;*
PrBlockdata:
    xor a               ;0690
    ld (l0173h),a       ;0691   (l0173h)=0
    inc a               ;0694
    ld (BlkDat),a       ;0695   (BlkDat)=1 (Block data)
    ld (l0262h),a       ;0698   (l0262h)=1
    jp PrProgram        ;069b   --> Processing PROGRAM
;
;
;
main:
    ld hl,0f800h        ;069e   hl = -8
    xor a               ;06a1   a=0
    ld (l01b9h),a       ;06a2   (l01b9h)=0
    ld (l0159h),hl      ;06a5   Reset bit count
    ld hl,l06aeh        ;06a8   hl=Point to Start F80
    jp l2c51h           ;06ab   --> Parse command line
;
; Start F80
; ENTRY Reg HL holds available top of memory
;       Reg B holds number of pages for extra stack (/P option)
;
l06aeh:
    ld (TopMem),hl      ;06ae   Save value Top of Memory (TopMem)=[fe05]
    ld sp,hl            ;06b1   Set for stack
    ld de,0ff38h        ;06b2   Size page extra stack
l06b5h:          ;<-;
      add hl,de     ;   ;06b5   hl=fe05+fe70=fe75
      dec b         ;   ;06b6   b=b-1
    jp nz,l06b5h ;--+   ;06b7   if b.ne.0 --> ...
    ld (TopDat),hl      ;06ba   Save value Top of data
    ld a,(enaLST)       ;06bd   Test list enabled
    or a                ;06c0
    jp z,l070ch         ;06c1   if(enaLST).eq.0 --> Compile module
    ld hl,l0823h        ;06c4   hl='FORTRAN-80...'
    call PrStrg         ;06c7   Print string
    ld hl,l06e5h        ;06ca   hl='BYTES:'
    call PrStrg         ;06cd   Print string
    ld hl,(TopDat)      ;06d0   Load value Top of data
    ld de,l68f7h        ;06d3   Address of the first byte of the data area
    call subHL.DE       ;06d6   hl=hl-de Size data area
    call PrNumb         ;06d9   Print number in HL as decimal number
    ld hl,l06f0h        ;06dc   hl='Created: 10-Dec-81'
    call PrStrg         ;06df   Print string
    jp l070ch           ;06e2   --> Compile module
;
l06e5h:
    dc ' -- Bytes: '    ;06e5
l06f0h:
    db  cr,lf,'Created: 10-Dec-81',cr,8ah
;
;   Compile next module
;
l0706h:
    call p.crlf         ;0706   Put cr lf to console
    call p.crlf         ;0709   Put cr lf to console
;
;   Compile module
;
l070ch:
    ld hl,(TopMem)      ;070c   Load value Top of memory
    ld sp,hl            ;070f   Set for stack
    ld hl,00000h        ;0710   hl=0
    ld (NumSrc),hl      ;0713   Line number source file = 0
    call ClrBuf20       ;0716   Clear buffer ^l02b5h length 20
    ld a,(l01b9h)       ;0719
    or a                ;071c
    call z,s_19c6h      ;071d   if (l01b9h).eq.0 call ...
    ld a,(l01b9h)       ;0720
    or a                ;0723
    jp z,l073bh ;---;   ;0724   if (l01b9h).eq.0 --> Initialization before compiling
    ld c,0fh        ;   ;0727   c=15 REL types - END FILE
    call RELITEM    ;   ;0729   Give end file
    call w.byte     ;   ;072c   Put byte to REL file from Reg B
    call lclose     ;   ;072f   Close list file
    call oclose     ;   ;0732   Close REL file
    call sclose     ;   ;0735   Close source file
    jp main         ;   ;0738
                    ;
l073bh:         ;<--+
;
;   Initialization before compiling
;
    ld hl,StartZ        ;073b   ;** Start of zeroed area **
    ld de,EndZ          ;073e   ;** End of Zeroed Area **
;
;   Reset variables
;
l0741h:            ;<-;
      ld (hl),0       ; ;0741   (hl)=0
      inc hl          ; ;0743   hl=hl+1
      call cmpHL.DE   ; ;0744   Compare HL with DE
    jp nz,l0741h   ;--+ ;0747   if HL.ne.EndZ --> Initialize next byte
;
    ld hl,NumMod        ;074a
    ld a,(hl)           ;074d
    or a                ;074e   if (NumMod).ne.0 --> hl,(l031bh); goto l0793h
    jp nz,l081dh    ;-- ;074f   (skip initial initializing the symbol table)
                    ;           Increment counter compiled program modules
    inc (hl)        ;   ;0752   (NumMod)=(NumMod)+1
    ld hl,(TopDat)  ;   ;0753   Load value Top of Data
    ld (l031fh),hl  ;   ;0756   (l031fh)=(TopDat)
    push hl         ;   ;0759 \ Save value (TopDat)         [FC75]
    ld de,lent2     ;   ;075a   Length data Table Intrinsic functions
    call cmp1HL.DE  ;   ;075d   hl=(TopDat)-lent2
    ld (l031dh),hl  ;   ;0760   (l031dh)=(TopDat)-lent2     [fa66]
    inc hl          ;   ;0763   Create a destination address
    ex de,hl        ;   ;0764    de=(TopDat)-lent2+1        [FA67]
    ld hl,IntrFun   ;   ;0765    hl=Point to Table Intrinsic functions
    ld bc,lent2     ;   ;0768    bc=Length data transferred
    call MoveBC     ;   ;076b   Move BC bytes from ^HL to ^DE
    pop hl          ;   ;076e / Restore value (TopDat)      [FC75]
    ld de,lent2     ;   ;076f   Length data Table Intrinsic functions
    call cmp1HL.DE  ;   ;0772   hl=(TopDat)-lent2
    ld de,lent1     ;   ;0775   Length of service data in the symbol table
    call cmp1HL.DE  ;   ;0778   hl=(TopDat)-lent2-lent1
    inc hl          ;   ;077b   Create a destination address
    ex de,hl        ;   ;077c    de=(TopDat)-lent2-lent1+1  [FA05]
    ld hl,l68f7h    ;   ;077d    hl=Point to Table service data in the symbol table
    ld bc,lent1     ;   ;0780    bc=Length data transferred
    call MoveBC     ;   ;0783   Move BC bytes from ^HL to ^DE
    ld hl,(TopDat)  ;   ;0786   
    ld de,lent2     ;   ;0789   
    call cmp1HL.DE  ;   ;078c   hl=(TopDat)-lent2
    ld de,lent1     ;   ;078f   
    call cmp1HL.DE  ;   ;0792   hl=(TopDat)-lent2-lent1     [FA04]
l0795h:         ;<--+
    ld (l0209h),hl      ;0795   (l0209h)= [FA04]
    ld (HeapEnd),hl     ;0798   (HeapEnd)=[FA04]
    ld (l020ch),hl      ;079b   (l020ch)= [FA04]
    ld (l031bh),hl      ;079e   (l031bh)= [FA04]
    ex de,hl            ;07a1   de=(l031ah)                 [FA04]
    ld hl,offs6         ;07a2
    add hl,de           ;07a5
    ld (l02afh),hl      ;07a6   (l02afh)=offs6+(l031ah)     [FA4E]=4a+fa04
    ld hl,lent1         ;07a9
    add hl,de           ;07ac
    ld (l023dh),hl      ;07ad   (l023dh)=lent1+(l031ah)     [FA66]=62+fa04
    ld hl,offs2         ;07b0
    add hl,de           ;07b3
    ld (l02b1h),hl      ;07b4   (l02b1h)=offs2+(l031ah)     [FA22]=1e+fa04
    ld hl,offs3         ;07b7
    add hl,de           ;07ba
    ld (l023fh),hl      ;07bb   (l023fh)=offs3+(l031ah)     [FA2C]=28+fa04
    ld hl,offs4         ;07be
    add hl,de           ;07c1
    ld (l02a1h),hl      ;07c2   (l02a1h)=offs4+(l031ah)     [FA36]=32+fa04
    ld hl,offs5         ;07c5
    add hl,de           ;07c8
    ld (l02b3h),hl      ;07c9   (l02b3h)=offs5+(l031ah)     [FA40]=3c+fa04
    ld hl,offs7         ;07cc
    add hl,de           ;07cf
    ld (l0241h),hl      ;07d0   (l0241h)=offs7+(l031ah)     [FA58]=54+fa04
    ld hl,(l031dh)      ;07d3   hl=(l031dh)=fa66
    ld de,00180h        ;07d6
    add hl,de           ;07d9
    ld (l01c6h),hl      ;07da   (l01c6h)=fa66+180=fbe6
    ld hl,l68f7h        ;07dd
    ld (l01b0h),hl      ;07e0   (l01b0h)=68f7
    ld (l01a4h),hl      ;07e3   (l01a4h)=68f7
    ld (l0217h),hl      ;07e6   (l0217h)=68f7
    ld (HeapPtr),hl     ;07e9   (HeapPtr)=68f7
    ld hl,00001h        ;07ec
    ld (DatSiz),hl      ;07ef   (DatSiz)=1
;
;   Define default variable types
;
    ld hl,TypeDef       ;07f2   hl=Pointer table type definitions variables
;
;   Define A-H as REAL
;
    ld a,1              ;07f5   a=1 (REAL)
    ld b,8              ;07f7   b=8
l07f9h:          ;<-;
      ld (hl),a     ;   ;07f9   (hl)=1
      inc hl        ;   ;07fa   hl=hl+1
      dec b         ;   ;07fb   b=b-1
    jp nz,l07f9h ;--+   ;07fc   if b.ne.0 --> ...
;
;   Define I-N as INTEGER
;
    ld c,6              ;07ff   c=6
l0801h:          ;<-;
      ld (hl),b     ;   ;0801   (hl)=0 (INTEGER)
      dec c         ;   ;0802   c=c-1
      inc hl        ;   ;0803   hl=hl+1
    jp nz,l0801h ;--+   ;0804   if c.ne.0 --> ...
;
;   Define O-Z as REAL
;
    ld b,0ch            ;0807   b=12
l0809h:          ;<-;
      ld (hl),a     ;   ;0809   (hl)=1 (REAL)
      inc hl        ;   ;080a   hl=hl+1
      dec b         ;   ;080b   b=b-1
    jp nz,l0809h ;--+   ;080c   if b.ne.0 --> ...

    jp Firstep           ;080f  --> First step of the compilation
;
;--------------------------------
;   Move BC bytes from ^HL to ^DE
;--------------------------------
MoveBC:
l0812h:         ;<--;
    ld a,(hl)       ;   ;0812
    ld (de),a       ;   ;0813   (de)=(hl)
    inc de          ;   ;0814   de=de+1
    inc hl          ;   ;0815   hl=hl+1
    dec bc          ;   ;0816   bc=bc-1
    ld a,b          ;   ;0817
    or c            ;   ;0818
    jp nz,l0812h ;--+   ;0819   if bc.ne.0 Move next byte
    ret                 ;081c
;
l081dh:
    ld hl,(l031bh)      ;081d   2a 1b 03
    jp l0795h           ;0820   --> ...
;
l0823h:
    dc  'FORTRAN-80 Ver. 3.44 Copyright 1978-1981 (C) By Microsoft'
;*
;*  hl=hl-de
;*
cmp1HL.DE:
    ld a,l              ;085c
    sub e               ;085d   Subtract LO
    ld l,a              ;085e
    ld a,h              ;085f
    sbc a,d             ;0860   .. and HI
    ld h,a              ;0861
    ret                 ;0862   
;
;+  Move B bytes from ^HL to ^DE
;
l0863h:        ;<---;
    ld a,(hl)       ;   ;0863
    ld (de),a       ;   ;0864   (de)=(hl)
    inc hl          ;   ;0865   hl=hl+1
    inc de          ;   ;0866   de=de+1
    dec b           ;   ;0867   b=b-1
    jp nz,l0863h ;--+   ;0868   if b.ne.0 Move next byte
    ret                 ;086b
;
;   Processing CALL name or CALL name(par1,par2,...,parn)
;
PrCall:
    call PrName         ;086c   Processing name
    call s_0a10h        ;086f   cd 10 0a
    ld a,(l0299h)       ;0872
    cp '('              ;0875
    jp z,l0889h ;---;   ;0877   if (l0299h).eq.'(' --> Processing actual parameters
    call s_1479h    ;   ;087a   cd 79 14
l087dh:          ;<-)-;
    ld hl,00000h    ; ; ;087d   hl=0
    ld (CurAdr),hl  ; ; ;0880   (CurAdr)=0
    call s_41f7h    ; ; ;0883   cd f7 41
    jp l09ebh       ; ; ;0886   --> Clear (l029ah) & (DO_Flg) -> Ending parsing
                    ; ;
l0889h:         ;<--+ ;         Processing of the actual parameters
    ld hl,00000h      ; ;0889   hl=0
    ld (CurAdr),hl    ; ;088c   (CurAdr)=0
    ld a,0ffh         ; ;088f   a= -1
    call s_14e2h      ; ;0891   cd e2 14
    call s_0ea4h      ; ;0894   cd a4 0e
    call s_606eh      ; ;0897   cd 6e 60
    jp l087dh   ;-----+ ;089a   --> ...
;
;   Creating built-in routine
;     ENTRY reg BC
;
CrBuilt:
    ld hl,l01d9h        ;089d
    ld a,c              ;08a0
    cp 05bh             ;08a1
    jp c,l08a9h ;---;   ;08a3   if c < 5bh --> ...
    sub 02ch        ;   ;08a6   d6 2c
    ld c,a          ;   ;08a8   4f  O
l08a9h:     ;<------+
    ld (hl),'$'         ;08a9   (l01d9h)='$'
    dec hl              ;08ab
    ld (hl),b           ;08ac   (l01d8h)=b
    dec hl              ;08ad
    ld (hl),c           ;08ae   (l01d7h)=c
    ld a,3              ;08af
    ld (SizeID),a       ;08b1   (SizeID)=3
    ld a,5              ;08b4
    ld (KindID),a       ;08b6   (KindID)=5 (Routine)
    ld a,(i_Type)       ;08b9
    push af             ;08bc \ Save (i_Type)
    ld hl,(l01cfh)      ;08bd
    push hl             ;08c0 \ Save (l01cfh)
    ld a,(l0299h)       ;08c1
    push af             ;08c4 \ Save (l0299h)
    ld a,'('            ;08c5
    ld (l0299h),a       ;08c7   (l0299h)='('
    call s_055ah        ;08ca   cd 5a 05
    call s_4551h        ;08cd   cd 51 45
    pop af              ;08d0 /
    ld (l0299h),a       ;08d1   Restore (l0299h)
    pop hl              ;08d4 / Restore (l01cfh)
    pop af              ;08d5 /
    ld (i_Type),a       ;08d6   Restore (i_Type)
    jp ExtAttr          ;08d9   --> Extract Attributes from the symbol table
;
;
;
s_08dch:
    ld a,(NumDim)       ;08dc
    cp 3                ;08df
    ld de,00000h        ;08e1
    jp nz,l08fch ;--;   ;08e4   if (NumDim).ne.3 {de=0--> ...}
                    ;
;   Three-dimensional array
                    ;
    push af         ;   ;08e7 \
    ld hl,(l0274h)  ;   ;08e8
    ld bc,-8        ;   ;08eb
    add hl,bc       ;   ;08ee   hl=(l0274h)-8
    ld b,(hl)       ;   ;08ef   46
    dec hl          ;   ;08f0   2b
    ld c,(hl)       ;   ;08f1   4e
    dec bc          ;   ;08f2   0b
    ld hl,(l026ch)  ;   ;08f3   2a 6c 02
    ex de,hl        ;   ;08f6   eb
    call s_5798h    ;   ;08f7   cd 98 57
    ex de,hl        ;   ;08fa   eb
    pop af          ;   ;08fb /
                    ;
l08fch:       ;<----+
    cp 2                ;08fc
    jp c,l0918h  ;--;   ;08fe   if (NumDim) < 2 --> ...
                    ;
;   Two-dimensional array
                    ;
    ld hl,(l0272h)  ;   ;0901
    ld bc,-8        ;   ;0904
    add hl,bc       ;   ;0907   hl=(l0272h)-8
    ld b,(hl)       ;   ;0908   46
    dec hl          ;   ;0909   2b
    ld c,(hl)       ;   ;090a   4e
    dec bc          ;   ;090b   0b
    ex de,hl        ;   ;090c   eb
    add hl,bc       ;   ;090d   09
    ld b,h          ;   ;090e
    ld c,l          ;   ;090f   bc=hl
    ld hl,(l026ah)  ;   ;0910   2a 6a 02
    ex de,hl        ;   ;0913   eb
    call s_5798h    ;   ;0914   cd 98 57
    ex de,hl        ;   ;0917   eb
                    ;
l0918h:       ;<----+
;
;   One-dimensional array
;
    ld hl,(l0270h)      ;0918   2a 70 02
    ld bc,-8            ;091b   0fff8h
    add hl,bc           ;091e   09
    ld b,(hl)           ;091f   46
    dec hl              ;0920   2b
    ld c,(hl)           ;0921   4e
    dec bc              ;0922   0b
    ex de,hl            ;0923   eb
    add hl,bc           ;0924   09
    ex de,hl            ;0925   eb
    ld a,(l02abh)       ;0926
    ld c,a              ;0929
    ld b,0              ;092a   bc=(l02abh)
    jp s_5798h          ;092c   --> ...
;
;+  Test continue processing statement
;
l092fh:
    ld a,(l0299h)       ;092f
    cp ','              ;0932   Test separator
    jp nz,l09ebh        ;0934   if (l0299h).ne.',' --> Clear (l029ah) & (DO_Flg) -> Ending parsing
    ld hl,(CurAdr)      ;0937   Address current program Processing statement
    jp (hl)             ;093a   go to (CurAdr)
;
;+  Compare HL with DE
;     ENTRY Reg HL and DE hold pointer
;     EXIT  Carry set if HL<DE
;           Zero  set if HL=DE
cmpHL.DE:
    ld a,h              ;093b   Compare HI
    sub d               ;093c
    ret nz              ;093d   .. exit if .NEQ.
    ld a,l              ;093e   Compare LO
    sub e               ;093f
    ret                 ;0940
;
;+  (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
;
s_0941h:
    ld hl,00000h        ;0941   hl=0
s_0944h:
    ld (l01d2h),hl      ;0944   (l01d2h)=
    ld (l01d4h),hl      ;0947   (l01d4h)=
    ld (l01d6h),hl      ;094a   (l01d6h)=
    ld (l01d8h),hl      ;094d   (l01d8h)=
    ret                 ;0950
;
;+  Initialization field l01dah 8-byte character ' '
;
s_0951h:
    ld a,' '            ;0951
s_0953h:
    ld b,8              ;0953   b=8 counter
    ld hl,l01dah        ;0955   address of the buffer to hold the string
l0958h:
    ld (hl),a           ;0958   save to buffer
    dec b               ;0959   b=b-1
    inc hl              ;095a   hl=hl+1
    jp nz,l0958h        ;095b   test b.ne.0
    ret                 ;095e
;
;   Processing COMMON /y1/a1 /y2/a2/.../yn/an
;
PrCommon:
    call g_n_chr                ;095f   Get next character
    cp '/'                      ;0962
    jp z,l09cfh  ;------------; ;0964   if chr.eq.'/' --> Processing COMMON block storage name
    ld (l0173h),a             ; ;0967   (l0173h)=chr
l096ah:             ;<------; ;
    ld a,1                  ; ; ;096a
    ld (SizeID),a           ; ; ;096c   (SizeID)=1
    ld a,0a0h               ; ; ;096f
    ld (l01d9h),a           ; ; ;0971   (l01d9h)=0a0h
l0974h:             ;<----; ; ;
    ld a,6                ; ; ; ;0974   a=6
    ld (KindID),a         ; ; ; ;0976   (KindID)=6 (Common)
    call s_055ah          ; ; ; ;0979   cd 5a 05
    ld (l0178h),hl        ; ; ; ;097c   (l0178h)=
l097fh:             ;<--; ; ; ;
    call PrName         ; ; ; ; ;097f   Processing name (common variable)
    ld a,(ScopeID)      ; ; ; ; ;0982
    or a                ; ; ; ; ;0985
    jp nz,wrn004 ;--;   ; ; ; ; ;0986   if (ScopeID).ne.0 --> Warning (4) COMMON Name Usage
    ld a,(KindID)   ;   ; ; ; ; ;0989
    sub 4           ;   ; ; ; ; ;098c
    jp z,l09a1h  ;--)-; ; ; ; ; ;098e   if (KindID).eq.4 (Array) --> ...
    inc a           ; ; ; ; ; ; ;0991
    jp z,l0999h ;-; ; ; ; ; ; ; ;0992   if (KindID).eq.3 (Variable) --> skip error message
wrn004:      ;<---)-+ ; ; ; ; ;
    call err.msg  ;   ; ; ; ; ; ;0995   Warning (4)
    db 4          ;   ; ; ; ; ; ;0998   COMMON Name Usage
l0999h:     ;<----+   ; ; ; ; ;
    ld a,(l0299h)     ; ; ; ; ; ;0999
    cp '('            ; ; ; ; ; ;099c
    call z,s_19eeh    ; ; ; ; ; ;099e   if (l0299h).eq.'(' --> Processing subscript an array
l09a1h:         ;<----+ ; ; ; ;
    call l68bbh         ; ; ; ; ;09a1   cd bb 68
    push hl             ; ; ; ; ;09a4 \ e5
    ld hl,(l0178h)      ; ; ; ; ;09a5
    ld (EntryID),hl     ; ; ; ; ;09a8   (EntryID)=(l0178h)
    dec hl              ; ; ; ; ;09ab
    dec hl              ; ; ; ; ;09ac   hl=hl-2
    ld d,(hl)           ; ; ; ; ;09ad   56
    dec hl              ; ; ; ; ;09ae   2b
    ld e,(hl)           ; ; ; ; ;09af   5e
    ex (sp),hl          ; ; ; ; ;09b0   e3 
    add hl,de           ; ; ; ; ;09b1   19 
    ex de,hl            ; ; ; ; ;09b2   eb 
    ld (DataID),hl      ; ; ; ; ;09b3   (DataID)=
    pop hl              ; ; ; ; ;09b6   e1
    ld (hl),e           ; ; ; ; ;09b7   73
    inc hl              ; ; ; ; ;09b8   23
    ld (hl),d           ; ; ; ; ;09b9   72
    ld a,1              ; ; ; ; ;09ba   a=1
    ld (ScopeID),a      ; ; ; ; ;09bc   (ScopeID)=1
    call PutAttr        ; ; ; ; ;09bf   Put Attributes in Symbol table
    ld a,(l0299h)       ; ; ; ; ;09c2
    cp ','              ; ; ; ; ;09c5
    jp z,l097fh   ;-----+ ; ; ; ;09c7   Test separator
    cp '/'                ; ; ; ;09ca
    jp nz,l09ebh          ; ; ; ;09cc   Clear (l029ah) & (DO_Flg) -> Ending parsing
                          ; ; ;
;   Processing COMMON block storage name
                          ; ; ;
l09cfh:              ;<---)-)-+ 
    call s_1cbbh          ; ;   ;09cf   cd bb 1c
    ld a,'/'              ; ;   ;09d2   a='/'
    call ch.chr           ; ;   ;09d4   Check character (a character for check)
    ld a,(KindID)         ; ;   ;09d7
    or a                  ; ;   ;09da
    jp z,l096ah     ;-----)-+   ;09db   if (KindID).eq.0 --> ...
    ld hl,l01d9h          ;     ;09de
    ld a,(hl)             ;     ;09e1
    or 080h               ;     ;09e2
    ld (hl),a             ;     ;09e4   (l01d9h)=(l01d9h).or.10000000b
    jp l0974h     ;-------+     ;09e5   --> ...
;*
;*  Processing CONTINUE
;*
PrContinue:
    call g_n_chr        ;09e8   Get next character
;*
;*  Clear (l029ah) & (DO_Flg) -> Ending parsing statement
;*
l09ebh:
    xor a               ;09eb   a=0
    jp l25beh           ;09ec   Save (l029ah) & (DO_Flg) -> Ending
;*
;*  Converting value Integer to Real
;*
s_09efh:
    push bc             ;09ef
    ld bc,'CA'          ;09f0   $CA - Integer to Real
    call CrBuilt        ;09f3   Creating built-in routine
    ld a,1              ;09f6
    ld (i_Type),a       ;09f8   (i_Type)=1 (REAL)
    pop bc              ;09fb
    ret                 ;09fc
;*
l09fdh:
    ld a,'S'            ;09fd   'S'
    db 011h   ;--;      ;09ff   ld de,0433eh (in the original) trap_ms
l0a00h:          ;
    ld a,'C'     ;      ;0a00   $CC - Integer to Double
    db 011h      ;      ;0a02   ld de,l4b3eh (in the original) trap_ms
l0a03h:     ;<---+
    ld a,'K'            ;0a03   $CK - Real to Double
    push bc             ;0a05
    ld c,a              ;0a06
    ld b,'C'            ;0a07   'C'
    call CrBuilt        ;0a09   Creating built-in routine
    ld a,3              ;0a0c   a=3 (DOUBLE)
    pop bc              ;0a0e
    ret                 ;0a0f
;
;
;
s_0a10h:
    ld de,PrRead            ;0a10   Address program processing READ, WRITE
    ld hl,(CurAdr)          ;0a13   Address current program Processing statement
    call cmpHL.DE           ;0a16
    ret z                   ;0a19   if (CurAdr).eq.PrRead Return
    ld a,(KindID)           ;0a1a
    cp 5                    ;0a1d
    ret z                   ;0a1f   if (KindID).eq.5 (Routine) Return
    cp 3                    ;0a20
    jp nz,err106    ;---;   ;0a22   if (KindID).ne.3 (Variable) --> Error (106) Illegal Procedure Name
    ld a,(ScopeID)      ;   ;0a25
    or a                ;   ;0a28
    jp z,l0a3bh ;--;    ;   ;0a29   if (ScopeID).eq.0 --> ...
    cp 3           ;    ;   ;0a2c
    jp z,l0a43h ;--)--; ;   ;0a2e   if (ScopeID).eq.3 --> ...
    ld hl,00000h   ;  ; ;   ;0a31
    ld (DataID),hl ;  ; ;   ;0a34   (DataID)=0
    ld a,h         ;  ; ;   ;0a37
    ld (ScopeID),a ;  ; ;   ;0a38   (ScopeID)=0
l0a3bh:       ;<---+  ; ;
    ld hl,(DataID)    ; ;   ;0a3b
    ld a,h            ; ;   ;0a3e
    or l              ; ;   ;0a3f
    jp nz,err106 ;-;  ; ;   ;0a40   if (DataID).ne.0 --> Error (106) Illegal Procedure Name
l0a43h:       ;<---)--+ ;
    ld a,5         ;    ;   ;0a43
    ld (KindID),a  ;    ;   ;0a45   (KindID)=5 (Routine)
    jp PutAttr     ;    ;   ;0a48   --> Put Attributes in Symbol table
err106:       ;<---+ <--+
    call err.msg            ;0a4b   Error (106)
    db 106                  ;0a4e   Illegal Procedure Name
;
;   Processing DATA (DATA list/ul,u2,...,un/,...)
;
PrData:
    ld hl,(PrgSiz)          ;0a4f
    push hl                 ;0a52 \ Save (PrgSiz)
    ld hl,00001h            ;0a53
    ld (l027eh),hl          ;0a56   (l027eh)=1
    dec hl                  ;0a59   hl=0
    add hl,sp               ;0a5a   hl=Stack pointer
    ld (l0217h),hl          ;0a5b   (l0217h)=Stack pointer
    ld (l028eh),hl          ;0a5e   (l028eh)=Stack pointer
l0a61h:         ;<--;
    call ChkVar     ;       ;0a61   Check that the name refers to a variables
    ld a,(ScopeID)  ;       ;0a64
    dec a           ;       ;0a67
    jp z,l0a76h ;-; ;       ;0a68   if (ScopeID).eq.1 --> ...
    ld a,(BlkDat) ; ;       ;0a6b   Load Flag Block data
    or a          ; ;       ;0a6e
    jp z,l0a76h ;-; ;       ;0a6f   if (BlkDat).eq.0 (not Block data)--> skip error message
    call err.msg  ; ;       ;0a72   Warning (9)
    db 9          ; ;       ;0a75   Non-COMMON Variable in BLOCK DATA
l0a76h:        ;<-+ ;
    call s_0cffh    ;       ;0a76   cd ff 0c
    ld hl,(l01cfh)  ;       ;0a79   2a cf 01
    call ChkStack   ;       ;0a7c   Check the stack
    push hl         ;       ;0a7f \ e5
    xor a           ;       ;0a80   a=0
    push af         ;       ;0a81 \ f5
    ld a,(l0299h)   ;       ;0a82
    cp '('          ;       ;0a85
    jp z,l0a9ah ;-; ;       ;0a87   if (l0299h).eq.'(' --> ...
l0a8ah:      ;<---)-)-;
    ld a,(l0299h) ; ; ;     ;0a8a
    cp ','        ; ; ;     ;0a8d
    jp z,l0a61h ;-)-+ ;     ;0a8f   if (l0299h).eq.',' --> ...
    ld a,'/'      ;   ;     ;0a92
    call ch.chr   ;   ;     ;0a94   Check character (a character for check)
    jp l0ab8h   ;-)-; ;     ;0a97   --> ...
                  ; ; ;
l0a9ah:       ;<--+ ; ;
    call DimDecl    ; ;     ;0a9a   Processing Dimension declarators
    ld a,(NumDim)   ; ;     ;0a9d
    ld hl,l0230h    ; ;     ;0aa0
    cp (hl)         ; ;     ;0aa3
    jp z,l0aabh ;-; ; ;     ;0aa4   if(NumDim).eq.(l0230h) --> skip error message
    call err.msg  ; ; ;     ;0aa7   Error (136)
    db 136        ; ; ;     ;0aaa   Wrong Number of Subscripts
                  ; ; ;
l0aabh:       ;<--+ ; ;
    call s_556ah    ; ;     ;0aab   cd 6a 55
    pop af          ; ;     ;0aae / f1
    cpl             ; ;     ;0aaf   2f
    push af         ; ;     ;0ab0 \ f5
    call s_08dch    ; ;     ;0ab1   cd dc 08
    push hl         ; ;     ;0ab4   e5
    jp l0a8ah ;-----)-+     ;0ab5   --> ...
                    ;
l0ab8h:         ;<--+
    ld a,1                  ;0ab8
    ld (l025ah),a           ;0aba   (l025ah)=1
l0abdh:
    ld hl,00001h            ;0abd
    ld (l0283h),hl          ;0ac0   (l0283h)=1
l0ac3h:         ;<--------;
    call s_0941h          ; ;0ac3   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
    call g_n_chr          ; ;0ac6   Get next character
    cp 'Z'                ; ;0ac9
    jp z,l0b08h  ;------; ; ;0acb   if chr.eq.'Z' --> Expected single quote & 4 hexadecimal digits
    cp 'X'              ; ; ;0ace
    jp z,l0b08h  ;------; ; ;0ad0   if chr.eq.'X' --> Expected single quote & 4 hexadecimal digits
    ld hl,l01ceh        ; ; ;0ad3
    ld (hl),0ffh        ; ; ;0ad6   (l01ceh)=0ffh
    cp ''''             ; ; ;0ad8   Test single quote
    jp z,l0b71h  ;----; ; ; ;0ada   if chr.eq.'''' --> ...
    ld (l0173h),a     ; ; ; ;0add   (l0173h)=chr
    call s_1cbbh      ; ; ; ;0ae0   cd bb 1c
    ld a,(KindID)     ; ; ; ;0ae3
    dec a             ; ; ; ;0ae6   if (KindID).ne.1 (Constant)
    jp nz,err107      ; ; ; ;0ae7      --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l0243h)     ; ; ; ;0aea
    cp 2              ; ; ; ;0aed
    jp nz,l0b6ah ;--; ; ; ; ;0aef   if (l0243h).ne.2 --> ...
    ld a,(TypeID)   ; ; ; ; ;0af2
    or a            ; ; ; ; ;0af5   if (TypeID).ne.0 (INTEGER)
    jp nz,err107    ; ; ; ; ;0af6      --> Error (107) Invalid DATA Constant or Repeat Factor
    ld hl,(l01d6h)  ; ; ; ; ;0af9
    ld (l0283h),hl  ; ; ; ; ;0afc   (l0283h)=(l01d6h)
    ld a,h          ; ; ; ; ;0aff
    or l            ; ; ; ; ;0b00
    jp nz,l0ac3h ;--)-)-)-+ ;0b01   if(l0283h).ne.0 --> ...
err107:             ; ; ;
    call err.msg    ; ; ;   ;0b04   Error (107)
    db 107          ; ; ;   ;0b07   Invalid DATA Constant or Repeat Factor
                    ; ; ;
l0b08h:      ;<-----)-;-+ 
                    ; ; 
;   Expected single quote & 4 hexadecimal digits
                    ; ;
    call g_n_chr    ; ;     ;0b08   Get next character
    cp ''''         ; ;     ;0b0b   Test single quote
    jp nz,err107    ; ;     ;0b0d   if chr.ne.'''' --> Error (107) Invalid DATA Constant or Repeat Factor
    call l1ae4h     ; ;     ;0b10   cd e4 1a
    ld a,8          ; ;     ;0b13   a=8
    jp l0b76h   ;---)-)-;   ;0b15   --> Save value type definitions variable ...
                    ; ; ;
l0b18h:             ; ; ;
    ld bc,l0c29h    ; ; ;   ;0b18   Point to l0c29h
    push bc         ; ; ;   ;0b1b   Save to return
    ld a,(l0282h)   ; ; ;   ;0b1c
    cp 3            ; ; ;   ;0b1f
    ret z           ; ; ;   ;0b21   if (l0282h).eq.3 return to l0c29h
    ld hl,(l01deh)  ; ; ;   ;0b22
    ld a,h          ; ; ;   ;0b25
    or l            ; ; ;   ;0b26
    ld hl,(l01e0h)  ; ; ;   ;0b27
    or h            ; ; ;   ;0b2a
    or l            ; ; ;   ;0b2b
    jp z,l0b33h ;-; ; ; ;   ;0b2c   if (l01deh).eq.0.or.(l01e0h).eq.0 --> skip error message
    call err.msg  ; ; ; ;   ;0b2f   Warning (29)
    db 29         ; ; ; ;   ;0b32   Hex Constant Overflow
                  ; ; ; ;
l0b33h:       ;<--+ ; ; ;
    ld hl,(l01dah)  ; ; ;   ;0b33
    ld (l01deh),hl  ; ; ;   ;0b36   (l01deh)=(l01dah)
    ld hl,(l01dch)  ; ; ;   ;0b39
    ld (l01e0h),hl  ; ; ;   ;0b3c   (l01e0h)=(l01dch)
    ld a,(l0282h)   ; ; ;   ;0b3f
    cp 4            ; ; ;   ;0b42
    ret z           ; ; ;   ;0b44   if (l0282h).eq.4 return to l0c29h
    dec a           ; ; ;   ;0b45
    ret z           ; ; ;   ;0b46   if (l0282h).eq.1 return to l0c29h
    ld hl,(l01e0h)  ; ; ;   ;0b47
    ld a,h          ; ; ;   ;0b4a
    or l            ; ; ;   ;0b4b
    jp z,l0b53h ;-; ; ; ;   ;0b4c   if (l01e0h).eq.0 --> skip error message
    call err.msg  ; ; ; ;   ;0b4f   Warning (29)
    db 29         ; ; ; ;   ;0b52   Hex Constant Overflow
                  ; ; ; ;
l0b53h:     ;<----+ ; ; ;
    ld a,(l0282h)   ; ; ;   ;0b53
    ld hl,(l01deh)  ; ; ;   ;0b56
    ld (l01e0h),hl  ; ; ;   ;0b59   (l01e0h)=(l01deh)
    or a            ; ; ;   ;0b5c
    ret z           ; ; ;   ;0b5d   if (l0282h).eq.0 return to l0c29h
    ld a,h          ; ; ;   ;0b5e
    or a            ; ; ;   ;0b5f
    ld a,l          ; ; ;   ;0b60
    ld (l01e1h),a   ; ; ;   ;0b61   (l01e1h)=l
    ret z           ; ; ;   ;0b64   if h.eq.0        Return to l0c29h
    call err.msg    ; ; ;   ;0b65   Warning (29)
    db 29           ; ; ;   ;0b68   Hex Constant Overflow
    ret             ; ; ;   ;0b69   Return to l0c29h
                    ; ; ;
l0b6ah:         ;<--+ ; ;
    ld a,(l01ceh)     ; ;   ;0b6a
    or a              ; ;   ;0b6d
    jp z,l0b79h   ;-; ; ;   ;0b6e   if (l01ceh).eq.0 --> ...
l0b71h:       ;<----)-+ ;
    call s_5936h    ;   ;   ;0b71   cd 36 59
    ld a,9          ;   ;   ;0b74   a=9
l0b76h:     ;<------)---+
    ld (TypeID),a   ;       ;0b76   (TypeID)= Save value type variable
l0b79h:   ;<--------+
    ld a,(TypeID)           ;0b79
    ld (l0280h),a           ;0b7c   (l0280h)=(TypeID)
    call s_56e1h            ;0b7f   Move 8 bytes from ^l01d2h to ^l01dah
    ld hl,l01dah            ;0b82   Source
    ld de,l01e2h            ;0b85   Destination
    call s_56e7h            ;0b88   Move 8 bytes from ^HL to ^DE
l0b8bh:         ;<--------;
    ld hl,(l027eh)        ; ;0b8b
    dec hl                ; ;0b8e
    ld (l027eh),hl        ; ;0b8f   (l027eh)=(l027eh)-1
    ld a,h                ; ;0b92
    or l                  ; ;0b93
    jp z,l0c8eh           ; ;0b94   if (l027eh).eq.0 --> ...
l0b97h:                   ;
    ld a,(l0280h)         ; ;0b97
    ld hl,l0282h          ; ;0b9a
    cp (hl)               ; ;0b9d
    jp nz,l0baeh ;--;     ; ;0b9e   if (l0282h).ne.(l0280h) --> ...
    or a            ;     ; ;0ba1
    jp nz,l0c29h;-; ;     ; ;0ba2   if (l0280h).eq.0 --> ...
    ld hl,(l01deh); ;     ; ;0ba5
    ld (l01e0h),hl; ;     ; ;0ba8   (l01e0h)=(l01deh)
    jp l0c29h   ;-; ;     ; ;0bab   --> ...
                  ; ;     ;
l0baeh:       ;<--)-+     ;
    or a          ;       ; ;0bae
    jp nz,l0bbbh;-)-;     ; ;0baf   if (l0280h).ne.0 --> ...
    ld a,(hl)     ; ;     ; ;0bb2
    cp 4          ; ;     ; ;0bb3
    jp z,l0c29h ;-; ;     ; ;0bb5   if (l0282h).eq.4 (INTEGER*4) --> ...
    ld a,(l0280h) ; ;     ; ;0bb8
l0bbbh:       ;<--)-+     ;
    dec a         ;       ; ;0bbb
    jp nz,l0bc5h;-)-;     ; ;0bbc   if (l0280h).eq.1 --> ...
    ld a,(hl)     ; ;     ; ;0bbf
    cp 3          ; ;     ; ;0bc0
    jp z,l0c29h ;-; ;     ; ;0bc2   if (l0282h).eq.3 (DOUBLE) --> ...
l0bc5h:       ;<--)-+     ;
    ld a,(l0280h) ;       ; ;0bc5
    or a          ;       ; ;0bc8
    jp nz,l0bf0h;-)-----; ; ;0bc9   if (l0280h).ne.0 --> ...
    ld a,(hl)     ;     ; ; ;0bcc
    cp 2          ;     ; ; ;0bcd   if (l0282h).ne.2 (BYTE)
    jp nz,err107  ;     ; ; ;0bcf     --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l01dfh) ;     ; ; ;0bd2
    or a          ;     ; ; ;0bd5
    jp z,l0bddh ;-)-;   ; ; ;0bd6   if (l01dfh).eq.0 --> ...
    inc a         ; ;   ; ; ;0bd9   if (l01dfh).eq.0ffh
    jp nz,err107  ; ;   ; ; ;0bda     --> Error (107) Invalid DATA Constant or Repeat Factor
l0bddh:       ;<--)-+   ; ;
    ld a,(l01deh) ;     ; ; ;0bdd   3a de 01
    jp l0c26h  ;--)---; ; ; ;0be0   --> ...
                  ;   ; ; ;
l0be3h:     ;<----)-; ; ; ;
    xor a         ; ; ; ; ; ;0be3
    or (hl)       ; ; ; ; ; ;0be4
    jp z,l0c29h ;-; ; ; ; ; ;0be5   if (l0282h).eq.0 (INTEGER) --> ...
    cp 4          ; ; ; ; ; ;0be8
    jp z,l0c29h ;-; ; ; ; ; ;0bea   if (l0282h).eq.4 (INTEGER*4) --> ...
    jp l0bf5h ;-; ; ; ; ; ; ;0bed   --> ...
                ; ; ; ; ; ;
l0bf0h:   ;<----)-)-)-)-+ ;
    cp 2        ; ; ; ;   ; ;0bf0
    jp z,l0be3h;)-)-+ ;   ; ;0bf2   if (l0280h).eq.2 --> ...
l0bf5h:      ;<-+ ;   ;   ;
    sub 8         ;   ;   ; ;0bf5
    jp z,l0b18h   ;   ;   ; ;0bf7   if (l0282h).eq.8 --> ...
    dec a         ;   ;   ; ;0bfa
    jp nz,err107  ;   ;   ; ;0bfb   if (l0282h).ne.9 --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l0282h) ;   ;   ; ;0bfe
    cp 3          ;   ;   ; ;0c01
    jp z,l0c29h ;-;   ;   ; ;0c03   if (l0282h).eq.3 (DOUBLE) --> ...
    ld hl,(l01dah);   ;   ; ;0c06
    ld (l01deh),hl;   ;   ; ;0c09   (l01deh)=(l01dah)
    ld hl,(l01dch);   ;   ; ;0c0c
    ld (l01e0h),hl;   ;   ; ;0c0f   (l01e0h)=(l01dch)
    cp 4          ;   ;   ; ;0c12
    jp z,l0c29h ;-;   ;   ; ;0c14   if (l0282h).eq.4 (INTEGER*4) --> ...
    dec a         ;   ;   ; ;0c17
    jp z,l0c29h ;-;   ;   ; ;0c18   if (l0282h).eq.1 (REAL) --> ...
    ld hl,(l01deh);   ;   ; ;0c1b
    ld (l01e0h),hl;   ;   ; ;0c1e   (l01e0h)=(l01deh)
    dec a         ;   ;   ; ;0c21
    jp nz,l0c29h;-;   ;   ; ;0c22   if (l0282h).ne.2 (BYTE) --> ...
    ld a,l        ;   ;   ; ;0c25   a=l
l0c26h:      ;<---)---+   ;
    ld (l01e1h),a ;       ; ;0c26   (l01e1h)=
l0c29h:   ;<------+       ;
    ld a,(l0282h)         ; ;0c29
    cp 4                  ; ;0c2c
    jp z,l0c39h  ;----;   ; ;0c2e   if (l0282h).eq.4 (INTEGER*4) --> ...
                      ;   ;
;   Calculation storage size variable according to the type
                      ;   ;
    inc a             ;   ; ;0c31   a=a+1
    rlca              ;   ; ;0c32   Multiply by 2
    or a              ;   ; ;0c33   for compatibility with z80
    jp po,l0c39h ;-;  ;   ; ;0c34   if (l0282h).ne.3 (Byte) --> ...
    ld a,1         ;  ;   ; ;0c37   a=1
l0c39h:      ;<----+<-+   ;
    ld hl,l01e7h          ; ;0c39   hl=l01e7h
    call w.name           ; ;0c3c   Put Name from Symbol table to REL file
    ld hl,l01e2h          ; ;0c3f   hl=l01e2h
    call s_56e4h          ; ;0c42   Move 8 bytes from hl to ^l01dah
    ld hl,(l0283h)        ; ;0c45
    dec hl                ; ;0c48
    ld (l0283h),hl        ; ;0c49   (l0283h)=(l0283h)-1
    ld a,h                ; ;0c4c
    or l                  ; ;0c4d
    jp nz,l0b8bh  ;-------+ ;0c4e   if (l0282h).ne.0 --> ...
    ld a,(l0299h)           ;0c51
    cp ','                  ;0c54
    jp z,l0abdh             ;0c56   if (l0298h).eq.',' --> ...
    ld hl,(l0217h)          ;0c59
    ex de,hl                ;0c5c
    ld hl,00000h            ;0c5d
    add hl,sp               ;0c60
    call cmpHL.DE           ;0c61   if SP.ne.(l0217h)
    jp nz,err108            ;0c64      --> Error (108) Incorrect Number of DATA Constants
    ld hl,(l028eh)          ;0c67
    ld sp,hl                ;0c6a   SP=(l028eh)
    ld a,'/'                ;0c6b
    call ch.chr             ;0c6d   Check character (a character for check)
    call g_n_chr            ;0c70   Get next character
    pop hl                  ;0c73 / e1
    call l6572h             ;0c74   cd 72 65
    xor a                   ;0c77
    ld (l025ah),a           ;0c78   (l025ah)=0
    ld a,(l0299h)           ;0c7b
    cp cr                   ;0c7e   if (l0299h).eq.cr
    jp z,l09ebh             ;0c80      --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    cp ','                  ;0c83   Test separator
    jp z,PrData             ;0c85   if (l0299h).eq.',' --> Processing DATA
    ld (l0173h),a           ;0c88   (l0173h)=(l0299h)
    jp PrData               ;0c8b   --> Processing DATA
;
l0c8eh:
    ld hl,00000h        ;0c8e
    add hl,sp           ;0c91   hl=SP
    ex de,hl            ;0c92
    ld hl,(l0217h)      ;0c93
    dec hl              ;0c96
    call cmpHL.DE       ;0c97
    jp nc,l0ca1h ;--;   ;0c9a   if (l0217h)-1 >= SP --> Skip error message
err108:             ;
    call err.msg    ;   ;0c9d   Error (108)
    db 108          ;   ;0ca0   Incorrect Number of DATA Constants
                    ;
l0ca1h:         ;<--+
    ld d,(hl)           ;0ca1   56
    dec hl              ;0ca2   2b
    ld e,(hl)           ;0ca3   5e
    dec hl              ;0ca4   2b
    push hl             ;0ca5 \ e5
    ex de,hl            ;0ca6   eb
    call ExtAttr        ;0ca7   Extract Attributes from the symbol table
    call l68bbh         ;0caa   cd bb 68
    pop hl              ;0cad / e1
    ld a,(hl)           ;0cae   7e
    dec hl              ;0caf   2b
    or a                ;0cb0   b7
    jp p,l0cc4h ;---;   ;0cb1   f2 c4 0c
    dec hl          ;   ;0cb4   2b
    ld d,(hl)       ;   ;0cb5   56
    dec hl          ;   ;0cb6   2b
    ld e,(hl)       ;   ;0cb7   5e
    push hl         ;   ;0cb8 \ e5
    ld hl,(DataID)  ;   ;0cb9
    add hl,de       ;   ;0cbc
    ld (DataID),hl  ;   ;0cbd   (DataID)=(DataID)+de
    ld de,00001h    ;   ;0cc0   de=1
    pop hl          ;   ;0cc3 / e1
l0cc4h:        ;<---+
    ld (l0217h),hl      ;0cc4   (l0217h)=
    ex de,hl            ;0cc7   eb
    ld (l027eh),hl      ;0cc8   (l027eh)=
    ld a,(TypeID)       ;0ccb
    ld (l0282h),a       ;0cce   (l0282h)=(TypeID)
    ld hl,(DataID)      ;0cd1   2a 5d 01
    ld bc,020bh         ;0cd4   Address modes DSEG (2), REL type - Set loading location counter (11)
    ld a,(ScopeID)      ;0cd7
    dec a               ;0cda
    jp nz,l0ce6h ;--;   ;0cdb   if (ScopeID).ne.1 --> ...
    push hl         ;   ;0cde \
    call s_64bah    ;   ;0cdf   cd ba 64
    pop hl          ;   ;0ce2 /
    ld bc,030bh     ;   ;0ce3   Address modes COMMON (3), REL type - Set loading location counter (11)
l0ce6h:        ;<---+
    call s_6575h        ;0ce6   cd 75 65
    ld a,(NoCode)       ;0ce9
    or a                ;0cec   Test /N
    jp nz,l0b97h        ;0ced   if (NoCode).ne.0 skip output --> ...
    call s_5dcbh        ;0cf0   if (Column).ne.0 Put cr lf to console
    call s_146ch        ;0cf3   Print *****
    call s_549ch        ;0cf6   cd 9c 54
    call puttab         ;0cf9   Put tab to console
    jp l0b97h           ;0cfc   --> ...
;*
;*
;*
s_0cffh:
    ld a,(ScopeID)      ;0cff
    or a                ;0d02
    ret nz              ;0d03   if(ScopeID).ne.0 Return
s_0d04h:
    call l68bbh         ;0d04   cd bb 68
    ld a,2              ;0d07
    ld (ScopeID),a      ;0d09   (ScopeID)=2 
    ex de,hl            ;0d0c   eb 
    ld hl,(DatSiz)      ;0d0d
    ld (DataID),hl      ;0d10   (DataID)=(DatSiz)
    add hl,de           ;0d13   19
    ld (DatSiz),hl      ;0d14   (DatSiz)= Save Data size
    jp PutAttr          ;0d17   --> Put Attributes in Symbol table
;*
;*  Signed divide DE/HL-->DE,HL
;*
;?                           !! No execution path to here !!
    ld a,d              ;0d1a   7a
    or a                ;0d1b   b7
    ld b,d              ;0d1c   42
    call m,s_0d6bh      ;0d1d   Make >0 if less 
    ld a,h              ;0d20
    xor b               ;0d21
    ld b,a              ;0d22   Set common sign
    ld a,h              ;0d23   Test zero result
    or l                ;0d24
    ret z               ;0d25   if(hl.eq.0) return
    ld a,h              ;0d26
    or a                ;0d27
    ex de,hl            ;0d28
    call m,s_0d6bh      ;0d29
    push bc             ;0d2c \
    call s_0d37h        ;0d2d   Divide 
    pop af              ;0d30 /
    or a                ;0d31
    call m,s_0d6bh      ;0d32   Make >0
    ex de,hl            ;0d35
    ret                 ;0d36
;*
;*  Unsigned divide DE/HL-->DE,HL
;*
s_0d37h:
    ld a,h              ;0d37   Get two's divisor complement
    cpl                 ;0d38
    ld b,a              ;0d39
    ld a,l              ;0d3a
    cpl                 ;0d3b
    ld c,a              ;0d3c
    inc bc              ;0d3d   Build two's divisor complement
    ld hl,00000h        ;0d3e   Init result
    ld a,011h           ;0d41   Set bit length
    push af             ;0d43 \
    or a                ;0d44
    jp l0d52h   ;---;   ;0d45
                    ;
l0d48h:      ;<-----)-;
    push af         ; ; ;0d48 \
    push hl         ; ; ;0d49 \
    add hl,bc       ; ; ;0d4a   Add divisor
    jp nc,l0d51h;-; ; ; ;0d4b   Check bit 
    pop af        ; ; ; ;0d4e /
    scf           ; ; ; ;0d4f
    db 03eh       ; ; ; ;0d50   ld a,0e1h (in the original)  trap_ms ***
l0d51h:      ;<---+ ; ;
    pop hl          ; ; ;0d51 /
l0d52h:         ;<--+ ;
    ld a,e            ; ;0d52   Shift left 32 bit
    rla               ; ;0d53
    ld e,a            ; ;0d54
    ld a,d            ; ;0d55
    rla               ; ;0d56
    ld d,a            ; ;0d57
    ld a,l            ; ;0d58
    rla               ; ;0d59
    ld l,a            ; ;0d5a
    ld a,h            ; ;0d5b
    rla               ; ;0d5c
    ld h,a            ; ;0d5d
    pop af            ; ;0d5e /
    dec a             ; ;0d5f   Test end
    jp nz,l0d48h ;----+ ;0d60
    ld a,h              ;0d63   Fix remainder
    or a                ;0d64
    rra                 ;0d65
    ld h,a              ;0d66
    ld a,l              ;0d67
    rra                 ;0d68
    ld l,a              ;0d69
    ret                 ;0d6a
;*
;*  Make number greater 0, DE=-DE
;*
s_0d6bh:
    xor a               ;0d6b   Clear entry
    ld c,a              ;0d6c
    sub e               ;0d6d   Calculate 0-DE
    ld e,a              ;0d6e
    ld a,c              ;0d6f
    sbc a,d             ;0d70
    ld d,a              ;0d71
    ret                 ;0d72
;*
;*  Processing DIMENSION (DIMENSION name(iconst1,iconst2,iconst3))
;*
PrDimension:
    call PrName         ;0d73   Processing name
    call s_19eeh        ;0d76   Processing subscript an array
    jp l092fh           ;0d79   --> Test continue processing statement
;*
;*  Processing DO loop parameters m1,m2,m3
;*    ENTRY Reg HL -
;*
s_0d7ch:
    ld (l01b2h),hl      ;0d7c   (l01b2h)=
    ld hl,(l01cfh)      ;0d7f
    ld (l01aeh),hl      ;0d82   (l01aeh)=(l01cfh)
    call s_259eh        ;0d85   Processing integer constant (m1-initial Value)
    ld (l01aah),hl      ;0d88   (l01aah)=
    call ChComma        ;0d8b   Check ','
    call s_259eh        ;0d8e   Processing integer constant (m2-final Value)
    ld (l01a6h),hl      ;0d91   (l01a6h)= 
    ld hl,(l023fh)      ;0d94
    ld (l01cfh),hl      ;0d97   (l01cfh)=(l023fh)
    ld a,(l0299h)       ;0d9a
    cp ','              ;0d9d   if (l0298h).eq.','
    call z,s_259eh      ;0d9f     Processing integer constant (m3-optional Increment)
    ld hl,(l01cfh)      ;0da2
    ld (l01a8h),hl      ;0da5   (l01a8h)=(l01cfh)
    jp l0e48h           ;0da8   --> ...
;*
;*
;*
s_0dabh:
    call s_5609h        ;0dab   cd 09 56
    ld hl,(l01aeh)      ;0dae
    push hl             ;0db1 \ Save (l01aeh)
    call ExtAttr        ;0db2   Extract Attributes from the symbol table
    ld a,(TypeID)       ;0db5
    push af             ;0db8 \ Save (TypeID)
    ld hl,(l01aah)      ;0db9   hl=(l01aah)
    call ExtAttr        ;0dbc   Extract Attributes from the symbol table
    ld a,(TypeID)       ;0dbf
    or a                ;0dc2
    jp z,l0dd7h  ;----; ;0dc3   if (TypeID).eq.0 (INTEGER) --> ...
    pop af            ; ;0dc6 / Restore (TypeID)
    or a              ; ;0dc7
    jp nz,l0dd8h ;--; ; ;0dc8   if (TypeID).ne.0 (INTEGER) --> ...
    call s_3ecch    ; ; ;0dcb   cd cc 3e
    call s_3682h    ; ; ;0dce   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ; ; ;0dd1   (i_Type)=0 (INTEGER)
    jp l0ddeh   ;-; ; ; ;0dd4   --> ...
                  ; ; ;
l0dd7h:      ;<---)-)-+
    pop af        ; ;   ;0dd7 / Restore (TypeID)
l0dd8h:        ;<-)-+
    ld (TypeID),a ;     ;0dd8   (TypeID)= Save value type variable
    call s_3ecch  ;     ;0ddb   cd cc 3e
l0ddeh:       ;<--+
    ld hl,(PrgSiz)      ;0dde
    ld (l01aah),hl      ;0de1   (l01aah)=(PrgSiz)
    pop hl              ;0de4 / Restore (l01aeh)
    call ExtAttr        ;0de5   Extract Attributes from the symbol table
    ld a,7              ;0de8   a=7
    call s_3a2ah        ;0dea   cd 2a 3a
    jp l6494h           ;0ded   --> ...
;*
;*  Parse DO statement (DO label i = m1,m2,m3)
;*
l0df0h:
    ld a,2              ;0df0   a=2
    call GetStr         ;0df2   Reading string length 2 characters
    ld de,0444fh        ;0df5   de="DO"
    ld hl,(l01e0h)      ;0df8
    call cmpHL.DE       ;0dfb
    jp nz,err126        ;0dfe   if (l01e0h).ne."DO" --> Error (126) Illegal Character for Syntax
    ld a,0ah            ;0e01   a=0ah
    call s_5e97h        ;0e03   cd 97 5e
    call s_21aeh        ;0e06   Processing label & Test (TypeID).eq.INTEGER
    ld a,(ScopeID)      ;0e09
    or a                ;0e0c
    jp z,l0e14h ;---;   ;0e0d   if (ScopeID).eq.0 --> skip error message
    call err.msg    ;   ;0e10   Error (124)
    db 124          ;   ;0e13   Backwards DO reference
l0e14h:         ;<--+
    ld hl,(l01cfh)      ;0e14
    push hl             ;0e17 \ Save (l01cfh)
    inc a               ;0e18
    ld (l0173h),a       ;0e19   (l0173h)=(ScopeID)+1
    call s_258bh        ;0e1c   Processing integer constant & Test (KindID).ne.1
    ld a,'='            ;0e1f
    call ch.chr         ;0e21   Check character (a character for check)
    pop hl              ;0e24 / Restore (l01cfh)
    call s_0d7ch        ;0e25   Processing DO loop parameters m1,m2, m3
    call s_0dabh        ;0e28   Code generation DO statement
    jp l1b45h           ;0e2b   --> Clear (l029ah) Set (DO_Flg) -> Ending parsing statement
;
;
;
s_0e2eh:
    ld hl,(DataID)      ;0e2e
    ld a,h              ;0e31
    or l                ;0e32
    jp z,l0e40h ;---;   ;0e33   if (DataID).eq.0 --> ...
    ld a,(TypeID)   ;   ;0e36
    or a            ;   ;0e39
    ret nz          ;   ;0e3a   if (TypeID).ne.0 (INTEGER) Return
    call err.msg    ;   ;0e3b   Warning (19)
    db 19           ;   ;0e3e   Statement Number Not FORMAT
    ret             ;   ;0e3f
                    ;
l0e40h:         ;<--+
    ld a,1              ;0e40
    ld (TypeID),a       ;0e42   (TypeID)=1 (REAL)
    jp PutAttr          ;0e45   --> Put Attributes in Symbol table
;
l0e48h:
    ld a,0ah            ;0e48   a=10
    call ChkMem         ;0e4a   Test Allocate A bytes of memory
    ld hl,(HeapPtr)     ;0e4d                               hl=(HeapPtr)
    ex de,hl            ;0e50                                            de=(HeapPtr)
    ld hl,(l01a4h)      ;0e51                               hl=(l01a4h)
    ld (l01b0h),hl      ;0e54   (l01b0h)=(l01a4h)
    call subHL.DE       ;0e57   hl=hl-de=(l01a4h)-(HeapPtr)
    ld b,h              ;0e5a
    ld c,l              ;0e5b   bc=hl                       bc=(l01a4h)-(HeapPtr)
    push de             ;0e5c \ Save de=(HeapPtr) -------+
    ld hl,0000ah        ;0e5d   hl=10                    ;
    push hl             ;0e60 \ Save hl=10 ------------+ ;
    add hl,de           ;0e61                          ; ;  hl=(HeapPtr)+10
    ld (HeapPtr),hl     ;0e62   (HeapPtr)=(HeapPtr)+10 ; ;  hl=(HeapPtr)
    pop de              ;0e65 /            ------------+ ;               de=10
    push hl             ;0e66 \ Save (HeapPtr)    -----+ ;
    ld hl,(l0217h)      ;0e67                          ; ;  hl=(l0217h)
    add hl,de           ;0e6a                          ; ;  hl=(l0217h)+10
    ld (l0217h),hl      ;0e6b   (l0217h)=(l0217h)+10   ; ;
    pop hl              ;0e6e / -----------------------+ ;  hl=(HeapPtr)+10
    pop de              ;0e6f / -------------------------+  de=(HeapPtr)
    jp z,l0e81h   ;---; ;0e70   if (l01a4h)-(HeapPtr).eq.0 --> ...
    dec hl            ; ;0e73   hl=(HeapPtr)+9
    dec de            ; ;0e74   de=(HeapPtr)-1
l0e75h:         ;<--; ;         bc=(l01a4h)-(HeapPtr)
      ld a,(de)     ; ; ;0e75
      ld (hl),a     ; ; ;0e76   (hl)=(de) 
      dec hl        ; ; ;0e77   hl=hl-1
      dec de        ; ; ;0e78   de=de-1
      inc bc        ; ; ;0e79   bc=bc+1
      ld a,b        ; ; ;0e7a
      or c          ; ; ;0e7b   Test bc
    jp nz,l0e75h ;--+ ; ;0e7c   if bc.ne.0 --> ...
    ex de,hl          ; ;0e7f   eb
    inc hl            ; ;0e80   hl=hl-1
l0e81h:           ;<--+
    ld (l01a4h),hl      ;0e81   (l01a4h)=
    jp l6494h           ;0e84   --> ...
;*
;*
;*
s_0e87h:
    ld a,4              ;0e87   a=4
    call ChkMem         ;0e89   Test Allocate A bytes of memory
    ld hl,(HeapPtr)     ;0e8c
    ld (l0217h),hl      ;0e8f   (l0217h)=(HeapPtr)
    xor a               ;0e92   a=0
    ld (hl),a           ;0e93   77
    inc hl              ;0e94   23
    ld (hl),a           ;0e95   77
    ex de,hl            ;0e96   eb
    ld hl,(l0244h)      ;0e97   2a 44 02
    ex de,hl            ;0e9a   eb
    inc hl              ;0e9b   23
    ld (hl),e           ;0e9c   73
    inc hl              ;0e9d   23
    ld (hl),d           ;0e9e   72
    inc hl              ;0e9f   23
    ld (HeapPtr),hl     ;0ea0   (HeapPtr)=(HeapPtr)+4
    ret                 ;0ea3
;*
;*
;*
s_0ea4h:
    ld a,4              ;0ea4   a=4
    call ChkMem         ;0ea6   Test Allocate A bytes of memory
    ld hl,(HeapPtr)     ;0ea9
    ld (l0217h),hl      ;0eac   (l0217h)=(HeapPtr)
    inc hl              ;0eaf
    inc hl              ;0eb0
    inc hl              ;0eb1
    inc hl              ;0eb2
    ld (HeapPtr),hl     ;0eb3   (HeapPtr)=(HeapPtr)+4
    call s_64dah        ;0eb6   cd da 64
    xor a               ;0eb9
    ld (l0231h),a       ;0eba   (l0231h)=0
    ret                 ;0ebd
;*
;*  Processing ENCODE(, DECODE( 
;*      (DECODE(a,label) k)
;*
PrEncode:
    call s_1cafh        ;0ebe   cd af 1c
    cp 4                ;0ec1
    jp z,l21d0h         ;0ec3   if (KindID).eq.4 (Array)--> ...
    call err.msg        ;0ec6   Warning (32)
    db 32               ;0ec9   Array Name Expected
    jp l21d0h           ;0eca   --> ...
;*
;*
;*
s_0ecdh:
    ld a,(l01eah)               ;0ecd
    dec a                       ;0ed0
    jp z,l1114h                 ;0ed1   if (l01eah).eq.1 --> ...
l0ed4h:
    ld hl,(l0235h)              ;0ed4
    ex de,hl                    ;0ed7
    ld hl,(l0209h)              ;0ed8
    call subHL.DE               ;0edb   hl=(l0209h)-(l0235h)
    ex de,hl                    ;0ede
    ld hl,(HeapEnd)             ;0edf
    inc hl                      ;0ee2
    inc hl                      ;0ee3
    inc hl                      ;0ee4
    inc hl                      ;0ee5   hl=(HeapEnd)+4
    call cmpHL.DE               ;0ee6
    jp nz,l1063h                ;0ee9   if ((HeapEnd)+4).ne.((l0209h)-(l0235h)) --> ...
    ld a,(hl)                   ;0eec   7e
    and 01fh                    ;0eed   00011111b
    cp 013h                     ;0eef
    jp nz,l0f03h ;--;           ;0ef1   if a.ne.13h  --> ...
    xor a           ;           ;0ef4
    ld (l02a3h),a   ;           ;0ef5   (l02a3h)=0
    ld hl,(l0235h)  ;           ;0ef8
    ld (l01cfh),hl  ;           ;0efb   (l01cfh)=(l0235h)
    ld a,17h        ;           ;0efe   a=017h
    call s_147ah    ;           ;0f00   cd 7a 14
l0f03h:         ;<--+
    ld hl,(l0237h)              ;0f03
    ld (l01cfh),hl              ;0f06   (l01cfh)=(l0237h)
    xor a                       ;0f09
    ld (l02a3h),a               ;0f0a   (l02a3h)=0
    ld a,(l0243h)               ;0f0d
    sub 6                       ;0f10
    jp z,l0f7ah    ;----;       ;0f12   if(l0243h).eq.6 --> ...
    dec a               ;       ;0f15
    jp z,l0f7ah    ;----;       ;0f16   if(l0243h).eq.7 --> ...
l0f19h:       ;<--------)---;
    ld a,(l0243h)       ;   ;   ;0f19   a=(l0243h)
    ld hl,(l0237h)      ;   ;   ;0f1c
    ld (l01cfh),hl      ;   ;   ;0f1f   (l01cfh)=(l0237h)
    call s_147ah        ;   ;   ;0f22   cd 7a 14
    ld a,(l0243h)       ;   ;   ;0f25
    cp 6                ;   ;   ;0f28
    jp nc,l0f5ah  ;-----)-; ;   ;0f2a   if(l0243h) >= 6 --> ...
l0f2dh:      ;<---------)-)-)-;
    ld a,(l01eeh)       ; ; ; ; ;0f2d
    ld (l01edh),a       ; ; ; ; ;0f30   (l01edh)=(l01eeh)
l0f33h:       ;<------; ; ; ; ;
    ld hl,(HeapEnd)   ; ; ; ; ; ;0f33
    inc hl            ; ; ; ; ; ;0f36
    inc hl            ; ; ; ; ; ;0f37
    inc hl            ; ; ; ; ; ;0f38
    inc hl            ; ; ; ; ; ;0f39
    ex de,hl          ; ; ; ; ; ;0f3a
    ld hl,(l0209h)    ; ; ; ; ; ;0f3b
    call subHL.DE     ; ; ; ; ; ;0f3e
    ld (l0235h),hl    ; ; ; ; ; ;0f41   (l0235h)=(l0209h)-((HeapEnd)+4)
    ret               ; ; ; ; ; ;0f44
                      ; ; ; ; ;
l0f45h:       ;<----; ; ; ; ; ;
    cp 0ch          ; ; ; ; ; ; ;0f45
    jp z,l0f2dh     ; ; ; ; ; ; ;0f47   if(l0243h).eq.12 --> ...
    cp 13h          ; ; ; ; ; ; ;0f4a
    jp nc,l0f2dh ;--)-)-)-)-)-; ;0f4c   if(l0243h) >= 19 --> ...
    ld hl,(HeapEnd) ; ; ; ; ; ; ;0f4f
    inc hl          ; ; ; ; ; ; ;0f52
    inc hl          ; ; ; ; ; ; ;0f53
    inc hl          ; ; ; ; ; ; ;0f54
    ld (hl),2       ; ; ; ; ; ; ;0f55   ((HeapEnd)+3)=2
    jp l0f6eh ;---; ; ; ; ; ; ; ;0f57   --> ...
                  ; ; ; ; ; ; ;
l0f5ah:    ;<-----)-)-)-)-+ ; ;
    cp 8          ; ; ; ;   ; ; ;0f5a
    jp c,l0f2dh ;-)-)-)-)---)-+ ;0f5c   if(l0243h) < 8 --> ...
    cp 0bh        ; ; ; ;   ;   ;0f5f
    jp nc,l0f45h;-)-+ ; ;   ;   ;0f61   if(l0242h) >= 11 --> ...
    ld hl,l01edh  ;   ; ;   ;   ;0f64   21 ed 01
    ld a,(hl)     ;   ; ;   ;   ;0f67   7e
    inc hl        ;   ; ;   ;   ;0f68   23
    or (hl)       ;   ; ;   ;   ;0f69   b6
    rra           ;   ; ;   ;   ;0f6a   1f
    jp c,err132   ;   ; ;   ;   ;0f6b   if --> Error (132) Illegal Mixed Mode Operation
l0f6eh:       ;<--+   ; ;   ;
    ld a,2            ; ;   ;   ;0f6e
    ld (l01edh),a     ; ;   ;   ;0f70   (l01edh)=2
    jp l0f33h     ;---+ ;   ;   ;0f73   --> ...
                        ;   ;
err132:                 ;   ;
    call err.msg        ;   ;   ;0f76   Error (132)
    db 132              ;   ;   ;0f79   Illegal Mixed Mode Operation
                        ;   ;
l0f7ah:         ;<------+   ;
    ld hl,(l0237h)          ;   ;0f7a
    ex de,hl                ;   ;0f7d   de=(l0237h)
    call s_0ff5h            ;   ;0f7e   cd f5 0f
    jp c,l0f19h    ;--------;   ;0f81   da 19 0f
    ld (l01bah),hl          ;   ;0f84   (l01bah)=
    ex de,hl                ;   ;0f87   eb
    ld (l01bch),hl          ;   ;0f88   (l01bch)=
    ld h,b                  ;   ;0f8b
    ld l,c                  ;   ;0f8c   hl=bc
    ld (l01beh),hl          ;   ;0f8d   (l01beh)=
    ld hl,(l0209h)          ;   ;0f90   2a 09 02
l0f93h:           ;<----;   ;
    ex de,hl            ;   ;   ;0f93   eb
    ld hl,(HeapEnd)     ;   ;   ;0f94   2a 15 02 
    call cmpHL.DE       ;   ;   ;0f97   Compare HL with DE
    jp z,l0f19h    ;----)---+   ;0f9a   if HL.eq.DE --> ...
    ex de,hl            ;       ;0f9d   eb
    ld a,(hl)           ;       ;0f9e   7e
    or a                ;       ;0f9f   b7
    jp m,l0fc6h  ;----; ;       ;0fa0   if a < 0 --> ...
    push hl           ; ;       ;0fa3 \ e5
    dec hl            ; ;       ;0fa4   2b
    dec hl            ; ;       ;0fa5   2b
    ld d,(hl)         ; ;       ;0fa6   56
    dec hl            ; ;       ;0fa7   2b
    ld e,(hl)         ; ;       ;0fa8   5e
    call s_0ff5h      ; ;       ;0fa9   cd f5 0f
    jp c,l0fc5h  ;--; ; ;       ;0fac   da c5 0f
    ld a,h          ; ; ;       ;0faf   7c
    and l           ; ; ;       ;0fb0   a5
    inc a           ; ; ;       ;0fb1   3c
    push hl         ; ; ;       ;0fb2 \ e5
    ld hl,(l01bah)  ; ; ;       ;0fb3   2a ba 01
    jp nz,l0fcdh ;--)-)-)---;   ;0fb6   c2 cd 0f
                    ; ; ;   ;
l0fb9h:    ;<-------)-)-)-; ;
    ld a,h          ; ; ; ; ;   ;0fb9   7c
    or l            ; ; ; ; ;   ;0fba   b5
    pop hl          ; ; ; ; ;   ;0fbb / e1
    jp z,l0fc5h ;---; ; ; ; ;   ;0fbc   if hl.eq.0 --> ...
l0fbfh:     ;<------)-)-)-)-)-;
    pop hl          ; ; ; ; ; ; ;0fbf / e1
    ld a,(hl)       ; ; ; ; ; ; ;0fc0   7e
    or 080h         ; ; ; ; ; ; ;0fc1   f6 80
    ld (hl),a       ; ; ; ; ; ; ;0fc3   77
    db 3eh          ; ; ; ; ; ; ;0fc4   ld a,0e1h (in the original)  trap_ms ***
l0fc5h:      ;<-----+ ; ; ; ; ;
    pop hl          ; ; ; ; ; ; ;0fc5 / e1
l0fc6h:        ;<---)-+ ; ; ; ;
    dec hl          ;   ; ; ; ; ;0fc6   2b
    dec hl          ;   ; ; ; ; ;0fc7   2b
    dec hl          ;   ; ; ; ; ;0fc8   2b
    dec hl          ;   ; ; ; ; ;0fc9   2b
    jp l0f93h ;-----)---+ ; ; ; ;0fca   --> ...
                    ;     ; ; ;
l0fcdh:     ;<------)-----)-+ ;
    ld a,h          ;     ;   ; ;0fcd   7c
    and l           ;     ;   ; ;0fce   a5
    inc a           ;     ;   ; ;0fcf   3c
    ex (sp),hl      ;     ;   ; ;0fd0   e3
    jp z,l0fb9h ;---)-----+   ; ;0fd1   if hl.eq.-1 --> ...
    ex de,hl        ;         ; ;0fd4   eb  . 
    ex (sp),hl      ;         ; ;0fd5   e3  . 
    call cmpHL.DE   ;         ; ;0fd6   Compare HL with DE
    pop de          ;         ; ;0fd9 / d1
    jp nz,l0fc5h ;--;         ; ;0fda   if HL.ne.DE --> ...
    ld hl,(l01beh)  ;         ; ;0fdd   2a be 01 
    call cmpHL.DE   ;         ; ;0fe0   Compare HL with DE
    jp c,l0fc5h  ;--;         ; ;0fe3   if HL < DE --> ...
    ld hl,(l01bch)  ;         ; ;0fe6   2a bc 01
    ex de,hl        ;         ; ;0fe9   eb
    ld h,b          ;         ; ;0fea
    ld l,c          ;         ; ;0feb   hl=bc
    call cmpHL.DE   ;         ; ;0fec   Compare HL with DE
    jp c,l0fc5h  ;--+         ; ;0fef   if HL < DE --> ...
    jp l0fbfh  ;--------------+ ;0ff2   --> ...
;*
;*  ENTRY Reg DE - ADR
;*
s_0ff5h:
    ld hl,(l0209h)          ;0ff5
    call subHL.DE           ;0ff8   hl=(l0209h)-ADR
    jp c,l103eh   ;-----;   ;0ffb   if (l0209h). < .ADR --> ...
    ld a,(hl)           ;   ;0ffe
    and 00011111b       ;   ;0fff
    cp 013h             ;   ;1001
    scf                 ;   ;1003   Set carry
    ret nz              ;   ;1004   if (hl).ne.013h Return
    dec hl              ;   ;1005
    dec hl              ;   ;1006   hl=(l0206h)-ADR-2
    ld d,(hl)           ;   ;1007
    dec hl              ;   ;1008
    ld e,(hl)           ;   ;1009   de=(hl)
    ex de,hl            ;   ;100a   eb
l100bh:         ;<--;   ;
    call ExtAttr    ;   ;   ;100b   Extract Attributes from the symbol table
    ld a,(KindID)   ;   ;   ;100e
    cp 3            ;   ;   ;1011
    ld hl,(l01d7h)  ;   ;   ;1013   2a d7 01
    jp z,l100bh ;---+   ;   ;1016   if (KindID).eq.3 (Variable)--> ...
    ld a,(ScopeID)      ;   ;1019
    cp 3                ;   ;101c
    jp z,l1039h  ;--;   ;   ;101e   if (ScopeID).eq.3 --> ...
    ld hl,(DataID)  ;   ;   ;1021
    push hl         ;   ;   ;1024 \ Save (DataID)
    call l68bbh     ;   ;   ;1025   cd bb 68
    pop de          ;   ;   ;1028 / de=(DataID)
l1029h:      ;<-----)-; ;
    add hl,de       ; ; ;   ;1029   19
    dec hl          ; ; ;   ;102a   2b
    ld b,h          ; ; ;   ;102b
    ld c,l          ; ; ;   ;102c   bc=hl
    ld hl,(EntryID) ; ; ;   ;102d   2a 74 01
    ld a,(ScopeID)  ; ; ;   ;1030
    dec a           ; ; ;   ;1033
    ret z           ; ; ;   ;1034   if (ScopeID).eq.1 Return
    xor a           ; ; ;   ;1035   a=0
    ld h,a          ; ; ;   ;1036
    ld l,a          ; ; ;   ;1037   hl=0
    ret             ; ; ;   ;1038
                    ; ; ;
l1039h:     ;<------; ; ;
    xor a           ; ; ;   ;1039   a=0
    ld hl,0ffffh    ; ; ;   ;103a   hl=0ffffh
    ret             ; ; ;   ;103d
                    ; ; ;
l103eh:       ;<----)-)-+
    ex de,hl        ; ;     ;103e   eb
    call ExtAttr    ; ;     ;103f   Extract Attributes from the symbol table
    ld a,(KindID)   ; ;     ;1042
    cp 3            ; ;     ;1045
    jp z,l104eh ;-; ; ;     ;1047   if (KindID).eq.3 (Variable) --> ...
    cp 4          ; ; ;     ;104a
    scf           ; ; ;     ;104c   Set carry
    ret nz        ; ; ;     ;104d   if (KindID).eq.4 (Array) Return
l104eh:       ;<--+ ; ;
    ld a,(ScopeID)  ; ;     ;104e
    cp 3            ; ;     ;1051
    jp z,l1039h ;---+ ;     ;1053   if (ScopeID).eq.3 --> ...
    ld hl,(DataID)    ;     ;1056
    ex de,hl          ;     ;1059   de=(DataID)
    ld a,(l02abh)     ;     ;105a
    ld l,a            ;     ;105d
    ld h,0            ;     ;105e   hl=(l02abh)
    jp l1029h  ;------+     ;1060   --> ...
;
l1063h:
    ld hl,(l0235h)          ;1063
    ld (l01cfh),hl          ;1066   (l01cfh)=(l0235h)
    ld a,(l0243h)           ;1069
    cp 6                    ;106c
    jp z,l110eh   ;-----;   ;106e   if (l0243h).eq.6 --> ...
    ex de,hl            ;   ;1071
    ld hl,(l0209h)      ;   ;1072
    call cmpHL.DE       ;   ;1075   Compare HL with DE 
    jp nc,l10f5h   ;----)-; ;1078   if (l0209h) >= (l01cfh) --> ...
    ld a,(l0243h)       ; ; ;107b
    cp 0ch              ; ; ;107e
    jp nz,l10abh ;----; ; ; ;1080   if (l0243h).ne.0ch --> ...
    call s_54c8h      ; ; ; ;1083   Extract Attributes from the symbol table, entry( l01cfh)
    dec a             ; ; ; ;1086
    jp nz,l10a7h  ;-; ; ; ; ;1087   if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)   ; ; ; ; ;108a
    and 1           ; ; ; ; ;108d
    jp z,l1164h     ; ; ; ; ;108f   if (TypeID).eq.1 (REAL) --> ...
    ld hl,l01d9h    ; ; ; ; ;1092
    ld a,(hl)       ; ; ; ; ;1095
    or a            ; ; ; ; ;1096
    ret z           ; ; ; ; ;1097   if (l01d9h).eq.0 Return
    dec hl          ; ; ; ; ;1098   hl-hl-1
    ld a,(hl)       ; ; ; ; ;1099
    xor 80h         ; ; ; ; ;109a   10000000b
    ld (hl),a       ; ; ; ; ;109c   (l01d9h)=(l01d9h).XOR.10000000b
    call s_055ah    ; ; ; ; ;109d   cd 5a 05
    ld hl,(l01cfh)  ; ; ; ; ;10a0
    ld (l0235h),hl  ; ; ; ; ;10a3   (l0235h)=(l01cfh) 
    ret             ; ; ; ; ;10a6
                    ; ; ; ;
l10a7h:        ;<---+ ; ; ;
    ld hl,(l01cfh)    ; ; ; ;10a7   2a cf 01
    ex de,hl          ; ; ; ;10aa   eb
l10abh:         ;<----+ ; ;
    call s_6591h        ; ; ;10ab   cd 91 65
l10aeh:                 ; ;
    jp nz,l110eh   ;----; ; ;10ae   if ne.0 --> ... 
    ld a,(hl)           ; ; ;10b1   7e
    and 01fh            ; ; ;10b2   00011111b
    jp nz,l65a3h        ; ; ;10b4   if ne.0 --> ...
    ld a,(hl)           ; ; ;10b7   7e
    or a                ; ; ;10b8   b7
    jp m,l65a3h         ; ; ;10b9   if < 0 --> ...
l10bch:         ;<--;   ; ;
    dec hl          ;   ; ; ;10bc   2b
    dec hl          ;   ; ; ;10bd   2b
    dec hl          ;   ; ; ;10be   2b
    dec hl          ;   ; ; ;10bf   2b
    ld a,(l0243h)   ;   ; ; ;10c0   3a 43 02
    ld b,a          ;   ; ; ;10c3   save (l0242h)
    ld a,(hl)       ;   ; ; ;10c4   7e 
    and 01fh        ;   ; ; ;10c5   00011111b
    cp b            ;   ; ; ;10c7   b8
    jp nz,l65a3h    ;   ; ; ;10c8   if a.ne.(l0242h) --> ...
    ld a,(hl)       ;   ; ; ;10cb   7e
    and 80h         ;   ; ; ;10cc   10000000b
    jp nz,l65a3h    ;   ; ; ;10ce   if ne.0 --> ...
    dec hl          ;   ; ; ;10d1   2b
    dec hl          ;   ; ; ;10d2   2b
    ld d,(hl)       ;   ; ; ;10d3   56
    dec hl          ;   ; ; ;10d4   2b
    ld e,(hl)       ;   ; ; ;10d5   5e
    push hl         ;   ; ; ;10d6 \ e5
    ld hl,(l0237h)  ;   ; ; ;10d7   2a 37 02
    call cmpHL.DE   ;   ; ; ;10da   Compare HL with DE
    pop hl          ;   ; ; ;10dd / e1
    jp nz,l65a3h    ;   ; ; ;10de   if HL.ne.DE --> ...
    inc hl          ;   ; ; ;10e1   23
    inc hl          ;   ; ; ;10e2   23
    inc hl          ;   ; ; ;10e3   23
    ex de,hl        ;   ; ; ;10e4   eb
    ld hl,(l0209h)  ;   ; ; ;10e5   2a 09 02 
    call subHL.DE   ;   ; ; ;10e8   hl=hl-de
    ld (l0235h),hl  ;   ; ; ;10eb   (l0235h)=
    ld a,(l01eeh)   ;   ; ; ;10ee
    ld (l01edh),a   ;   ; ; ;10f1   (l01edh)=(l01eeh)
    ret             ;   ; ; ;10f4
                    ;   ; ;
l10f5h:         ;<--)---)-+
    ld hl,l10aeh    ;   ;   ;10f5
    ld (l0260h),hl  ;   ;   ;10f8   (l0260h)=l10aeh
    ld hl,(l01cfh)  ;   ;   ;10fb
    ld (l025eh),hl  ;   ;   ;10fe   (l025eh)=(l01cfh)
    ex de,hl        ;   ;   ;1101
    ld hl,(l0209h)  ;   ;   ;1102
    call subHL.DE   ;   ;   ;1105   hl=hl-de
    ld (l025ch),hl  ;   ;   ;1108   (l025ch)=(l0209h)-(l01cfh)
    jp l10bch   ;---+   ;   ;110b   --> ...
                        ;
l110eh:             ;<--+
    call s_1479h            ;110e   cd 79 14
    jp l0f03h               ;1111   --> ...

l1114h:
    ld a,(l0243h)           ;1114
    cp 0ch                  ;1117
    jp z,l1164h    ;----;   ;1119   if(l0243h).eq.0ch --> ...
    ld a,(l01ebh)       ;   ;111c
    dec a               ;   ;111f
    jp z,l114ah  ;----; ;   ;1120   if(l01ebh).eq.1 --> ...
l1123h:      ;<-----; ; ;
    xor a           ; ; ;   ;1123
    ld (l01eah),a   ; ; ;   ;1124   (l01eah)=0 
    ld a,(l0243h)   ; ; ;   ;1127
    cp 3            ; ; ;   ;112a
    jp c,l1139h ;-; ; ; ;   ;112c   if(l0243h) < 3 --> ...
    cp 8          ; ; ; ;   ;112f
    jp c,l0ed4h   ; ; ; ;   ;1131   if(l0243h) < 8 --> ...
    cp 0bh        ; ; ; ;   ;1134
    jp nc,l0ed4h  ; ; ; ;   ;1136   if(l0243h) >= 0bh --> ...
l1139h:       ;<--+ ; ; ;
    ld hl,(l0235h)  ; ; ;   ;1139
    ex de,hl        ; ; ;   ;113c   de=(l0235h) ------;
    ld hl,(l0237h)  ; ; ;   ;113d                     ;
    ld (l0235h),hl  ; ; ;   ;1140   (l0235h)=(l0237h) ;
    ex de,hl        ; ; ;   ;1143   hl=(l0235h) <-----+
    ld (l0237h),hl  ; ; ;   ;1144   (l0237h)=(l0235h)
    jp l0ed4h       ; ; ;   ;1147   --> ...
                    ; ; ;
l114ah:         ;<--)-+ ;
    ld a,(l0243h)   ;   ;   ;114a
    cp 6            ;   ;   ;114d
    jp nc,l1123h ;--+   ;   ;114f   if (l0243h) >= 6 --> ...
    ld hl,(l0237h)      ;   ;1152   hl=(l0237h)
    call ExtAttr        ;   ;1155   Extract Attributes from the symbol table
    ld hl,(l01d6h)      ;   ;1158
    ld (l0237h),hl      ;   ;115b   (l0237h)=(l01d6h)
    ld hl,(l01d8h)      ;   ;115e
    ld (l0239h),hl      ;   ;1161   (l0239h)=(l01d8h)
l1164h:             ;<--+
    ld hl,(l0235h)          ;1164   hl=(l0235h) 
    call ExtAttr            ;1167   Extract Attributes from the symbol table
    ld a,(l0243h)           ;116a
    dec a                   ;116d
    jp z,l119ah ;-;         ;116e   if(l0243h).eq.1 (Addition) --> ...
    dec a         ;         ;1171
    jp z,l11a6h ;-)-;       ;1172   if(l0243h).eq.2 (Multiplication) --> ...
    dec a         ; ;       ;1175
    jp z,l11c4h ;-)-)-;     ;1176   if(l0243h).eq.3 (Subtraction) --> ...
    dec a         ; ; ;     ;1179
    jp z,l11d0h   ; ; ;     ;117a   if(l0243h).eq.4 (Division) --> ...
    dec a         ; ; ;     ;117d
    jp z,l11dch   ; ; ;     ;117e   if(l0243h).eq.5 --> ...
    ld hl,l01d6h  ; ; ;     ;1181   hl=l01d6h
    call s_20fbh  ; ; ;     ;1184   Negate Integer*4 ^hl=-^hl 
l1187h:     ;<====)=)=)===I
    call s_055ah  ; ; ;   I ;1187   cd 5a 05
    ld (l0235h),hl; ; ;   I ;118a   (l0235h)=
    ret           ; ; ;   I ;118d
                  ; ; ;   I
l118eh:      ;<---)-)-)-; I
    ld hl,00000h  ; ; ; ; I ;118e
    ld (l01d6h),hl; ; ; ; I ;1191   (l01d6h)=0
    ld (l01d8h),hl; ; ; ; I ;1194   (l01d8h)=0
    jp l1187h ;===)=)=)=)=I ;1197   --> ...
                  ; ; ; ; I
l119ah:    ;<-----+ ; ; ; I
    ld hl,l01d6h    ; ; ; I ;119a   hl=l01d6h
    ld de,l0237h    ; ; ; I ;119d   de=l0237h
    call s_20e0h    ; ; ; I ;11a0   Addition integer*4 ^hl=^de+^hl
    jp l1187h   ;===)=)=)=I ;11a3   --> ...
                    ; ; ; I
l11a6h:     ;<------+ ; ; I
    ld hl,00000h      ; ; I ;11a6
    ld (l0235h),hl    ; ; I ;11a9   (l0235h)=0 
l11ach:         ;<--; ; ; I
    ld hl,l01d6h    ; ; ; I ;11ac   hl=l01d6h
    ld de,l0237h    ; ; ; I ;11af   de=l0237h
    call s_2108h    ; ; ; I ;11b2   Multiplication integer*4 ^hl=^de+^hl
l11b5h:             ; ; ; I
    ld hl,(l0235h)  ; ; ; I ;11b5
    dec hl          ; ; ; I ;11b8
    ld (l0235h),hl  ; ; ; I ;11b9   (l0235h)=(l0235h)-1 
    ld a,h          ; ; ; I ;11bc
    or a            ; ; ; I ;11bd
    jp m,l1187h   ;=)=)=)=I ;11be   if (l0235h) < 0 --> ...
    jp l11ach  ;----+ ; ; I ;11c1   --> ...
                      ; ; I
l11c4h:         ;<----+ ; I
    ld hl,l01d6h        ; I ;11c4   hl=l01d6h
    ld de,l0237h        ; I ;11c7   de=l0237h
    call s_20edh        ; I ;11ca   Subtraction integer*4 ^de=^hl-^de
    jp l1187h        ;==)=I ;11cd   --> ...
                        ; I
l11d0h:                 ; I
    ld hl,l01d6h        ; I ;11d0   hl=l01d6h 
    ld de,l0237h        ; I ;11d3   de=l0237h 
    call s_2159h        ; I ;11d6   Division integer*4 ^hl=^de+^hl
    jp l1187h        ;==)=I ;11d9   --> ...
                        ;
l11dch:                 ;
    ld hl,(l0237h)      ;   ;11dc 
    ld (l0235h),hl      ;   ;11df   (l0235h)=(l0237h)
    ld a,h              ;   ;11e2   7c
    or a                ;   ;11e3   b7
    ld hl,(l01d6h)      ;   ;11e4
    ld (l0237h),hl      ;   ;11e7   (l0237h)=(l01d6h)
    ld hl,(l01d8h)      ;   ;11ea   
    ld (l0239h),hl      ;   ;11ed   (l0239h)=(l01d8h)
    ld hl,00001h        ;   ;11f0
    ld (l01d6h),hl      ;   ;11f3   (l01d6h)=1
    ld hl,00000h        ;   ;11f6
    ld (l01d8h),hl      ;   ;11f9   (l01d8h)=0
    jp p,l11b5h         ;   ;11fc   if (l0235h) > 0 --> ...
    ld hl,(l0237h)      ;   ;11ff   2a 37 02 
    ld a,h              ;   ;1202   7c  |
    or l                ;   ;1203   b5  .
    ld hl,(l0239h)      ;   ;1204   hl=(l0239h)
    or h                ;   ;1207   b4  .
    or l                ;   ;1208   b5  .
    ld hl,00000h        ;   ;1209   hl=0
    jp nz,l118eh    ;---;   ;120c   if a.ne.0 --> ...
    call err.msg        ;   ;120f   Warning (30)
    db 30               ;   ;1212   Division by Zero
    jp l118eh       ;---+   ;1213   --> ...
;*
;*
;*
s_1216h:
    ld a,(l0243h)           ;1216
    push af                 ;1219 \ Save (l0243h)
    call s_606eh            ;121a   cd 6e 60
    pop af                  ;121d / 
    ld (l0243h),a           ;121e   Restore (l0243h)
    ret                     ;1221
;*
;*  Processing EQUIVALENCE EQUIVALENCE (nlist) [,(nlist)]...
;*
PrEquivalence:
    call g_n_chr            ;1222   Get next character
    call s_68ach            ;1225   Check '('
    ld hl,00000h            ;1228   hl=0
    ld (l027ch),hl          ;122b   (l027ch)=0
l122eh:             ;<----;
    call ChkVar           ; ;122e   Check that the name refers to a variables
    ld hl,00000h          ; ;1231   hl=0
    ld (l0288h),hl        ; ;1234   (l0288h)=0
    ex de,hl              ; ;1237   eb
    ld a,(KindID)         ; ;1238
    cp  3                 ; ;123b
    jp z,l1260h  ;----;   ; ;123d   if (KindID).eq.3 (Variable) --> ...
    call DimDecl      ;   ; ;1240   Processing Dimension declarators
    ld a,(NumDim)     ;   ; ;1243
    cp 1              ;   ; ;1246
    jp z,l1256h  ;--; ;   ; ;1248   if (NumDim).eq.1 --> ...
    ld hl,l0230h    ; ;   ; ;124b
    cp (hl)         ; ;   ; ;124e
    jp z,l1256h  ;--; ;   ; ;124f   if (l0230h).eq.0 --> Skip error message
    call err.msg    ; ;   ; ;1252   Warning (5)
    db 5            ; ;   ; ;1255   Wrong Number of Subscripts
                    ; ;   ;
l1256h:         ;<--+ ;   ;
    call s_556ah      ;   ; ;1256   cd 6a 55
    call s_08dch      ;   ; ;1259   cd dc 08
    ld (l0288h),hl    ;   ; ;125c   (l0288h)=
    ex de,hl          ;   ; ;125f   eb
l1260h:         ;<----+   ;
    ld hl,(l01cfh)        ; ;1260
    ld (l01c4h),hl        ; ;1263   (l01c4h)=(l01cfh)
    ld hl,(DataID)        ; ;1266 
    ex de,hl              ; ;1269
    ld hl,(l0288h)        ; ;126a
    call subHL.DE         ; ;126d
    ld (l028ah),hl        ; ;1270   (l028ah)=(l0288h)-(DataID)
    ld hl,(l027ch)        ; ;1273
    ld a,h                ; ;1276
    or l                  ; ;1277
    jp z,l12a6h   ;-----; ; ;1278   if (l027ch).eq.0 --> ...
l127bh:       ;<------; ; ;
    ex de,hl          ; ; ; ;127b
    ld hl,(l01cfh)    ; ; ; ;127c
    call cmpHL.DE     ; ; ; ;127f
    jp nz,l12b2h  ;-; ; ; ; ;1282   if (l01cfh).ne.(l027ch) --> ...
    ld hl,(l028ah)  ; ; ; ; ;1285
    ld a,h          ; ; ; ; ;1288
    or l            ; ; ; ; ;1289
    jp z,l1291h ;-; ; ; ; ; ;128a   if (l028ah).eq.0 --> Skip error message
    call err.msg  ; ; ; ; ; ;128d   Warning (6)
    db 6          ; ; ; ; ; ;1290   Array Multiply EQUIVALENCEd within a Group
                  ; ; ; ; ;
l1291h:        ;<-+ ; ; ; ;
    ld a,(l0299h)   ; ; ; ; ;1291
    cp ','          ; ; ; ; ;1294   Test separator
    jp z,l122eh  ;--)-)-)-+ ;1296   if (l0299h).eq.',' --> ...
    call s_5cdeh    ; ; ;   ;1299   cd de 5c
    ld a,(l0243h)   ; ; ;   ;129c
    or a            ; ; ;   ;129f
    jp z,l09ebh     ; ; ;   ;12a0   if (l0243h).eq.0 --> Clear (l029ah) & (DO_Flg) -> Ending parsing
    jp PrEquivalence; ; ;   ;12a3   --> ...
                    ; ; ;
l12a6h:         ;<--)-)-+
    ld hl,(l01cfh)  ; ;     ;12a6
    ld (l027ch),hl  ; ;     ;12a9   (l027ch)=(l01cfh)
    ld a,(ScopeID)  ; ;     ;12ac
    ld (l028ch),a   ; ;     ;12af   (l028ch)=(ScopeID)
l12b2h:       ;<----+ ;
    ld a,(ScopeID)    ;     ;12b2 
    dec a             ;     ;12b5
    jp z,l12f5h   ;-; ;     ;12b6   if (ScopeID).eq.1 --> ...
    ld hl,(l028ah)  ; ;     ;12b9
    ex de,hl        ; ;     ;12bc
    ld hl,(DataID)  ; ;     ;12bd
    add hl,de       ; ;     ;12c0
    ld (DataID),hl  ; ;     ;12c1   (DataID)=(DataID)+(l028ah)
    ld a,(l028ch)   ; ;     ;12c4
    cp 1            ; ;     ;12c7
    jp z,l1335h ;---)-)-;   ;12c9   if (l028ch).eq.1 --> ...
    ld (ScopeID),a  ; ; ;   ;12cc   (ScopeID)=(l028ch)
    call PutAttr    ; ; ;   ;12cf   Put Attributes in Symbol table
    call s_16bfh    ; ; ;   ;12d2   {call ExtAttr(EntryID); Test hl=(l01c4h)-(EntryID)}
    ld hl,(l027ch)  ; ; ;   ;12d5   hl=(l027ch)
    jp nz,l127bh  ;-)-+ ;   ;12d8   if (l01c4h).ne.(EntryID) --> ...
    dec hl          ;   ;   ;12db   2b
    dec hl          ;   ;   ;12dc   2b
    dec hl          ;   ;   ;12dd   2b
    dec hl          ;   ;   ;12de   2b
    ld b,(hl)       ;   ;   ;12df   46
    dec hl          ;   ;   ;12e0   2b
    ld c,(hl)       ;   ;   ;12e1   4e
    ex de,hl        ;   ;   ;12e2   eb
    ld hl,(EntryID) ;   ;   ;12e3   2a 74 01
    ex de,hl        ;   ;   ;12e6   eb
    ld (hl),e       ;   ;   ;12e7   73
    inc hl          ;   ;   ;12e8   23
    ld (hl),d       ;   ;   ;12e9   72
    ld h,b          ;   ;   ;12ea
    ld l,c          ;   ;   ;12eb   hl=bc
    ld (EntryID),hl ;   ;   ;12ec   (EntryID)=
    call PutAttr    ;   ;   ;12ef   Put Attributes in Symbol table
    jp l1291h       ;   ;   ;12f2   --> ...
                    ;   ;
l12f5h:         ;<--+   ;
    ld hl,(l0288h)      ;   ;12f5
    ex de,hl            ;   ;12f8
    ld hl,(DataID)      ;   ;12f9 
    add hl,de           ;   ;12fc
    ld (l028eh),hl      ;   ;12fd   (l028eh)=(DataID)+(l0288h)
    ld hl,(EntryID)     ;   ;1300
    ld (l0290h),hl      ;   ;1303   (l0290h)=(EntryID)
    ld hl,(l01cfh)      ;   ;1306
    ex de,hl            ;   ;1309 
    ld hl,(l027ch)      ;   ;130a
    call cmpHL.DE       ;   ;130d
    jp z,l1291h         ;   ;1310   if (l027ch).eq.(l01cfh) --> ...
    ld a,(l028ch)       ;   ;1313
    dec a               ;   ;1316
    jp nz,l1321h  ;-;   ;   ;1317   if (l028ch).ne.1  --> Skip error message
    call err.msg    ;   ;   ;131a   Warning (7)
    db 7            ;   ;   ;131d   Multiple EQUIVALENCE of COMMON
    jp l1291h       ;   ;   ;131e   --> ...
                    ;   ;
l1321h:         ;<--+   ;
    ld a,1              ;   ;1321
    ld (l028ch),a       ;   ;1323   (l028ch)=1
    ld hl,(l027ch)      ;   ;1326
    ld (l01c4h),hl      ;   ;1329   (l01c4h)=(l027ch)
    call ExtAttr        ;   ;132c   Extract Attributes from the symbol table
l132fh:         ;<----; ;
    ld hl,00000h      ; ;   ;132f
    ld (l028ah),hl    ; ;   ;1332   (l028ah)=0
l1335h:          ;<---)-+
    ld hl,(DataID)    ;     ;1335
    ex de,hl          ;     ;1338
    ld hl,(l028eh)    ;     ;1339
    call subHL.DE     ;     ;133c
    ld (DataID),hl    ;     ;133f   (DataID)=(l028eh)-(DataID)
    ld a,h            ;     ;1342
    or a              ;     ;1343
    jp p,l134bh  ;--; ;     ;1344   if (DataID) > 0 --> Skip error message
    call err.msg    ; ;     ;1347   Warning (8)
    db 8            ; ;     ;134a   COMMON Base Lowered
l134bh:        ;<---+ ;
    ld hl,(l028ah)    ;     ;134b
    ex de,hl          ;     ;134e
    ld hl,(l028eh)    ;     ;134f
    call subHL.DE     ;     ;1352
    ld (l028eh),hl    ;     ;1355   (l028eh)=(l028eh)-(l028ah)
    call l68bbh       ;     ;1358   cd bb 68
    ex de,hl          ;     ;135b   eb
    ld hl,(DataID)    ;     ;135c   2a 5d 01
    add hl,de         ;     ;135f   19
    ex de,hl          ;     ;1360   eb
    ld hl,(l0290h)    ;     ;1361   2a 90 02
l1364h:         ;<--; ;
      dec hl        ; ;     ;1364   hl=hl-1
      ld a,(hl)     ; ;     ;1365   7e
      and 007h      ; ;     ;1366   00000111b
      cp 4          ; ;     ;1368   fe 04
      dec hl        ; ;     ;136a   hl=hl-1
      ld b,h        ; ;     ;136b
      ld c,l        ; ;     ;136c   bc=hl
      ld a,(hl)     ; ;     ;136d   7e
      dec hl        ; ;     ;136e   hl=hl-1
      ld l,(hl)     ; ;     ;136f   6e
      ld h,a        ; ;     ;1370   67
    jp z,l1364h   ;-+ ;     ;1371   if .eq.4 --> ...
    call cmpHL.DE     ;     ;1374   Compare HL with DE
    jp nc,l137fh ;--; ;     ;1377   if HL >= DE --> ...
    ld h,b          ; ;     ;137a
    ld l,c          ; ;     ;137b   hl=bc
    ld (hl),d       ; ;     ;137c   72
    dec hl          ; ;     ;137d   2b
    ld (hl),e       ; ;     ;137e   73
l137fh:         ;<--+ ;
    ld hl,(l0290h)    ;     ;137f   2a 90 02
    ex de,hl          ;     ;1382   eb
    push de           ;     ;1383 \ Save (l0290h) --------------------;
    ld hl,(EntryID)   ;     ;1384                                     ;
    push hl           ;     ;1387 \ Save (EntryID)    --------------; ;
    ld (l0290h),hl    ;     ;1388   (l0290h)=(EntryID)              ; ;
    ex de,hl          ;     ;138b   eb                              ; ;
    ld (EntryID),hl   ;     ;138c   (EntryID)=                      ; ;
    ld a,001h         ;     ;138f   a=1                             ; ;
    ld (ScopeID),a    ;     ;1391   (ScopeID)=1                     ; ;
    call PutAttr      ;     ;1394   Put Attributes in Symbol table  ; ;
    pop hl            ;     ;1397 / Restore (EntryID) <-------------+ ;
    ld (EntryID),hl   ;     ;1398   (EntryID)=(EntryID)               ;
    pop hl            ;     ;139b / Restore  (l0290h) <---------------+
    ld (l0290h),hl    ;     ;139c   (l0290h)=
    call s_16bfh      ;     ;139f   {call ExtAttr(EntryID); Test hl=(l01c4h)-(EntryID)}
    jp nz,l132fh ;----+     ;13a2   if (l01c4h).ne.(EntryID) --> ...
    jp l1291h               ;13a5   --> ...
;*
;*  Print error message
;*
err.msg:
    ex (sp),hl          ;13a8   Get callers address
    push af             ;13a9
    push de             ;13aa
    push bc             ;13ab
    ld a,(hl)           ;13ac   Fetch error_number
    inc hl              ;13ad   23
    push hl             ;13ae   e5
    cp 064h             ;13af   test 100
    push af             ;13b1   Save error_number
    inc a               ;13b2   a=a+1
    ld (conflg),a       ;13b3   Set console
    call p.crlf         ;13b6   Put cr lf to console
    pop af              ;13b9   Restore error_number
    push af             ;13ba   Save error_number
    ld a,'?'            ;13bb   a='?' mark error
    jp nc,l13c2h ;--;   ;13bd   if error_number >= 100 skip '%'
    ld a,'%'        ;   ;13c0   a='%' mark warning
l13c2h:         ;<--+
    call putchr         ;13c2   Print mark
;
    ld hl,l0324h        ;13c5   hl="Line: "
    call PrStrg         ;13c8   Print string
;
    ld a,(l0223h)       ;13cb
    or a                ;13ce
    jp nz,l13dbh  ;---; ;13cf   if (l0223h).ne.0 --> Skip Print number
    ld hl,(NumSrc)    ; ;13d2   Get line number source file
    call PrNumb       ; ;13d5   Print number in HL as decimal number
    jp l13e1h    ;--; ; ;13d8   --> Skip Print string
                    ; ;
l13dbh:       ;<----)-+
    ld hl,l0223h    ;   ;13db   21 23 02
    call PrStrg     ;   ;13de   Print string
l13e1h:         ;<--+
    ld a,' '            ;13e1
    call putchr         ;13e3   Print ' '
    pop af              ;13e6   Restore error_number
    push af             ;13e7   Save error_number
    ld hl,WrnTab        ;13e8   hl=Point to warning msg table
    jp c,l13f3h   ;-;   ;13eb   if error_number < 100 - warning
    sub 064h        ;   ;13ee   a=a-100
    ld hl,ErrTab    ;   ;13f0   hl=Point to error msg table
l13f3h:         ;<--+
    inc a               ;13f3   a=a+1
    ld c,a              ;13f4   4f
l13f5h:         ;<--;
      ld a,(hl)     ;   ;13f5   7e
      or a          ;   ;13f6   b7
      inc hl        ;   ;13f7   hl=hl+1
      jp p,l13f5h ;-;   ;13f8   if a > 0 --> ...
      dec c         ;   ;13fb   c=c-1
    jp nz,l13f5h  ;-+   ;13fc   if c.ne.0 --> ...
    call PrStrg         ;13ff   Print string error(warning) msg
    ld a,':'            ;1402
    call putchr         ;1404   print ':'
;*
;*  Print characters scanned at the time the error was detected
;*
    ld hl,l02b5h-1      ;1407   21 b4 02
l140ah:
    inc hl              ;140a   hl=hl+1
    ld a,(hl)           ;140b   Get character
    cp ' '              ;140c
    jp z,l140ah         ;140e   Skip space
;
l1411h:            ;<-;
      ld a,(hl)       ; ;1411   Get character
      cp cr           ; ;1412   Test end of line (cr)
      jp z,l141eh ;-; ; ;1414   .. yeap
      call putchr   ; ; ;1417   Put character to console
      inc hl        ; ; ;141a
    jp l1411h   ;---)-+ ;141b   --> next character
                    ;
l141eh:       ;<----+
    call p.crlf         ;141e   Put cr lf to console
    xor a               ;1421
    ld (conflg),a       ;1422   (conflg)=0 clear console
    pop af              ;1425   Restore error_number
    jp c,l145fh ;---;   ;1426   if error_number < 100 --> skip error processing
    ld hl,(ErrCnt)  ;   ;1429
    inc hl          ;   ;142c
    ld (ErrCnt),hl  ;   ;142d   (ErrCnt)=(ErrCnt)+1
    ld hl,(TopMem)  ;   ;1430   Load value Top of memory
    ld sp,hl        ;   ;1433   Set for stack
    ld hl,(l01a4h)  ;   ;1434
    ld (HeapPtr),hl ;   ;1437   (HeapPtr)=(l01a4h)
    ld hl,(l0209h)  ;   ;143a
    ld (HeapEnd),hl ;   ;143d   (HeapEnd)=(l0209h)
    ld b,a          ;   ;1440   Save error_number
    xor a           ;   ;1441
    ld (l0173h),a   ;   ;1442   (l0173h)=0
    ld (l01d1h),a   ;   ;1445   (l01d1h)=0
    ld a,b          ;   ;1448   Restore error_number
    cp 131          ;   ;1449   if error_number.eq.131 (Premature End Of File on Input Device)
    jp z,l5176h     ;   ;144b      --> Completion compile the module
    call ClrBuf20   ;   ;144e   Clear buffer ^l02b5h length 20
l1451h:       ;<--; ;
    ld a,(l0299h) ; ;   ;1451
    cp cr         ; ;   ;1454
    jp z,Firstep  ; ;   ;1456   if (l0299h).eq.cr --> First step of the compilation
    call s_19a8h  ; ;   ;1459   Parsing source line
    jp l1451h ;---+ ;   ;145c   --> ...
                    ;
l145fh:         ;<--+
    ld hl,(WrnCnt)      ;145f
    inc hl              ;1462
    ld (WrnCnt),hl      ;1463   (WrnCnt)=(WrnCnt)+1
    pop hl              ;1466
    pop bc              ;1467
    pop de              ;1468
    pop af              ;1469
    ex (sp),hl          ;146a   fix return address
    ret                 ;146b
;*
;* Print *****
;*
s_146ch:
    ld hl,l484eh        ;146c   hl="*****"
;*
;* Print stringn in ^HL
;*
PrStrg:
l146fh:         ;<--;
    ld a,(hl)       ;   ;146f   Get character 
    inc hl          ;   ;1470
    call putchr     ;   ;1471   Put character to console
    or a            ;   ;1474   Test end string
    jp p,l146fh ;---+   ;1475   .. nope
    ret                 ;1478
;
s_1479h:
    xor a                   ;1479   a=0
;
;   ENTRY Reg A (0,6,7,11,20,23
;
s_147ah:
    push af                 ;147a \ f5
    ld a,4                  ;147b   a=4
    call ChkMem             ;147d   Test Allocate A bytes of memory
    ld hl,(l01cfh)          ;1480
    inc hl                  ;1483
    ld a,h                  ;1484
    or l                    ;1485
    jp z,l1497h  ;--;       ;1486   if (l01cfh).eq.1 --> ...
    dec hl          ;       ;1489
    ex de,hl        ;       ;148a
    ld hl,(l0209h)  ;       ;148b
    call cmpHL.DE   ;       ;148e
    jp nc,l14b5h ;--)-;     ;1491   if (l0209h) >= (l01cfh) --> ...
    call s_54c8h    ; ;     ;1494   Extract Attributes from the symbol table, entry (l01cfh)
l1497h:        ;<---+ ;
    pop af            ;     ;1497 / f1  .
l1498h:         ;<----)-;
    ld b,a            ; ;   ;1498   47  G
l1499h:        ;<---+ ; ;
    ld a,(l02a3h)   ; ; ;   ;1499   3a a3 02    : . . 
    rrca            ; ; ;   ;149c   0f  .
    or b            ; ; ;   ;149d   b0  .
    ld hl,(HeapEnd) ; ; ;   ;149e   2a 15 02    * . . 
    ld (hl),a       ; ; ;   ;14a1   77  w 
    ld a,(TypeID)   ; ; ;   ;14a2   3a ec 01    : . . 
    dec hl          ; ; ;   ;14a5   2b  +
    ld (hl),a       ; ; ;   ;14a6   77  w 
    ex de,hl        ; ; ;   ;14a7   eb  . 
    ld hl,(l01cfh)  ; ; ;   ;14a8   2a cf 01    * . . 
    ex de,hl        ; ; ;   ;14ab   eb  . 
    dec hl          ; ; ;   ;14ac   2b  +
    ld (hl),d       ; ; ;   ;14ad   72  r 
    dec hl          ; ; ;   ;14ae   2b  +
    ld (hl),e       ; ; ;   ;14af   73  s 
    dec hl          ; ; ;   ;14b0   2b  +
    ld (HeapEnd),hl ; ; ;   ;14b1   (HeapEnd)=
    ret             ; ; ;   ;14b4   c9  .
                    ; ; ;
l14b5h:          ;<-)-+ ;
    call subHL.DE   ;   ;   ;14b5   cd f6 64    . . d 
    dec hl          ;   ;   ;14b8   2b  +
    ld a,(hl)       ;   ;   ;14b9   7e  ~ 
    ld (TypeID),a   ;   ;   ;14ba   32 ec 01    2 . . 
    pop af          ;   ;   ;14bd / f1  .
    or a            ;   ;   ;14be   b7  .
    jp nz,l1498h ;--)---+   ;14bf   c2 98 14    . . . 
    ld b,a          ;       ;14c2   47  G
    dec hl          ;       ;14c3   2b  +
    ld a,(hl)       ;       ;14c4   7e  ~ 
    and 01fh        ;       ;14c5   e6 1f   . .
    cp 013h         ;       ;14c7   fe 13   . .
    jp z,l1499h ;---;       ;14c9   ca 99 14    . . .
    ex de,hl        ;       ;14cc   eb  . 
    ld hl,(HeapEnd) ;       ;14cd   2a 15 02    * . . 
    inc hl          ;       ;14d0   23  #
    inc hl          ;       ;14d1   23  #
    inc hl          ;       ;14d2   23  #
    inc hl          ;       ;14d3   23  #
    call cmpHL.DE   ;       ;14d4   cd 3b 09    . ; . 
    jp nz,l1499h ;--+       ;14d7   c2 99 14    . . . 
    ret                     ;14da   c9  .
;*
;*  g_n_chr; (l0173h)=chr
;*
s_14dbh:
    call g_n_chr            ;14db   Get next character
    ld (l0173h),a           ;14de   (l0173h)=chr
    ret                     ;14e1
;*
;*    ENTRY  Reg  A -
;*      0 -
;*      1 -
;*     -1 -
;*    EXIT
;*
s_14e2h:
    or a                    ;14e2   Test BYTE
    push af                 ;14e3 \ Save Carry status ------;
    ld (l01c3h),a           ;14e4   (l01c3h)=BYTE           ;
    xor a                   ;14e7   a=0                     ;
    ld (l024dh),a           ;14e8   (l024dh)=0              ;
    ld (l02a4h),a           ;14eb   (l02a4h)=0              ;
    ld h,a                  ;14ee                           ;
    ld l,a                  ;14ef                           ;
    ld (l0244h),hl          ;14f0   (l0244h)=0              ;
    call s_0e87h            ;14f3   cd 87 0e                ;
    pop af                  ;14f6 / Restore Carry status <--+
    push af                 ;14f7 \ Save BYTE
    jp m,l1664h             ;14f8   if BYTE < 0 --> ...
l14fbh:
    call s_1cbbh            ;14fb   cd bb 1c 
    or a                    ;14fe
    jp z,l1670h             ;14ff   if (KindID).eq.0 --> ...
    dec a                   ;1502
    jp nz,l1570h  ;-----;   ;1503   if (KindID).ne.1 (Constant)--> ...
    ld a,(l01ceh)       ;   ;1506
    or a                ;   ;1509
    jp z,l1570h   ;-----;   ;150a   if (l01ceh).eq.0 --> ...
    ld a,(l024dh)       ;   ;150d 
    or a                ;   ;1510
    jp z,l155eh  ;----; ;   ;1511   if (l024ch).eq.0 --> ...
    ld hl,(DatSiz)    ; ;   ;1514   Load Data size
    ld bc,020bh       ; ;   ;1517   Address modes DSEG (2), REL type - Set loading location counter (11)
    call s_6575h      ; ;   ;151a   cd 75 65
    ld a,(l01d6h)     ; ;   ;151d
    ld d,a            ; ;   ;1520   d=(l01d6h)
l1521h:       ;<--;   ; ;
    call s_1a9eh  ;   ; ;   ;1521   cd 9e 1a
    jp z,l152dh ;-)-; ; ;   ;1524   if eq.0 --> ...
    call s_4833h  ; ; ; ;   ;1527   Put constant byte in reg A to REL file
    jp l1521h ;---+ ; ; ;   ;152a   --> ...
                    ; ; ;
l152dh:       ;<----+ ; ;
    ld hl,0483ah      ; ;   ;152d
    ld (l01d8h),hl    ; ;   ;1530   (l01d8h)=":H"
    ld hl,(l01cch)    ; ;   ;1533
    inc hl            ; ;   ;1536
    ld (l01cch),hl    ; ;   ;1537   (l01cch)=(l01cch)+1
    ld (l01d6h),hl    ; ;   ;153a   (l01d6h)=(l01cch)+1
    ld a,4            ; ;   ;153d
    ld (SizeID),a     ; ;   ;153f   (SizeID)=4
    dec a             ; ;   ;1542
    ld (KindID),a     ; ;   ;1543   (KindID)=3 (Variable)
    call s_055ah      ; ;   ;1546   cd 5a 05
    call s_0cffh      ; ;   ;1549   cd ff 0c
    ld hl,(PrgSiz)    ; ;   ;154c
    ld (DatSiz),hl    ; ;   ;154f   (DatSiz)=(PrgSiz)
    ld hl,(l021eh)    ; ;   ;1552   hl=(l021eh)
    call l6572h       ; ;   ;1555   cd 72 65
    call s_5709h      ; ;   ;1558   cd 09 57
    jp l1579h   ;---; ; ;   ;155b   --> ...
                    ; ; ;
l155eh:     ;<------)-+ ;
    call s_5936h    ;   ;   ;155e   cd 36 59 
    ld hl,(l01d4h)  ;   ;   ;1561
    ld (l01d8h),hl  ;   ;   ;1564   (l01d8h)=(l01d4h)
    ld hl,(l01d2h)  ;   ;   ;1567
    ld (l01d6h),hl  ;   ;   ;156a   (l01d6h)=(l01d2h)
    call s_5709h    ;   ;   ;156d   cd 09 57
l1570h:       ;<----)---+
    call s_055ah    ;       ;1570   cd 5a 05
    cp 4            ;       ;1573
    jp nc,l1639h    ;       ;1575   if a >= 4 --> ...
    sbc a,a         ;       ;1578   9f
;   ret pe          ;                                   V3.4
l1579h:     ;<------+
    call s_0ea4h            ;1579   cd a4 0e
    ld a,(l0243h)           ;157c
    or a                    ;157f
    jp nz,l158fh ;--;       ;1580   if (l0243h).ne.0  --> ...
    ld a,(l0299h)   ;       ;1583
    cp cr           ;       ;1586
    jp z,l1622h  ;--)-----; ;1588   if (l0299h).eq.cr --> ...
    call err.msg    ;     ; ;158b   Error (118)
    db  118         ;     ; ;158e   Illegal Operator
                    ;     ;
l158fh:      ;<-----+     ;
    cp 6                  ; ;158f
    jp z,l15c0h ;-------; ; ;1591   if (l0243h).eq.6   --> ...
    cp 0ch              ; ; ;1594
    jp z,l15eah  ;----; ; ; ;1596   if (l0243h).eq.0ch --> ...
    cp 7              ; ; ; ;1599
    jp z,l15b2h ;-;   ; ; ; ;159b   if (l0243h).eq.7   --> ...
    ld (l02a4h),a ;   ; ; ; ;159e   (l02a4h)=a
    cp 9          ;   ; ; ; ;15a1
    jp c,l14fbh   ;   ; ; ; ;15a3   if (l02a4h) < 9    --> ...
    cp 0bh        ;   ; ; ; ;15a6
    jp z,l14fbh   ;   ; ; ; ;15a8   if (l02a4h).eq.0bh --> ...
l15abh:     ;<----)-; ; ; ;
    xor a         ; ; ; ; ; ;15ab   a=0
    ld (l02a4h),a ; ; ; ; ; ;15ac   (l02a4h)=0
    jp l14fbh     ; ; ; ; ; ;15af   --> ...
                  ; ; ; ; ;
l15b2h:      ;<---+ ; ; ; ;
    ld a,(l01c3h)   ; ; ; ; ;15b2
    or a            ; ; ; ; ;15b5
    jp nz,err126    ; ; ; ; ;15b6   if (l01c3h).ne.0 --> Error (126) Illegal Character for Syntax
    inc a           ; ; ; ; ;15b9
    ld (l01c3h),a   ; ; ; ; ;15ba   (l01c3h)=1
    jp l15abh ;-----+ ; ; ; ;15bd   --> ...
                    ; ; ; ;
l15c0h:        ;<---)-)-+ ;
    ld hl,(l0244h)  ; ;   ; ;15c0
    ld a,h          ; ;   ; ;15c3
    or l            ; ;   ; ;15c4
    jp nz,err119    ; ;   ; ;15c5   if (l0244h).ne.0 --> Error (119) Mismatched Parenthesis
    ld a,(l024dh)   ; ;   ; ;15c8
    or a            ; ;   ; ;15cb
    jp nz,l15d4h;-; ; ;   ; ;15cc   if (l024dh).ne.0 --> ...
    pop af        ; ; ;   ; ;15cf /
    jp p,err102   ; ; ;   ; ;15d0   if a > 0 --> Error (102) Illegal Statement Completion
    push af       ; ; ;   ; ;15d3 \
l15d4h:       ;<--+ ; ;   ;
    call s_1216h    ; ;   ; ;15d4   cd 16 12
l15d7h:    ;<-------)-)-; ;
    call s_0ea4h    ; ; ; ; ;15d7   cd a4 0e
    call s_0e87h    ; ; ; ; ;15da   cd 87 0e
    xor a           ; ; ; ; ;15dd   a=0
    ld h,a          ; ; ; ; ;15de
    ld l,a          ; ; ; ; ;15df   hl=0
    ld (l0244h),hl  ; ; ; ; ;15e0   (l0244h)=0 
    jp l15abh  ;----+ ; ; ; ;15e3   --> ...
                      ; ; ;
err119:               ; ; ;
    call err.msg      ; ; ; ;15e6   Error (119)
    db 119            ; ; ; ;15e9   Mismatched Parenthesis
                      ; ; ;
l15eah:     ;<--------+ ; ;
    ld hl,(l0244h)      ; ; ;15ea
    dec hl              ; ; ;15ed
    ld (l0244h),hl      ; ; ;15ee   (l0244h)=(l0244h)-1
    ld a,h              ; ; ;15f1
    or a                ; ; ;15f2
    jp p,l1615h  ;--;   ; ; ;15f3   if (l0244h) > 0  --> ...
    ld a,(l024dh)   ;   ; ; ;15f6
    or a            ;   ; ; ;15f9
    jp z,l161bh ;---)-; ; ; ;15fa   if (l024dh).eq.0 --> ...
    dec a           ; ; ; ; ;15fd
    ld (l024dh),a   ; ; ; ; ;15fe   (l024dh)=(l024dh)-1
    call s_5cdeh    ; ; ; ; ;1601   cd de 5c
    call s_1216h    ; ; ; ; ;1604   cd 16 12
    pop af          ; ; ; ; ;1607 / f1
    push af         ; ; ; ; ;1608 \ ----------------------------;
    jp p,l1579h     ; ; ; ; ;1609   if a > 0 --> ...            ;
    ld a,(l024dh)   ; ; ; ; ;160c                               ;
    or a            ; ; ; ; ;160f                               ;
    jp nz,l1579h    ; ; ; ; ;1610   if (l024dh).ne.0 --> ...    ;
    pop af          ; ; ; ; ;1613 / <---------------------------+
    ret             ; ; ; ; ;1614
                    ; ; ; ;
l1615h:         ;<--+ ; ; ;
    call s_5cdeh      ; ; ; ;1615   cd de 5c
    jp l1579h         ; ; ; ;1618   --> ...
                      ; ; ;
l161bh:       ;<------+ ; ;
    pop af              ; ; ;161b / f1
    jp z,err119         ; ; ;161c   if a.eq.0 --> Error (119) Mismatched Parenthesis
    jp s_606eh          ; ; ;161f   --> ...
                        ; ;
l1622h:     ;<----------)-+
    ld a,(l024dh)       ;   ;1622
    or a                ;   ;1625
    jp nz,err119        ;   ;1626   if (l024dh).ne.0 --> Error (119) Mismatched Parenthesis
    ld hl,(l0244h)      ;   ;1629
    ld a,h              ;   ;162c
    or l                ;   ;162d
    jp nz,err119        ;   ;162e   if (l0244h).ne.0) Error (119) Mismatched Parenthesis
    pop af              ;   ;1631 / f1
    jp z,s_606eh        ;   ;1632   if a.eq.0 --> ...
    call err.msg        ;   ;1635   Error (102)
    db 102              ;   ;1638   Illegal Statement Completion
                        ;
l1639h:                 ;
    ld a,(l0299h)       ;   ;1639
    cp '('              ;   ;163c
    jp z,l1652h ;---;   ;   ;163e   if (l0299h).eq.'(' --> ...
    cp ','          ;   ;   ;1641
    jp z,l1579h     ;   ;   ;1643   if (l0299h).eq.',' --> ...
    cp ')'          ;   ;   ;1646
    jp z,l1579h     ;   ;   ;1648   if (l0299h).eq.')' --> ...
    call err.msg    ;   ;   ;164b   Warning (27)
    db 27           ;   ;   ;164e   Invalid Operand Usage
    jp l1579h       ;   ;   ;164f   --> ...
                    ;   ;
l1652h:         ;<--+   ;
    ld a,(KindID)       ;   ;1652
    cp 5                ;   ;1655
    jp nc,l1664h ;--;   ;   ;1657   if (KindID) >= 5 (Routine) --> ...
    call s_59a5h    ;   ;   ;165a   cd a5 59
    xor a           ;   ;   ;165d
    ld (l0231h),a   ;   ;   ;165e   (l0231h)=0
    jp l1579h       ;   ;   ;1661   --> ...
                    ;   ;
l1664h:     ;<------+   ;
    ld a,6              ;   ;1664
    ld (l0243h),a       ;   ;1666   (l0243h)=6
    ld hl,l024dh        ;   ;1669
    inc (hl)            ;   ;166c   (l024dh)=(l024dh)+1
    jp l15d7h    ;------+   ;166d   --> ...

l1670h:
    ld a,(l0299h)           ;1670
    cp '('                  ;1673
    jp z,l16a2h   ;---;     ;1675   if (l0299h).eq.'(' --> ...
    ld hl,l02a4h      ;     ;1678
    inc (hl)          ;     ;167b
    dec (hl)          ;     ;167c
    jp nz,err120 ;--; ;     ;167d   if (l02a4h).ne.0 --> Error (120) Consecutive Operators
    inc (hl)        ; ;     ;1680   (l02a4h)=(l02a4h)+1
    ld a,(l0243h)   ; ;     ;1681
    dec a           ; ;     ;1684
    jp z,l14fbh     ; ;     ;1685   if (l0243h).eq.1   --> ...
    ld hl,00000h    ; ;     ;1688
    ld (l01cfh),hl  ; ;     ;168b   (l01cfh)=0
    call s_0ea4h    ; ;     ;168e   cd a4 0e
    ld a,(l0243h)   ; ;     ;1691
    cp 3            ; ;     ;1694
    jp z,l14fbh     ; ;     ;1696   if (l0243h).eq.3   --> ...
    cp 0bh          ; ;     ;1699
    jp z,l14fbh     ; ;     ;169b   if (l0243h).eq.0bh --> ...
err120:         ;<--+ ;
    call err.msg      ;     ;169e   Error (120)
    db 120            ;     ;16a1   Consecutive Operators
                      ;
l16a2h:         ;<----+
    ld hl,(l0244h)          ;16a2
    ld (l01cfh),hl          ;16a5   (l01cfh)=(l0244h)
    inc hl                  ;16a8
    ld (l0244h),hl          ;16a9   (l0244h)=(l0244h)+1
    call s_0ea4h            ;16ac   cd a4 0e
    xor a                   ;16af
    ld (l02a4h),a           ;16b0   (l02a4h)=0
    jp l14fbh               ;16b3   --> ...
;*
;*  Processing EXTERNAL (EXTERNAL name1,...)
;*
PrExternal:
    call PrName         ;16b6   Processing name
    call s_0a10h        ;16b9   cd 10 0a
    jp l092fh           ;16bc   --> Test continue processing statement
;*
;*  call ExtAttr(EntryID); Test hl=(l01c4h)-(EntryID)
;*
s_16bfh:
    ld hl,(EntryID)     ;16bf
    push hl             ;16c2 \ Save (EntryID)
    call ExtAttr        ;16c3   Extract Attributes from the symbol table
    pop de              ;16c6 / Restore (EntryID)
    ld hl,(l01c4h)      ;16c7
    call subHL.DE       ;16ca   hl=hl-de=(l01c4h)-(EntryID)
    ld a,h              ;16cd
    or l                ;16ce   Test (l01c4h)-(EntryID)
    ret                 ;16cf
;*
;*  Processing FORMAT
;*
PrFormat:
    ld hl,(l0264h)      ;16d0
    ld a,h              ;16d3
    or l                ;16d4
    push af             ;16d5   Save Carry status
    call nz,ExtAttr     ;16d6   if (l0264h).ne.0 Extract Attributes from the symbol table
    pop af              ;16d9   Resrore Carry status
    jp nz,l16e4h ;--;   ;16da   if (l0264h).ne.0 --> skip error message
    call err.msg    ;   ;16dd   Warning (15)
    db 15           ;   ;16e0   Missing Statement Number on FORMAT
    jp l1715h     ;-)-; ;16e1   --> ...
                    ; ;
l16e4h:         ;<--+ ;
    ld hl,00000h      ; ;16e4   hl=0
    ld (DataID),hl    ; ;16e7   (DataID)=0
    call s_0e2eh      ; ;16ea   cd 2e 0e
    ld hl,(DatSiz)    ; ;16ed   Load Data size
    ld a,1            ; ;16f0
    ld (l020eh),a     ; ;16f2   (l020eh)=1
    ld a,(l0262h)     ; ;16f5
    cp 5              ; ;16f8
    jp c,l1704h ;-;   ; ;16fa   if (l0262h) < 5 --> ...
    ld a,(RomFlg) ;   ; ;16fd
    or a          ;   ; ;1700   Test /M
    jp z,l170fh ;-)-; ; ;1701   if (RomFlg).ne.0 --> skip
l1704h:     ;<----+ ; ;
    ld a,1          ; ; ;1704
    ld (RomFlg),a   ; ; ;1706   (RomFlg)=1
    call s_4859h    ; ; ;1709   Put 'JP word' & word=0000 to REL file
    ld hl,(PrgSiz)  ; ; ;170c   Load Program size
l170fh:         ;<--+ ;
    ld (DataID),hl    ; ;170f   (DataID)=
    call PutAttr      ; ;1712   Put Attributes in Symbol table
l1715h:         ;<----+
    xor a               ;1715   a=0
    push af             ;1716   f5
    call g_n_chr        ;1717   Get next character
    call s_68ach        ;171a   Check '('
    ld a,(RomFlg)       ;171d
    or a                ;1720   Test /M
    jp nz,l172dh ;--;   ;1721   if (RomFlg).ne.0 --> skip
    ld hl,(DatSiz)  ;   ;1724   Load Data size
    ld bc,020bh     ;   ;1727   Address modes DSEG (2), rel type - Set loading location counter (11)
    call s_6575h    ;   ;172a   cd 75 65
l172dh:       ;<----+
    ld a,(l0299h)       ;172d   a=(l0299h)
    call s_4833h        ;1730   Put constant byte in reg A to REL file
;*
;*  Spacing Specification & Scaling Factor FORMAT
;*
l1733h:     ;<--------;
    call s_181eh      ;         ;1733   Convert decimal ASCII string to hex
    jp z,l1792h  ;----)-;       ;1736   ca 92 17
    ld a,h            ; ;       ;1739   7c
    or l              ; ;       ;173a   b5
    jp nz,l1744h ;--; ; ;       ;173b   if hl.ne.0 --> Processing FORMAT Field descriptors
    ld a,(l0299h)   ; ; ;       ;173e   3a 99 02
    jp l17bdh       ; ; ;       ;1741   --> ...
                    ; ; ;
l1744h:         ;<--+ ; ;
                      ; ;
;   Processing FORMAT Field descriptors
                      ; ;
    ld a,(l0299h)     ; ;       ;1744
    cp 'H'            ; ;       ;1747
    jp z,l17d3h       ; ;       ;1749   if (l0299h).eq.'H' --> Hollerith Conversion
    cp 'X'            ; ;       ;174c
    jp z,l1733h ;-----; ;       ;174e   if (l0299h).eq.'X' --> Spacing Specification
    cp 'P'            ; ;       ;1751
    jp z,l1733h ;-----+ ;       ;1753   if (l0299h).eq.'P' --> Scaling Factor
l1756h:     ;<----------)-----;
    cp '('              ;     ; ;1756
    jp z,l180fh         ;     ; ;1758   if a.eq.'(' --> ...
    cp 'E'              ;     ; ;175b
    jp z,l17c5h   ;-----)---; ; ;175d   if a.eq.'E' --> Numeric Conversion
    cp 'F'              ;   ; ; ;1760
    jp z,l17c5h   ;-----)---; ; ;1762   if a.eq.'F' --> Numeric Conversion
    cp 'A'              ;   ; ; ;1765
    jp z,l178fh ;---;   ;   ; ; ;1767   if a.eq.'A' --> A-Type Conversion
    cp 'I'          ;   ;   ; ; ;176a
    jp z,l178fh ;---;   ;   ; ; ;176c   if a.eq.'I' --> I-Type Conversion
    cp 'G'          ;   ;   ; ; ;176f
    jp z,l17c5h   ;-)---)---; ; ;1771   if a.eq.'G' --> Numeric Conversion
    cp 'D'          ;   ;   ; ; ;1774
    jp z,l17c5h   ;-)---)---; ; ;1776   if a.eq.'D' --> Numeric Conversion
    cp 'L'          ;   ;   ; ; ;1779
    jp z,l178fh ;---;   ;   ; ; ;177b   if a.eq.'L' --> Logical Conversion
l177eh:       ;<----)-; ;   ; ;
    ld a,(RomFlg)   ; ; ;   ; ; ;177e
    or a            ; ; ;   ; ; ;1781   Test /M
    jp nz,l178bh;-; ; ; ;   ; ; ;1782   if (RomFlg).ne.0 --> Error (126) Illegal Character for Syntax
    ld hl,(l021eh); ; ; ;   ; ; ;1785   hl=(l021eh)
    call l6572h   ; ; ; ;   ; ; ;1788   cd 72 65
l178bh:       ;<--+ ; ; ;   ; ;
    call err.msg    ; ; ;   ; ; ;178b   Error (126)
    db 126          ; ; ;   ; ; ;178e   Illegal Character for Syntax
                    ; ; ;   ; ;
l178fh:         ;<--+ ; ;   ; ;
                      ; ;   ; ;
;   Logical & A-Type Conversion FORMAT
                      ; ;   ; ;
    call s_1846h      ; ;   ; ; ;178f   Convert decimal ASCII string to hex
l1792h:       ;<------)-+-; ; ;
    cp '-'            ;   ; ; ; ;1792   Test '-'
    jp z,l17b7h ;---; ;   ; ; ; ;1794   ca b7 17
    cp ''''         ; ;   ; ; ; ;1797   Test ''''
    jp z,l17d7h  ;--)-)-; ; ; ; ;1799   Literal string
    cp ','          ; ; ; ; ; ; ;179c   Test ','
    jp z,l1733h     ; ; ; ; ; ; ;179e   Spacing Specification & Scaling Factor
    cp '/'          ; ; ; ; ; ; ;17a1   Test '/'
    jp z,l1733h     ; ; ; ; ; ; ;17a3   Spacing Specification & Scaling Factor
    cp ')'          ; ; ; ; ; ; ;17a6   Test ')'
    jp z,l17aeh ;-; ; ; ; ; ; ; ;17a8   ca ae 17
    jp l1756h ;---)-)-)-)-)-)-+ ;17ab   --> ...
                  ; ; ; ; ; ;
l17aeh:       ;<--+ ; ; ; ; ;
    pop af          ; ; ; ; ;   ;17ae / f1
    dec a           ; ; ; ; ;   ;17af   3d
    jp m,l184fh     ; ; ; ; ;   ;17b0   if < 0 --> ...
    push af         ; ; ; ; ;   ;17b3   f5
    jp l1733h       ; ; ; ; ;   ;17b4   --> Spacing Specification & Scaling Factor
                    ; ; ; ; ;
l17b7h:       ;<----+ ; ; ; ;
    call s_181eh      ; ; ; ;   ;17b7   Convert decimal ASCII string to hex
    jp z,l177eh   ;---; ; ; ;   ;17ba   ca 7e 17
l17bdh:               ; ; ; ;
    cp 'P'            ; ; ; ;   ;17bd
    jp nz,l177eh  ;---+ ; ; ;   ;17bf   if end character.ne.'P' --> ...
    jp l1733h           ; ; ;   ;17c2   --> Spacing Specification & Scaling Factor
                        ; ; ;
;   Numeric Conversion FORMAT
                        ; ; ;
l17c5h:    ;<-----------)-)-+
    call s_1846h        ; ;     ;17c5   Convert decimal ASCII string to hex
    ld a,'.'            ; ;     ;17c8
    call ch.chr         ; ;     ;17ca   Check character (a character for check)
    call s_1846h        ; ;     ;17cd   Convert decimal ASCII string to hex
    jp nz,l1792h  ;-----)-+     ;17d0   if a.ne.0 --> ...
                        ;
;   Hollerith Conversion FORMAT
                        ;
l17d3h:                 ;
    ld a,1              ;   ;17d3   a=1
    ld d,l              ;   ;17d5   55
    db 01h              ;   ;17d6   ld bc,0ff3eh (in the original)  trap_ms
l17d7h:       ;<--------+
    ld a,0ffh               ;17d7
    ld (l01ceh),a           ;17d9   (l01ceh)=-1
l17dch:         ;<------;
    call s_1a9eh        ;   ;17dc   cd 9e 1a
    jp nz,l17f6h  ;---; ;   ;17df   c2 f6 17
    ld a,(l01ceh)     ; ;   ;17e2   3a ce 01
    inc a             ; ;   ;17e5   a=a+1
    jp nz,l17efh ;--; ; ;   ;17e6   if (l01ceh).ne.0ffh --> ...
    ld a,''''       ; ; ;   ;17e9
    call s_4833h    ; ; ;   ;17eb   Put constant byte in reg A to REL file
    xor a           ; ; ;   ;17ee   a=0
l17efh:         ;<--+ ; ;
    inc a             ; ;   ;17ef   a=a+1
    ld (l0173h),a     ; ;   ;17f0   (l0173h)=
    jp l1733h         ; ;   ;17f3   --> Spacing Specification & Scaling Factor
                      ; ;
l17f6h:         ;<----+ ;
    push af             ;   ;17f6 \ Save a ---------------------------------;
    push de             ;   ;17f7 \                                         ;
    call s_4833h        ;   ;17f8   Put constant byte in reg A to REL file  ;
    pop de              ;   ;17fb /                                         ;
    ld a,(l01ceh)       ;   ;17fc                                           ;
    inc a               ;   ;17ff                                           ;
    pop bc              ;   ;1800 / b=a    <--------------------------------+
    jp nz,l17dch ;------;   ;1801   if (l01ceh).ne.-1 --> ...
    ld a,b              ;   ;1804   78
    cp ''''             ;   ;1805
    push de             ;   ;1807 \
    call z,s_4833h      ;   ;1808   if b.eq.'''' Put constant byte in reg A to REL file
    pop de              ;   ;180b /
    jp l17dch    ;------+   ;180c   --> ...

l180fh:
    pop af                  ;180f / f1
    inc a                   ;1810   3c
    push af                 ;1811 \ f5
    cp 3                    ;1812
    jp c,l1733h             ;1814   if < 3 --> Spacing Specification & Scaling Factor
    call err.msg            ;1817   Warning (18)
    db 18                   ;181a   Format Nest Too Deep
    jp l1733h               ;181b   --> Spacing Specification & Scaling Factor
;*
;*  Convert decimal ASCII string to hex
;*    EXIT  Reg HL holds number
;*    Accu holds non valid end character
;*
s_181eh:
    xor a               ;181e   a=0
    ld b,a              ;181f   b=0
    ld h,a              ;1820
    ld l,a              ;1821   hl=0
l1822h:         ;<----;
      push bc         ; ;1822
      push hl         ; ;1823
      call g_n_chr    ; ;1824   a=chr
      push af         ; ;1827 \
      call s_4833h    ; ;1828   Put constant byte in reg A to REL file
      pop af          ; ;182b /
      pop hl          ; ;182c
      pop bc          ; ;182d
      ld c,a          ; ;182e   c=chr
      jp p,l1842h ;-; ; ;182f   if chr Special character or Letter --> exit from loop
      inc b         ; ; ;1832   b=b+1
      ld d,h        ; ; ;1833
      ld e,l        ; ; ;1834   de=hl
      add hl,hl     ; ; ;1835   * 2
      add hl,hl     ; ; ;1836   * 4
      add hl,de     ; ; ;1837   * 5
      add hl,hl     ; ; ;1838   * 10
      sub '0'       ; ; ;1839   Make binary from ASCII
      ld e,a        ; ; ;183b
      ld d,0        ; ; ;183c   de=a
      add hl,de     ; ; ;183e
    jp l1822h   ;---)-+ ;183f   --> read next character
                    ;
l1842h:      ;<-----+
    inc b               ;1842   b=b+1
    dec b               ;1843   b=b-1
    ld a,c              ;1844   c=chr
    ret                 ;1845
;*
;*  Convert decimal ASCII string to hex
;*
s_1846h:
    call s_181eh        ;1846   Convert decimal ASCII string to hex
    ret nz              ;1849   if ne 0 return
    call err.msg        ;184a   Warning (17)
    db 17               ;184d   Zero Format Value
    ret                 ;184e
;*
l184fh:
    ld a,(RomFlg)       ;184f
    or a                ;1852   Test /M
    jp nz,l1862h ;--;   ;1853   if (RomFlg).ne.0 --> skip
    ld hl,(PrgSiz)  ;   ;1856   Load Program size
    ld (DatSiz),hl  ;   ;1859   (DatSiz)=(PrgSiz)
    ld hl,(l021eh)  ;   ;185c   hl=(l021eh)
    call l6572h     ;   ;185f   cd 72 65
l1862h:         ;<--+
    call g_n_chr        ;1862   Get next character
    ld a,1              ;1865   a=1 (DO_Flg)
    jp l25c1h           ;1867   --> Save (DO_Flg) -> Ending parsing statement
;*
;*  Creation variable T:xxx in a symbol table
;*    ENTRY  Reg  a - (TypeID)
;*
s_186ah:
    ld (TypeID),a       ;186a   (TypeID)=
    push af             ;186d \ Save (TypeID) --------------------------+
    ld c,a              ;186e                                           ;
    ld (l01d5h),a       ;186f   (l01d5h)=(TypeID)                       ;
    ld b,0              ;1872   bc=(TypeID)                             ;
    ld hl,'T:'          ;1874                                           ;
    ld (l01d8h),hl      ;1877   (l01d8h)=":T"                           ;
    ld hl,l029dh        ;187a                                           ;
    add hl,bc           ;187d   hl=l029dh+(TypeID)                      ;
    ld a,(hl)           ;187e                                           ;
    inc (hl)            ;187f   (l029dh+(TypeID))=(l029dh+(TypeID))+1   ;
    ld h,a              ;1880   67                                      ;
    ld a,(l029bh)       ;1881   3a 9b 02                                ;
    ld l,a              ;1884   6f                                      ;
    ld (l01d6h),hl      ;1885   (l01d6h)=                               ;
    ld a,3              ;1888                                           ;
    ld (KindID),a       ;188a   (KindID)=3 (Variable)                   ;
    ld a,5              ;188d                                           ;
    ld (SizeID),a       ;188f   (SizeID)=5                              ;
    call s_055ah        ;1892   cd 5a 05                                ;
    pop af              ;1895 / Restore <-------------------------------+
    ld (TypeID),a       ;1896    (TypeID)
    ld a,2              ;1899
    ld (ScopeID),a      ;189b   (ScopeID)=2
    jp PutAttr          ;189e   --> Put Attributes in Symbol table
;*
;*  Processing PAUSE n, STOP n
;*
PrPause:
    ld hl,l022eh        ;18a1   Load Pointer to location 1 and 2 bytes statement
    ld c,(hl)           ;18a4   Loading second character statement
    inc hl              ;18a5   hl=hl+1
    ld b,(hl)           ;18a6   Loading first character statement
    push bc             ;18a7 \ Save two characters
    call CrBuilt        ;18a8   Creating built-in routine
    call s_0951h        ;18ab   Initialization field l01dah 8-byte character ' '
;*
;*  Processing a text string up to 6 characters
;*
    ld b,6              ;18ae   b=6 Length string
    ld hl,l01e1h        ;18b0   Address of the buffer to hold the string
l18b3h:        ;<---;
      push hl       ;   ;18b3
      push bc       ;   ;18b4
      call g_n_chr  ;   ;18b5   Get next character
      pop bc        ;   ;18b8
      pop hl        ;   ;18b9
      cp cr         ;   ;18ba
      jp z,l18c8h ;-)-; ;18bc   if chr.eq.cr --> exit from loop
      ld (hl),a     ; ; ;18bf   (hl)=chr
      dec hl        ; ; ;18c0   hl=hl-1
      dec b         ; ; ;18c1   b=b-1
    jp nz,l18b3h ;--+ ; ;18c2   if b.ne.0 --> read next character
    call g_n_chr      ; ;18c5   Get next character
l18c8h:          ;<---+
    ld a,(NoCode)       ;18c8
    or a                ;18cb   Test /N
    jp nz,l18ddh ;--;   ;18cc   if (NoCode).ne.0  --> skip output
    call s_5dcbh    ;   ;18cf   if (Column).ne.0 Put cr lf to console
    call s_146ch    ;   ;18d2   Print "*****"
    call s_501bh    ;   ;18d5   Put addres DATA' to console
    ld a,tab        ;   ;18d8
    call putchr     ;   ;18da   Put tab to console
l18ddh:         ;<--+
    ld hl,l01e2h        ;18dd   21 e2 01 
    ld b,6              ;18e0   b=6
l18e2h:         ;<--;
      dec hl        ;   ;18e2   hl=hl-1
      push hl       ;   ;18e3
      push bc       ;   ;18e4
      ld a,(hl)     ;   ;18e5   a=(hl)
      call p.byte   ;   ;18e6   Put byte in reg A to REL file
      pop bc        ;   ;18e9
      pop hl        ;   ;18ea
      dec b         ;   ;18eb   b=b-1
    jp nz,l18e2h ;--+   ;18ec   if b.ne.0 --> ...
    pop af              ;18ef / Restore first character
    cp 'P'              ;18f0
    jp z,l1b45h         ;18f2   if chr.eq.'P' --> Clear (l029ah) Set (DO_Flg) -> Ending parsing statement
    jp l25bch           ;18f5   --> Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement
;*
;*  Reading string length A characters
;*    ENTRY  Reg  a - Number of read characters
;*    EXIT   Reg  a - Last character in the string
;*           Reg hl - Pointer to last character
;*
GetStr:
    push af             ;18f8   Save # of characters
    ld hl,l01e1h        ;18f9   Address of the buffer to hold the string
    push hl             ;18fc
    call s_0951h        ;18fd   Initialization field l01dah 8-byte character ' '
l1900h:         ;<--;
      call g_n_chr  ;   ;1900   Get next character
      pop hl        ;   ;1903
      pop bc        ;   ;1904   Restore # of characters on Reg B
      ld (hl),a     ;   ;1905   Save read character
      ret c         ;   ;1906   if chr Special character Return
      dec b         ;   ;1907   b=b-1
      ret z         ;   ;1908   if b.eq.0 Return
      dec hl        ;   ;1909   hl=hl-1
      push bc       ;   ;190a
      push hl       ;   ;190b
    jp l1900h   ;---+   ;190c   --> Read next character
;*
;*  Processing of actual parameters subprogram
;*
s_190fh:
    ld a,(l0299h)       ;190f
    sub cr              ;1912
    ret z               ;1914   if(l0299h).eq.cr Return
    call s_68ach        ;1915   Check '('
    ld b,0              ;1918   b=0
    ld hl,(DatSiz)      ;191a
    ld (l0296h),hl      ;191d   (l0296h)=(DatSiz)
l1920h:         ;<----;
      inc b           ; ;1920   b=b+1
      push bc         ; ;1921 \ Save b ---------------------------;
      push hl         ; ;1922 \ ----------------;                 ;
      call PrName     ; ;1923   Processing name ;                 ;
      pop hl          ; ;1926 / <---------------+                 ;
      ld (DataID),hl  ; ;1927   (DataID)=                         ;
      inc hl          ; ;192a                                     ;
      inc hl          ; ;192b                                     ;                                    ;
      push hl         ; ;192c \ hl=(DataID)+2 ------------------; ;
      ld a,3          ; ;192d                                   ; ;
      ld (ScopeID),a  ; ;192f                                   ; ;
      ld (KindID),a   ; ;1932   (KindID)=3 (Variable)           ; ;
      ld hl,(l01cfh)  ; ;1935                                   ; ;
      ld (EntryID),hl ; ;1938   (EntryID)=(l01cch)              ; ;
      call PutAttr    ; ;193b   Put Attributes in Symbol table  ; ;
      ld a,(l0299h)   ; ;193e                                   ; ;
      cp ','          ; ;1941   Test separator ','              ; ;
      pop hl          ; ;1943 / Restore hl    <-----------------+ ;
      pop bc          ; ;1944 / Restore b <-----------------------+
    jp z,l1920h  ;----+ ;1945   if (l0299h).eq.',' Found next argument
    push bc             ;1948 \ ----------------;
    ld (DatSiz),hl      ;1949   Save Data size  ;
    call s_5cdeh        ;194c   cd de 5c        ;
    pop af              ;194f / <---------------+
    ld (NumArg),a       ;1950   Save Number of arguments to transfer
    ret                 ;1953
;*
;*  Get next chatacter
;*
g_n_chr:
    ld a,(l0173h)       ;1954
    or a                ;1957
    ld a,(l0299h)       ;1958 ? Load character
    jp nz,l1975h ;----; ;195b   if (l0173h).ne.0 skip convert to upper case
l195eh:       ;<----; ;
      call s_19a8h  ; ; ;195e   Parsing source line
      cp ' '        ; ; ;1961
    jp z,l195eh ;---+ ; ;1963   Skip blank
                      ;
;   Convert character to upper case
                      ;
    cp 'a'            ; ;1966   Test range
    jp c,l1975h  ;----; ;1968   if < 'a'
    cp 'z'+1          ; ;196b
    jp nc,l1975h ;----; ;196d   if >= "{"
    sub 'a'-'A'       ; ;1970   Convert to upper case
    ld (l0299h),a     ; ;1972   Saving the converted character
                      ;
l1975h:         ;<----+

;   Test valid letter

    cp '$'              ;1975   Test $
    jp z,l1995h ;-----; ;1977   if a.eq.'$'
    cp 'A'            ; ;197a   Test start A..Z
    jp c,l1984h ;-;   ; ;197c   if a < 'A'
    cp 'Z'+1      ;   ; ;197f   Verify letter
    jp c,l1995h ;-)---; ;1981   if a < 'Z'+1
l1984h:       ;<--+   ;
    cp '0'            ; ;1984   Test special characters
    jp c,l198eh ;---; ; ;1986   if a < '0'
    cp '9'+1        ; ; ;1989   Test digits
    jp c,l1992h ;-; ; ; ;198b   if a < '9'+1 
;                 ; ; ;
; Char A..Z, $    ; ; ;
l198eh:       ;<--)-+ ;                   Equivalent  Original
    xor a         ;   ; ;198e               xor a       xor a
    inc a         ;   ; ;198f   a=1         inc a       inc a
    scf           ;   ; ;1990   Set carry   scf         scf
    db 1          ;   ; ;1991 ;-----------  jp t1996h   ld bc,03dafh    trap_ms2
l1992h:     ;<----+   ;       ;
    xor a             ; ;1992 ;             xor a
    dec a             ; ;1993 ; a=-1        dec a
    db 6              ; ;1994 ;-----------  jp t1996h   ld b,0afh       trap_ms2
l1995h:         ;<----+       ;
    xor a               ;1995 ; a=0         xor a
t1996h:     ;<----------------+
    ld a,(l0299h)       ;1996   Load character
    ld b,a              ;1999   Save value
    push af             ;199a \
    ld hl,l0173h        ;199b
    ld a,(hl)           ;199e   a=(l0173h)
    ld (hl),0           ;199f   (l0173h)=0
    or a                ;19a1
    ld a,b              ;19a2   Restore value
    call z,s_5927h      ;19a3   if((l0173h).eq.0) Move 19 bytes from l02b6h to l02b5h
    pop af              ;19a6 /
    ret                 ;19a7
;*
;*  Parsing source line
;*
s_19a8h:
l19a8h:          ;<----;
    ld hl,PosStm       ;    ;19a8
    ld e,(hl)          ;    ;19ab
    inc (hl)           ;    ;19ac   (PosStm)=(PosStm)+1
    ld hl,l0108h       ;    ;19ad   Point to source line
    ld d,0             ;    ;19b0
    add hl,de          ;    ;19b2
    ld a,(hl)          ;    ;19b3
    cp cr              ;    ;19b4   Test end of line
    jp z,l19bdh ;--;   ;    ;19b6   if (l0108h+(PosStm)).eq.cr --> ...
l19b9h:      ;<----)-; ;
    ld (l0299h),a  ; ; ;    ;19b9   (l0299h)=(l0108h+(PosStm)) or 0dh(cr) or 2fh('/')
    ret            ; ; ;    ;19bc
                   ; ; ;
l19bdh:       ;<---+ ; ;
    ld a,(l01d1h)    ; ;    ;19bd
    or a             ; ;    ;19c0
    ld a,'/'         ; ;    ;19c1
    jp nz,l19b9h ;---+ ;    ;19c3   if (l01d1h).ne.0 { a='/' --> ...}
s_19c6h:             ; ;
l19c6h:        ;<--; ; ;
    call s_5ce9h   ; ; ;    ;19c6   Print source line
    ld de,l0108h   ; ; ;    ;19c9   Point to source line
    ld a,(de)      ; ; ;    ;19cc
    cp 'C'         ; ; ;    ;19cd
    jp z,l19c6h  ;-; ; ;    ;19cf   if (l0108h).eq.'C' --> ...
    cp 'c'         ; ; ;    ;19d2
    jp z,l19c6h  ;-+ ; ;    ;19d4   if (l0108h).eq.'c' --> ...
    ld hl,PosStm     ; ;    ;19d7
    ld (hl),6        ; ;    ;19da   (PosStm)=6
    ld de,l010dh     ; ;    ;19dc   Point to Continuation character field
    ld a,(de)        ; ;    ;19df   Load character
    and 0efh         ; ;    ;19e0   11101111b
    cp ' '           ; ;    ;19e2   Test valid Continuation character
    jp nz,l19a8h  ;--)-+    ;19e4   if (l010dh).ne.(' '.or.'0') Found chr Continuation Line
    ld (hl),0        ;      ;19e7   (PosStm)=0
    ld a,cr          ;      ;19e9   a=cr
    jp l19b9h   ;----+      ;19eb   --> ...
;*
;*  Processing subscript an array
;*
s_19eeh:
    ld a,(KindID)       ;19ee
    cp 3                ;19f1
    jp z,l19fah ;---;   ;19f3   if (KindID).eq.3 --> Skip error message
    call err.msg    ;   ;19f6   Warning (3)
    db 3            ;   ;19f9   Array Name Misuse
l19fah:         ;<--+
    ld hl,(l01cfh)      ;19fa
    push hl             ;19fd \ Save (l01cch)
    call DimDecl        ;19fe   Processing Dimension declarators
    ld a,1              ;1a01
    ld (KindID),a       ;1a03   (KindID)=1 (Constant)
    ld a,7              ;1a06   a=7
    ld (TypeID),a       ;1a08   (TypeID)=7
    ld a,(NumDim)       ;1a0b
    ld (ScopeID),a      ;1a0e   (ScopeID)=(NumDim)
    rlca                ;1a11   Multiply by 2
    ld (SizeID),a       ;1a12   (SizeID)=(ScopeID)*2
    ld hl,(l0270h)      ;1a15
    ld (l01d8h),hl      ;1a18   (l01d8h)=(l0270h)
    ld hl,(l0272h)      ;1a1b
    ld (l01d6h),hl      ;1a1e   (l01d6h)=(l0272h)
    ld hl,(l0274h)      ;1a21
    ld (l01d4h),hl      ;1a24   (l01d4h)=(l0274h)
    ld hl,(l0209h)      ;1a27
    ld (l0220h),hl      ;1a2a   (l0220h)=(l0209h)
    ld (l01cfh),hl      ;1a2d   (l01cfh)=(l0209h)
    call s_04e9h        ;1a30   cd e9 04
    call PutAttr        ;1a33   Put Attributes in Symbol table
    pop hl              ;1a36 / hl=(l01cch)
    call ExtAttr        ;1a37   Extract Attributes from the symbol table
    ld a,004h           ;1a3a
    ld (KindID),a       ;1a3c   (KindID)=4 (Array)
    call PutAttr        ;1a3f   Put Attributes in Symbol table
    jp s_54c8h          ;1a42   --> Extract Attributes from the symbol table, entry (l01cfh)
;*
;*  Processing IF(e) m1,m2,m3 or IF(u) s
;*
PrIf:
    ld a,1              ;1a45   a=1
    call s_14e2h        ;1a47   cd e2 14
    call s_1479h        ;1a4a   cd 79 14
    call g_n_chr        ;1a4d   Get next character
    ld hl,PosStm        ;1a50
    jp m,l1a6eh   ;---; ;1a53   if chr Digit --> Arithmetic IF
                      ;
;   Logical IF        ;
                      ;
    dec (hl)          ; ;1a56   (PosStm)=(PosStm)-1
    ld a,020h         ; ;1a57
    ld (l02c8h),a     ; ;1a59   (l02c8h)=020h
    ld a,(l0222h)     ; ;1a5c
    or a              ; ;1a5f
    jp z,l1a67h ;---; ; ;1a60   if (l0222h).eq.0 --> Skip error message
    call err.msg    ; ; ;1a63   Error (135)
    db 135          ; ; ;1a66   Illegal Statement Following Logical IF
l1a67h:         ;<--+ ;
    inc a             ; ;1a67
    ld (l0222h),a     ; ;1a68   (l0222h)=(l0222h)+1
    jp l6755h         ; ;1a6b   --> ...
                      ;
;   Arithmetic IF     ;
                      ;
l1a6eh:        ;<-----+
    dec (hl)            ;1a6e   (PosStm)=(PosStm)-1
    ld a,020h           ;1a6f
    ld (l02c8h),a       ;1a71   (l02c8h)=20h
    call s_41f7h        ;1a74   cd f7 41
    call s_47b3h        ;1a77   cd b3 47
    call s_21aeh        ;1a7a   Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cfh)      ;1a7d
    ld (l020fh),hl      ;1a80   (l020fh)=(l01cfh)
    call ChComma        ;1a83   Check ','
    call s_21aeh        ;1a86   Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cfh)      ;1a89
    ld (l0211h),hl      ;1a8c   (l0211h)=(l01cfh)
    call ChComma        ;1a8f   Check ','
    call s_21aeh        ;1a92   Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cfh)      ;1a95
    ld (l0213h),hl      ;1a98   (l0213h)=(l01cfh)
    jp l25bch           ;1a9b   --> Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_1a9eh:
    ld a,(l01ceh)       ;1a9e
    dec a               ;1aa1
    jp nz,l1aaah ;--;   ;1aa2   if (l01cbh).ne.1 --> ...
    or d            ;   ;1aa5   b2
    jp z,l1ad9h ;---)-; ;1aa6   ca d9 1a
    dec d           ; ; ;1aa9   15
l1aaah:         ;<--+ ;
    push de           ; ;1aaa \
    call s_19a8h      ; ;1aab   Parsing source line
    call s_5927h      ; ;1aae   Move 19 bytes from l02b6h to l02b5h
    pop de            ; ;1ab1 /
    cp cr             ; ;1ab2
    jp z,err123       ; ;1ab4   if cr --> Error (123) Illegal Hollerith Construction
    sub ''''          ; ;1ab7
    jp z,l1abfh ;-;   ; ;1ab9   if eq '''' --> ...
l1abch:      ;<---)-; ;
    ld a,c        ; ; ; ;1abc   79
    or a          ; ; ; ;1abd   b7
    ret           ; ; ; ;1abe
                  ; ; ;
l1abfh:       ;<--+ ; ;
    ld a,(l01ceh)   ; ; ;1abf
    dec a           ; ; ;1ac2
    jp z,l1abch ;---; ; ;1ac3   if (l01ceh).eq.0ffh --> ...
    push de         ; ; ;1ac6 \
    call s_19a8h    ; ; ;1ac7   Parsing source line
    call s_5927h    ; ; ;1aca   Move 19 bytes from l02b6h to l02b5h
    pop de          ; ; ;1acd /
    sub ''''        ; ; ;1ace
    jp z,l1abch ;---+ ; ;1ad0   if eq '''' --> ...
    ld a,c            ; ;1ad3
    sub 20h           ; ;1ad4
    jp nz,l1adeh ;--; ; ;1ad6   if c.ne.' ' --> ...
l1ad9h:       ;<----)-+
    push de         ;   ;1ad9 \
    call g_n_chr    ;   ;1ada   Get next character
    pop de          ;   ;1add /
l1adeh:         ;<--+
    xor a               ;1ade   a=0
    ret                 ;1adf
;
err123:
    call err.msg        ;1ae0   Error (123)
    db 123              ;1ae3   Illegal Hollerith Construction
;*
;*
;*
l1ae4h:
    xor a                       ;1ae4   a=0
    push af                     ;1ae5 \ f5
l1ae6h:                 ;<--;
      call g_n_chr          ;   ;1ae6   Get next character
      jp p,l1b17h ;-----;   ;   ;1ae9   if chr Special character or Letter --> ...
      sub '0'           ;   ;   ;1aec   Make binary from ASCII
l1aeeh:             ;<--)-; ;
      ld e,a            ; ; ;   ;1aee   5f
      ld a,(l01d9h)     ; ; ;   ;1aef   3a d9 01
      and 0f0h          ; ; ;   ;1af2   11110000b
      jp z,l1b05h ;---; ; ; ;   ;1af4   ca 05 1b
      pop af          ; ; ; ;   ;1af7 /
      jp nz,l1b04h;-; ; ; ; ;   ;1af8   c2 04 1b
      inc a         ; ; ; ; ;   ;1afb   a=a+1 
      push af       ; ; ; ; ;   ;1afc \ f5  .
      push de       ; ; ; ; ;   ;1afd \ ------------------------;
      call err.msg  ; ; ; ; ;   ;1afe   Warning (29)            ;
      db 29         ; ; ; ; ;   ;1b01   Hex Constant Overflow   ;
      pop de        ; ; ; ; ;   ;1b02 / <-----------------------+
      db 6          ; ; ; ; ;   ;1b03   ld b,0f5h (in the original) trap_ms ***
l1b04h:         ;<--+ ; ; ; ;
      push af         ; ; ; ;   ;1b04 \
l1b05h:       ;<------+ ; ; ;
      ld d,4            ; ; ;   ;1b05   d=4
l1b07h:           ;<-;  ; ; ;
        call s_20adh ;  ; ; ;   ;1b07   cd ad 20
        dec d        ;  ; ; ;   ;1b0a   d=d-1
      jp nz,l1b07h ;-+  ; ; ;   ;1b0b   if d.ne.0 next step
      ld hl,l01d2h      ; ; ;   ;1b0e   21 d2 01    ! . . 
      ld a,(hl)         ; ; ;   ;1b11   7e  ~ 
      or e              ; ; ;   ;1b12   b3  .
      ld (hl),a         ; ; ;   ;1b13   77  w 
    jp l1ae6h   ;-------)-)-+   ;1b14   --> Get next character
                        ; ;
l1b17h:      ;<---------+ ;
    cp 'A'                ;     ;1b17   Test start A..Z
    jp c,l1b23h ;---;     ;     ;1b19   if < 'A' --> ...
    sub 037h        ;     ;     ;1b1c   d6 37
    cp 16           ;     ;     ;1b1e
    jp c,l1aeeh   ;-)-----+     ;1b20   if < 16 --> ...
l1b23h:         ;<--+
    pop af                      ;1b23 / f1  .
    ld a,''''                   ;1b24   "'"
    call ch.chr                 ;1b26   Check character (a character for check)
    jp g_n_chr                  ;1b29   --> Get next character
;*
;*  Processing integer constant with test (KindID)=Constant
;*
s_1b2ch:
    call l25b5h         ;1b2c   Processing integer constant with error checking
    ld a,(KindID)       ;1b2f
    dec a               ;1b32
    ret z               ;1b33   if (KindID).eq.1 (Constant) Return
    call err.msg        ;1b34   Error (109)
    db 109             ;1b37    Incorrect Integer Constant
;*
;*  Clear buffer ^l02b5h length 20
;*
ClrBuf20:
    ld a,20             ;1b38   a=20 - Length cleaned area
    ld hl,l02b5h        ;1b3a   Starting address buffer
l1b3dh:           ;<--;
      ld (hl),' '     ; ;1b3d   (hl)=' '
      inc hl          ; ;1b3f   hl=hl+1
      dec a           ; ;1b40   a=a-1
    jp nz,l1b3dh ;----+ ;1b41   if a.ne.0 --> Clear next cell
    ret                 ;1b44
;*
;*  Clear (l029ah) Set (DO_Flg) -> Ending parsing statement
;*
l1b45h:
    xor a               ;1b45
    ld (l029ah),a       ;1b46   (l029ah)=0
    inc a               ;1b49   a=1 (DO_Flg)
    jp l25c1h           ;1b4a   --> Save (DO_Flg) -> Ending parsing statement
;*
;*  Processing IMPLICIT (IMPLICIT type(range),...)
;*
PrImpicit:
    call ParTyp             ;1b4d   Parsing type definitions from IMPLICIT
    push af                 ;1b50 \ Save ID_Type variable
    call g_n_chr            ;1b51   Get next character
    call s_68ach            ;1b54   Check '('
;*
;*  Processing a single or range alphabetic characters (for example, A or W-Z)
;*
l1b57h:         ;<-------;
    call g_n_chr         ;  ;1b57   Get next character
    jp m,err126          ;  ;1b5a   if chr Digit --> Error (126) Illegal Character for Syntax
    jp c,l1ba3h  ;-----; ;  ;1b5d   if chr Special character --> Expected symbol ')'
    sub 'A'            ; ;  ;1b60   Calculation of the index
    ld c,a             ; ;  ;1b62
    ld b,0             ; ;  ;1b63   bc=a
    ld hl,TypeDef      ; ;  ;1b65   hl=Pointer table type definitions variables
    add hl,bc          ; ;  ;1b68   Calculation position in the table
    push hl            ; ;  ;1b69 \ Save position in the table -------------;
    call g_n_chr       ; ;  ;1b6a   Get next character                      ;
    cp '-'             ; ;  ;1b6d   Test delimiter range                    ;
    pop de             ; ;  ;1b6f / Restore position in the table in DE <---+
    ld h,d             ; ;  ;1b70
    ld l,e             ; ;  ;1b71   hl=de
    jp nz,l1b91h ;---; ; ;  ;1b72   if chr.ne.'-' --> Delimiter range not found
    push de          ; ; ;  ;1b75 \ Save de ----------------------------------------;
    call g_n_chr     ; ; ;  ;1b76   Get next character                              ;
    jp nz,err126     ; ; ;  ;1b79   if chr Special character or Digit               ;
                     ; ; ;            --> Error (126) Illegal Character for Syntax  ;
    push af          ; ; ;  ;1b7c \ --------------------;                           ;
    call g_n_chr     ; ; ;  ;1b7d ? Get next character  ; (Skip chr ?)              ;
    pop af           ; ; ;  ;1b80 / <-------------------+                           ;
    sub 'A'          ; ; ;  ;1b81   Calculation of the index from previous chr      ;
    ld c,a           ; ; ;  ;1b83                                                   ;
    ld b,0           ; ; ;  ;1b84   bc=a                                            ;
    ld hl,TypeDef    ; ; ;  ;1b86   hl=Pointer table type definitions variables     ;
    add hl,bc        ; ; ;  ;1b89   Calculation position in the table               ;
    pop de           ; ; ;  ;1b8a / Restore de <------------------------------------+
    call cmpHL.DE    ; ; ;  ;1b8b   Compare HL with DE
    jp c,err126      ; ; ;  ;1b8e   if HL < DE --> Error (126) Illegal Character for Syntax
l1b91h:         ;<---+ ; ;
t1b91h:         ;<---; ; ;
      pop af         ; ; ;  ;1b91 / Restore ID_Type
      ld (de),a      ; ; ;  ;1b92   (de)=ID_Type
      push af        ; ; ;  ;1b93 \ Save ID_Type
      call cmpHL.DE  ; ; ;  ;1b94   Compare HL with DE
      inc de         ; ; ;  ;1b97   de=de+1
    jp nz,t1b91h ;---+ ; ;  ;1b98   if HL.ne.DE --> Next step
    ld a,(l0299h)      ; ;  ;1b9b
    cp ','             ; ;  ;1b9e   if (l0298h).eq.',' (found separator) {
    jp z,l1b57h ;------)-+  ;1ba0       --> Processing next a single or range alphabetic characters}
l1ba3h:            ;<--+            Expected symbol ')'
    cp ')'                  ;1ba3
    jp nz,err126            ;1ba5   if (l0298h).ne.')' --> Error (126) Illegal Character for Syntax
    pop af                  ;1ba8 / Balance stack after exit from loop
    call g_n_chr            ;1ba9   Get next character
    cp ','                  ;1bac   Test separator
    jp z,PrImpicit          ;1bae   if chr.eq.',' (found separator) --> Processing next IMPLICIT
    ld hl,(l031dh)          ;1bb1   hl=(l031dh)
    call ExtAttr            ;1bb4   Extract Attributes from the symbol table
l1bb7h:         ;<--------;
    cp 3                  ; ;1bb7
    jp c,l1bd5h ;-------; ; ;1bb9   if (KindID) < 3 (Variable) --> ...
    ld a,(ScopeID)      ; ; ;1bbc
    cp 2                ; ; ;1bbf
    jp z,l1bc9h ;--;    ; ; ;1bc1   if (ScopeID).eq.2 --> ...
    cp 3           ;    ; ; ;1bc4
    jp nz,l1bd5h ;-)-;  ; ; ;1bc6   if (ScopeID).ne.3 --> ...
l1bc9h:       ;<---+ ;  ; ;
    ld a,(l01d9h)    ;  ; ; ;1bc9   a=(l01d9h)
    call GetType     ;  ; ; ;1bcc   Get value type variables
    ld (TypeID),a    ;  ; ; ;1bcf   Save value type variable
    call PutAttr     ;  ; ; ;1bd2   Put Attributes in Symbol table
l1bd5h:         ;<---+<-+ ;
    call s_688bh          ; ;1bd5   Calculate address next symbol in the Symbols table;
                          ;           if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp nc,l1bb7h ;--------+ ;1bd8   if (l0209h) < (l01cfh) --> ...
    jp l09ebh               ;1bdb   --> Clear (l029ah) & (DO_Flg) -> Ending parsing
;*
;*  Get value type definitions variables
;*    ENTRY Reg A first character of the name
;*    EXIT  Reg A value type definitions variables
;*
GetType:
    cp '$'                  ;1bde   Test '$' (indication System variable names)
    jp nz,FromTable ;--;    ;1be0   if a.ne.'$' Get value from table
    xor a              ;    ;1be3   a=0 (INTEGER)
    ret                ;    ;1be4   
                       ;
; Get value from table ;
                       ;
FromTable:       ;<----+
    ld hl,TypeDef           ;1be5   hl=Pointer table type definitions variables
    sub 'A'                 ;1be8   Calculation of the index
    ld e,a                  ;1bea
    ld d,0                  ;1beb   de=a
    add hl,de               ;1bed   Calculation position in the table
    ld a,(hl)               ;1bee   Get value
    ret                     ;1bef   
;*
;*  Parsing type definitions from IMPLICIT
;*
;*    EXIT Reg A - ID_Type:
;*      0 - INTEGER, INTEGER*2 or System variable names
;*      1 - REAL, REAL*4
;*      2 - LOGICAL, BYTE
;*      3 - DOUBLE PRECISION, REAL*8
;*      4 - INTEGER*4
;*
ParTyp:
    call g_n_chr        ;1bf0   Get next character
    jp nz,err126        ;1bf3   if chr Special character or Digit --> Error (126) Illegal Character for Syntax
    cp 'B'              ;1bf6   Test 'B'
    ld hl,Type_b        ;1bf8   hl=bYTE
    jp z,TypFnd  ;--;   ;1bfb   .. yeap
    ld hl,Type_i    ;   ;1bfe   hl=iNTEGER
    cp 'I'          ;   ;1c01   Test 'I'
    jp z,TypFnd  ;--;   ;1c03   .. yeap
    ld hl,Type_d    ;   ;1c06   hl=dOUBLEPRECISION
    cp 'D'          ;   ;1c09   Test 'D'
    jp z,TypFnd  ;--;   ;1c0b   .. yeap
    ld hl,Type_l    ;   ;1c0e   hl=lOGICAL
    cp 'L'          ;   ;1c11   Test 'L'
    jp z,TypFnd  ;--;   ;1c13   .. yeap
    cp 'R'          ;   ;1c16   Test 'R'
    jp nz,err126    ;   ;1c18   .. nope --> Error (126) Illegal Character for Syntax
    ld hl,Type_r    ;   ;1c1b   .. yeap hl=rEAL
                    ;
TypFnd:         ;<--+
;
;   Found first character type description
;   Test following character
;
    ld b,(hl)           ;1c1e   Load Length string in table
    inc hl              ;1c1f   Update pointer
l1c20h:         ;<--;
      push bc       ;   ;1c20
      push hl       ;   ;1c21
      call g_n_chr  ;   ;1c22   Get next character
      pop hl        ;   ;1c25
      pop bc        ;   ;1c26
      cp (hl)       ;   ;1c27   
      jp nz,err126  ;   ;1c28   if chr.ne.byte from string --> Error (126) Illegal Character for Syntax
      inc hl        ;   ;1c2b   hl=hl+1
      dec b         ;   ;1c2c   b=b-1
    jp nz,l1c20h ;--+   ;1c2d   if b.ne.0 --> Compare next character
    ld a,(hl)           ;1c30   Load ID_Type from table
    cp 3                ;1c31
    ret z               ;1c33   if ID_Type.eq.3 (DOUBLE PRECISION, REAL*8) Return
    push af             ;1c34 \ Save ID_Type
    call g_n_chr        ;1c35   Get next character
    cp '*'              ;1c38
    jp z,Modifier ;--;  ;1c3a   if chr.eq.'*' --> Processing data type length specifier
    ld (l0173h),a    ;  ;1c3d   (l0173h)=chr
    pop af           ;  ;1c40 / Restore ID_Type
    ret              ;  ;1c41
                     ;
Modifier:        ;<--+          Processing data type length specifier
    call g_n_chr        ;1c42   Get next character
    jp p,err126         ;1c45   if --> Error (126) Illegal Character for Syntax
    sub '0'             ;1c48   Make binary Size_storage in bytes variable or array element
    ld b,a              ;1c4a   Save value Size_storage
    pop af              ;1c4b / Restore ID_Type
    dec a               ;1c4c
    ld a,b              ;1c4d   Restore value Size_storage
    jp z,MdReal ;---;   ;1c4e   if ID_Type.eq.1 (REAL) --> ...
    dec a           ;   ;1c51
    jp z,MdByte ;-; ;   ;1c52   if Size_storage.eq.1 --> ...
    dec a         ; ;   ;1c55
    ret z         ; ;   ;1c56   if Size_storage.eq.2 Return (a=0 INTEGER, INTEGER*2)
    ld a,b        ; ;   ;1c57   Restore value Size_storage
    cp 4          ; ;   ;1c58.
    ret z         ; ;   ;1c5a   if Size_storage.eq.4 return (a=4 INTEGER*4)
    jp err126     ; ;   ;1c5b   --> Error (126) Illegal Character for Syntax
MdByte:     ;<----+ ;
    ld a,2          ;   ;1c5e   a=2 (LOGICAL, BYTE)
    ret             ;   ;1c60
                    ;
MdReal:         ;<--+
    cp 4                ;1c61
    ld a,1              ;1c63   a=1 (REAL)
    ret z               ;1c65   if Size_storage.eq.4 Return
    ld a,b              ;1c66   Restore value Size_storage
    cp 8                ;1c67
    ld a,3              ;1c69   a=3 (DOUBLE PRECISION, REAL*8)
    ret z               ;1c6b   if Size_storage.eq.8 Return
    jp err126           ;1c6c   --> Error (126) Illegal Character for Syntax
;*
;*  Processing INCLUDE <filename>
;*
PrInclude:
    ld a,1              ;1c6f   a=1
    ld (l01d1h),a       ;1c71   (l01d1h)=1 Set include flag
    ld hl,IncBuf        ;1c74   Pointer to string specifying name of file
    ld b,40             ;1c77   Length character string
l1c79h:         ;<--;
      push bc       ;   ;1c79
      push hl       ;   ;1c7a
      call g_n_chr  ;   ;1c7b   Get next character
      pop hl        ;   ;1c7e
      pop bc        ;   ;1c7f
      cp '/'        ;   ;1c80
      jp z,l1c8bh ;-)-; ;1c82   if chr.eq '/' --> exit from loop
      ld (hl),a     ; ; ;1c85   (hl)=chr (put in buffer)
      inc hl        ; ; ;1c86   hl=hl+1
      dec b         ; ; ;1c87   b=b-1
    jp nz,l1c79h ;--+ ; ;1c88   if b.ne.0 next char
l1c8bh:         ;<----+
    ld (hl),' '         ;1c8b   Replace '/' on ' ' (options not implemented)
    ld hl,IncBuf        ;1c8d   Pointer to string specifying name of file
    call ParsName       ;1c90   Parsing include file name and open it
    or a                ;1c93   Test success
    jp nz,err137        ;1c94   if a.ne.0 --> Error (137) File Not Found
    xor a               ;1c97
    ld (l01d1h),a       ;1c98   (l01d1h)=0
    inc a               ;1c9b
    ld (incflg),a       ;1c9c   (incflg)=1
    call s_19c6h        ;1c9f   cd c6 19
    jp l09ebh           ;1ca2   --> Clear (l029ah) & (DO_Flg) -> Ending parsing statement
;*
;*  Processing name
;*
PrName:
    call s_1cafh        ;1ca5   cd af 1c
    cp 3                ;1ca8
    ret nc              ;1caa   if (KindID) > 3 Return
    call err.msg        ;1cab   Error (105)
    db 105              ;1cae   Missing Name
;*
;*  EXIT reg A:
;*    0 - ?
;*    1 - Constant
;*    2 - Label
;*    3 - Variable
;*    4 - Array Name
;*
s_1cafh:
    call s_1cbbh        ;1caf   cd bb 1c
s_1cb2h:
    or a                ;1cb2   b7
    call nz,s_055ah     ;1cb3   c4 5a 05
    ld a,(KindID)       ;1cb6
    or a                ;1cb9   Test (KindID)
    ret                 ;1cba
;*
;*
;*
s_1cbbh:
    xor a                       ;1cbb
    ld (KindID),a               ;1cbc   (KindID)=0
    ld (l0243h),a               ;1cbf   (l0243h)=0
    ld (l01ceh),a               ;1cc2   (l01ceh)=0
    ld l,a                      ;1cc5
    ld h,a                      ;1cc6
    ld (l0278h),hl              ;1cc7   (l0278h)=0
    ld (l027ah),hl              ;1cca   (l027ah)=0
    call s_0941h                ;1ccd   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
l1cd0h:
    xor a                       ;1cd0
    ld (TypeID),a               ;1cd1   (TypeID)=0 (INTEGER)
l1cd4h:         ;<----------;
    call g_n_chr            ;   ;1cd4   Get next character
    jp m,l1df9h             ;   ;1cd7   if chr Digit --> ...
    ld c,a                  ;   ;1cda   Save chr
    rra                     ;   ;1cdb   1f
    ld b,a                  ;   ;1cdc   47
    ld a,(TypeID)           ;   ;1cdd
    or a                    ;   ;1ce0
    jp nz,l1e2ah ;----------)-; ;1ce1   if (TypeID).ne.0 (INTEGER) --> ...
    ld (l027ah),a           ; ; ;1ce4   (l027ah)=0
    inc a                   ; ; ;1ce7
    ld (TypeID),a           ; ; ;1ce8   (TypeID)=1 (REAL)
    ld a,4                  ; ; ;1ceb
    ld (SizeID),a           ; ; ;1ced   (SizeID)=4
    ld a,c                  ; ; ;1cf0   Restore chr
    cp '.'                  ; ; ;1cf1
    jp z,l1ed5h             ; ; ;1cf3   if chr.eq.'.' --> ...
    ld a,(KindID)           ; ; ;1cf6
    or a                    ; ; ;1cf9
    jp nz,l1f43h            ; ; ;1cfa   if (KindID).ne.0  --> ...
    ld a,c                  ; ; ;1cfd   Restore chr
    sub ''''                ; ; ;1cfe
    jp nz,l1d10h ;--;       ; ; ;1d00   if chr.ne.'''' --> ...
    ld (TypeID),a   ;       ; ; ;1d03   (TypeID) = 0 (INTEGER)
    dec a           ;       ; ; ;1d06
    ld (l01ceh),a   ;       ; ; ;1d07   (l01ceh) = -1
    ld a,1          ;       ; ; ;1d0a
    ld (KindID),a   ;       ; ; ;1d0c   (KindID)=1 (Constant)
    ret             ;       ; ; ;1d0f
                    ;       ; ;
l1d10h:     ;<------+       ; ;
    ld a,(l0278h)           ; ; ;1d10
    or a                    ; ; ;1d13
    jp nz,l1dedh   ;------; ; ; ;1d14   if (l0278h).ne.0 --> ...
    ld a,(l025ah)         ; ; ; ;1d17
    or a                  ; ; ; ;1d1a
    jp z,l1d29h ;---;     ; ; ; ;1d1b   if (l025ah).eq.0 --> ...
    ld a,c          ;     ; ; ; ;1d1e   Restore chr
    cp '+'          ;     ; ; ; ;1d1f
    jp z,l1de7h  ;--)---; ; ; ; ;1d21   if chr.eq.'+' --> ...
    cp '-'          ;   ; ; ; ; ;1d24
    jp z,l1de7h  ;--)---; ; ; ; ;1d26   if chr.eq.'-' --> ...
l1d29h:     ;<------+   ; ; ; ;  
    ld a,b              ; ; ; ; ;1d29   78
    rla                 ; ; ; ; ;1d2a   17
    jp c,l1d9fh         ; ; ; ; ;1d2b   if --> ...
    ld a,c              ; ; ; ; ;1d2e   Restore chr
    cp 'Z'              ; ; ; ; ;1d2f
    jp z,l1d39h  ;--;   ; ; ; ; ;1d31   if chr.eq.'Z' --> ...
    cp 'X'          ;   ; ; ; ; ;1d34
    jp nz,l1d72h ;--)-; ; ; ; ; ;1d36   if chr.ne.'X' --> ...
l1d39h:         ;<--+ ; ; ; ; ;         Expected single quote, up to 4 hexadecimal digits (0-9 and A-F) and a single quote
    push bc           ; ; ; ; ; ;1d39 \
    call g_n_chr      ; ; ; ; ; ;1d3a   Get next character
    pop bc            ; ; ; ; ; ;1d3d /
    cp ''''           ; ; ; ; ; ;1d3e
    jp nz,l1d6fh ;--; ; ; ; ; ; ;1d40   if chr.ne.'''' --> ...
    call l1ae4h     ; ; ; ; ; ; ;1d43   cd e4 1a
    ld hl,(l01d6h)  ; ; ; ; ; ; ;1d46
    ld a,h          ; ; ; ; ; ; ;1d49
    or l            ; ; ; ; ; ; ;1d4a
    ld hl,(l01d8h)  ; ; ; ; ; ; ;1d4b
    or h            ; ; ; ; ; ; ;1d4e
    or l            ; ; ; ; ; ; ;1d4f
    jp nz,l1e44h    ; ; ; ; ; ; ;1d50   if (l01d6h).ne.0.or.(l01d8h).ne.0.or.(l01d9h).ne.0 --> ...
    ld hl,(l01d2h)  ; ; ; ; ; ; ;1d53
    ld (l01d6h),hl  ; ; ; ; ; ; ;1d56   (l01d6h)=(l01d2h)
    ld hl,(l01d4h)  ; ; ; ; ; ; ;1d59
    ld (l01d8h),hl  ; ; ; ; ; ; ;1d5c   (l01d8h)=(l01d4h)
    xor a           ; ; ; ; ; ; ;1d5f
    ld (TypeID),a   ; ; ; ; ; ; ;1d60   (TypeID)=0 (INTEGER)
    inc a           ; ; ; ; ; ; ;1d63
    ld (KindID),a   ; ; ; ; ; ; ;1d64   (KindID)=1 (Constant)
    ld a,4          ; ; ; ; ; ; ;1d67
    ld (SizeID),a   ; ; ; ; ; ; ;1d69   (SizeID)=4
    jp l1d9fh       ; ; ; ; ; ; ;1d6c   --> ...
                    ; ; ; ; ; ;
l1d6fh:          ;<-+ ; ; ; ; ;
    ld (l0173h),a     ; ; ; ; ; ;1d6f   (l0173h)=chr
l1d72h:      ;<-------+ ; ; ; ;
    ld a,c              ; ; ; ; ;1d72   Restore chr
    call GetType        ; ; ; ; ;1d73   Get value type variables
    ld (TypeID),a       ; ; ; ; ;1d76   Save value type variable
    ld a,3              ; ; ; ; ;1d79
    ld (KindID),a       ; ; ; ; ;1d7b   (KindID)=3 (Variable)
    ld b,-7             ; ; ; ; ;1d7e   b = -7
    ld hl,l01d9h        ; ; ; ; ;1d80   21 d9 01
    ld a,c              ; ; ; ; ;1d83   Restore chr
l1d84h:         ;<---;  ; ; ; ;
      inc b          ;  ; ; ; ; ;1d84   b=b+1
      jp z,err117    ;  ; ; ; ; ;1d85   if b.eq.0 --> Error (117) Identifier Too Long
      ld (hl),a      ;  ; ; ; ; ;1d88   (hl)=chr
      dec hl         ;  ; ; ; ; ;1d89   hl=hl-1
      push hl        ;  ; ; ; ; ;1d8a \
      push bc        ;  ; ; ; ; ;1d8b \
      call g_n_chr   ;  ; ; ; ; ;1d8c   Get next character
      pop bc         ;  ; ; ; ; ;1d8f /
      pop hl         ;  ; ; ; ; ;1d90 /
      jp nc,l1d84h ;-;  ; ; ; ; ;1d91   if chr Letter or Digit --> ...
      cp '$'         ;  ; ; ; ; ;1d94
    jp z,l1d84h ;----+  ; ; ; ; ;1d96   if chr.eq.'$' --> ...
    ld a,7              ; ; ; ; ;1d99
    add a,b             ; ; ; ; ;1d9b
    ld (SizeID),a       ; ; ; ; ;1d9c   (SizeID)=b+7
l1d9fh:                 ; ; ; ;
    call s_5709h        ; ; ; ; ;1d9f   cd 09 57
l1da2h:                 ; ; ; ;
    ld a,(KindID)       ; ; ; ; ;1da2
    dec a               ; ; ; ; ;1da5
    jp nz,l1ddfh ;----; ; ; ; ; ;1da6   if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)     ; ; ; ; ; ;1da9
    or a              ; ; ; ; ; ;1dac
    jp nz,l1ddfh ;----; ; ; ; ; ;1dad   if (TypeID).ne.0 (INTEGER)  --> ...
    ld hl,(l01d8h)    ; ; ; ; ; ;1db0
    ld a,h            ; ; ; ; ; ;1db3
    or l              ; ; ; ; ; ;1db4
    jp z,l1dd1h ;---; ; ; ; ; ; ;1db5   if (l01d8h).eq.0 --> ...
    inc hl          ; ; ; ; ; ; ;1db8
    ld a,h          ; ; ; ; ; ; ;1db9
    or l            ; ; ; ; ; ; ;1dba
    jp nz,l1ddah;-; ; ; ; ; ; ; ;1dbb   if (l01d8h).ne.-1--> ...
    ld hl,(l01d6h); ; ; ; ; ; ; ;1dbe   2a d6 01
    ld a,h        ; ; ; ; ; ; ; ;1dc1   7c
    and 80h       ; ; ; ; ; ; ; ;1dc2   10000000b
    jp z,l1ddah ;-; ; ; ; ; ; ; ;1dc4   ca da 1d
    ld a,h        ; ; ; ; ; ; ; ;1dc7   7c
    and 7fh       ; ; ; ; ; ; ; ;1dc8   01111111b
    or l          ; ; ; ; ; ; ; ;1dca   b5  .
    jp z,l1ddah ;-; ; ; ; ; ; ; ;1dcb   ca da 1d
    jp l1ddfh ;---)-)-; ; ; ; ; ;1dce   c3 df 1d
l1dd1h:    ;<-----)-+ ; ; ; ; ;
    ld hl,(l01d6h);   ; ; ; ; ; ;1dd1   2a d6 01
    ld a,h        ;   ; ; ; ; ; ;1dd4   7c
    and 80h       ;   ; ; ; ; ; ;1dd5   10000000b
    jp z,l1ddfh ;-)---; ; ; ; ; ;1dd7   ca df 1d
l1ddah:    ;<-----+   ; ; ; ; ;
    ld a,4            ; ; ; ; ; ;1dda
    ld (TypeID),a     ; ; ; ; ; ;1ddc   (TypeID)=4 (INTEGER*4)
l1ddfh:         ;<----+ ; ; ; ;
    ld a,(KindID)       ; ; ; ; ;1ddf   a=(KindID)
    ret                 ; ; ; ; ;1de2
                        ; ; ; ;
err117:                 ; ; ; ;
    call err.msg        ; ; ; ; ;1de3   Error (117)
    db 117              ; ; ; ; ;1de6   Identifier Too Long
                        ; ; ; ;
l1de7h:    ;<-----------+ ; ; ;
    ld (l0278h),a         ; ; ; ;1de7   (l0278h)=chr
    jp l1cd0h             ; ; ; ;1dea   --> ...
                          ; ; ;
l1dedh:   ;<--------------+ ; ;
    ld a,(l0278h)           ; ; ;1ded
    ld (l0299h),a           ; ; ;1df0   (l0299h)=(l0278h)
    ld (l0173h),a           ; ; ;1df3   (l0173h)=(l0278h)
    jp l1d9fh               ; ; ;1df6   --> ...
                            ; ;
l1df9h:                     ; ;
    ld hl,KindID            ; ; ;1df9
    ld (hl),1               ; ; ;1dfc   (KindID)=1 (Constant)
    ld a,(l01d9h)           ; ; ;1dfe
    and 0f0h                ; ; ;1e01   11110000b
    jp nz,l1cd4h  ;---------; ; ;1e03   if ((l01d9h).and.11110000b).ne.0 --> ...
    ld hl,l027ah            ; ; ;1e06
    inc (hl)                ; ; ;1e09   (l027ah)=(l027ah)+1
    call s_20bch            ; ; ;1e0a   cd bc 20
    xor a                   ; ; ;1e0d   a=0
    call s_0953h            ; ; ;1e0e   Initialization field l01dah 8-byte character null
    ld a,(l0299h)           ; ; ;1e11
    sub '0'                 ; ; ;1e14   Make binary from ASCII
    ld (l01dah),a           ; ; ;1e16   (l01dah)=(l0299h)-'0'
    call s_209ah            ; ; ;1e19   cd 9a 20
    jp nc,l1cd4h  ;---------; ; ;1e1c   if --> ...
    call s_208bh            ; ; ;1e1f   cd 8b 20  
    ld a,080h               ; ; ;1e22
    ld (l01d9h),a           ; ; ;1e24   (l01d9h)=080h
    jp l1cd4h     ;---------+ ; ;1e27   --> ...
                              ;
l1e2ah:     ;<----------------+
    ld a,b                      ;1e2a   78
    rla                         ;1e2b   17
    jp c,l1fbbh   ;-----;       ;1e2c   da bb 1f
l1e2fh:                 ;
    ld a,(l0299h)       ;   ;1e2f
    cp 'E'              ;   ;1e32
    jp z,l1e59h ;-----; ;   ;1e34   if (l0299h).eq.'E' --> ...
    cp 'D'            ; ;   ;1e37
    jp z,l1e4fh ;-;   ; ;   ;1e39   if (l0298h).eq.'D' --> ...
    ld a,0ffh     ;   ; ;   ;1e3c
    ld (l0243h),a ;   ; ;   ;1e3e   (l0243h)=0ffh
    jp l1e90h ;---)-; ; ;   ;1e41   --> ...
                  ; ; ; ;
l1e44h:           ; ; ; ;
    ld a,(l01d1h) ; ; ; ;   ;1e44
    or a          ; ; ; ;   ;1e47
    jp nz,l64fdh  ; ; ; ;   ;1e48   if (l01d1h).ne.0 --> Search statement
    call err.msg  ; ; ; ;   ;1e4b   Error (104)
    db 104        ; ; ; ;   ;1e4e   Illegal Data Constant
                  ; ; ; ;
l1e4fh:  ;<-------+ ; ; ;
    ld a,3          ; ; ;   ;1e4f
    ld (TypeID),a   ; ; ;   ;1e51   (TypeID)=3 (DOUBLE)
    ld a,8          ; ; ;   ;1e54
    ld (SizeID),a   ; ; ;   ;1e56   (SizeID)=8 
l1e59h:      ;<-----)-+ ;
    call g_n_chr    ;   ;   ;1e59   Get next character
    jp m,l1f92h     ;   ;   ;1e5c   if chr Digit --> ...
    cp '-'          ;   ;   ;1e5f
    jp z,l1f88h ;---)-; ;   ;1e61   if chr.eq.'-' --> ...
    cp '+'          ; ; ;   ;1e64
    jp z,l1f8ch     ; ; ;   ;1e66   if chr.eq.'+' --> ...
    ld a,(TypeID)   ; ; ;   ;1e69
    cp 3            ; ; ;   ;1e6c
    jp z,l1e44h     ; ; ;   ;1e6e   if (TypeID).eq.3 (DOUBLE) --> ...
    ld (l0173h),a   ; ; ;   ;1e71   (l0173h)=(TypeID)
    ld a,(l0243h)   ; ; ;   ;1e74
    or a            ; ; ;   ;1e77
    jp z,l1e44h     ; ; ;   ;1e78   if (l0243h).eq.0 --> ...
    call g_n_chr    ; ; ;   ;1e7b   Get next character
    cp 'Q'          ; ; ;   ;1e7e
    jp nz,l1e44h    ; ; ;   ;1e80   if chr.ne.'Q' --> ...
    call g_n_chr    ; ; ;   ;1e83   Get next character
    cp '.'          ; ; ;   ;1e86
    jp nz,l1e44h    ; ; ;   ;1e88   if chr.ne.'.' --> ...
    ld a,9          ; ; ;   ;1e8b
    ld (l01b4h),a   ; ; ;   ;1e8d   (l01b4h)=9
l1e90h:       ;<----+ ; ;
    xor a             ; ;   ;1e90
    ld (TypeID),a     ; ;   ;1e91   (TypeID)=0 (INTEGER)
    ld a,4            ; ;   ;1e94
    ld (SizeID),a     ; ;   ;1e96   (SizeID)=4
    ld hl,(l01d8h)    ; ;   ;1e99
    ld a,h            ; ;   ;1e9c
    or l              ; ;   ;1e9d
    ld hl,(l01d6h)    ; ;   ;1e9e
    or h              ; ;   ;1ea1
    or l              ; ;   ;1ea2
    jp nz,l1e44h      ; ;   ;1ea3   if (l01d8h).ne.0.or.(l01d6h).ne.0.or.(l01d5h).ne.0 --> ...
    ld hl,(l01d4h)    ; ;   ;1ea6
    ld a,h            ; ;   ;1ea9
    or a              ; ;   ;1eaa
    jp m,l1e44h       ; ;   ;1eab   if (l01d4h) < 0 --> ...
    ld (l01d8h),hl    ; ;   ;1eae   (l01d8h)=(l01d4h)
    ld hl,(l01d2h)    ; ;   ;1eb1
    ld (l01d6h),hl    ; ;   ;1eb4   (l01d6h)=(l01d2h)
    ld a,(l0278h)     ; ;   ;1eb7
    cp '-'            ; ;   ;1eba
    ld hl,l01d6h      ; ;   ;1ebc   hl=l01d6h
    call z,s_20fbh    ; ;   ;1ebf   if (l0278h).eq.'-' Negate integer*4 ^hl=-^hl
l1ec2h:               ; ;
    ld a,(l0243h)     ; ;   ;1ec2
    or a              ; ;   ;1ec5
    jp z,l1d9fh       ; ;   ;1ec6   if (l0243h).eq.0 --> ...
    jp p,l1da2h       ; ;   ;1ec9   if (l0242h).>.0  --> ...
    ld (l0173h),a     ; ;   ;1ecc   (l0173h)=(l0243h)
l1ecfh:         ;<--; ; ;
    call s_573ch    ; ; ;   ;1ecf   Parsing Logical operation
    jp l1da2h       ; ; ;   ;1ed2   --> ...
                    ; ; ;
l1ed5h:             ; ; ;
    call g_n_chr    ; ; ;   ;1ed5   Get next character
    jp m,l1df9h     ; ; ;   ;1ed8   if chr Digit --> ...
    jp c,l1fbbh ;---)-)-;   ;1edb   if chr Special character --> ...
    ld a,12h        ; ; ;   ;1ede
    ld (l0243h),a   ; ; ;   ;1ee0   (l0243h)=12h
    ld a,(KindID)   ; ; ;   ;1ee3
    or a            ; ; ;   ;1ee6
    jp nz,l1e2fh    ; ; ;   ;1ee7   if (KindID).ne.0 --> ...
    inc a           ; ; ;   ;1eea
    ld (l0173h),a   ; ; ;   ;1eeb   (l0173h)=1
    ld a,(l0299h)   ; ; ;   ;1eee
    cp 'N'          ; ; ;   ;1ef1
    jp z,l1ecfh ;---+ ; ;   ;1ef3   if (l0299h).eq.'N' --> ...
    ld a,5            ; ;   ;1ef6   a=5
    call GetStr       ; ;   ;1ef8   Reading string length A characters
    ld hl,l01ddh      ; ;   ;1efb   21 dd 01
    ld de,l02cah      ; ;   ;1efe   de="FALSE"
    ld b,5            ; ;   ;1f01   b=5
    call cmpstr       ; ;   ;1f03   Compare strings ^HL:^DE with length in B
    jp z,l1f38h  ;--; ; ;   ;1f06   cif strings eq --> ...
    ld hl,l01ddh    ; ; ;   ;1f09   21 dd 01
    ld de,l02cfh    ; ; ;   ;1f0c   hl="TRUE."
    ld b,5          ; ; ;   ;1f0f   b=5
    call cmpstr     ; ; ;   ;1f11   Compare strings ^HL:^DE with length in B
    jp nz,l1e44h    ; ; ;   ;1f14   if strings ne --> ...
                    ; ; ;
;   found "TRUE."   ; ; ;
                    ; ; ;
    ld a,0ffh       ; ; ;   ;1f17
    ld (l01d8h),a   ; ; ;   ;1f19   (l01d8h)=0ffh
    ld (l01d9h),a   ; ; ;   ;1f1c   (l01d9h)=0ffh
    ld (l01d6h),a   ; ; ;   ;1f1f   (l01d6h)=0ffh
    ld (l01d7h),a   ; ; ;   ;1f22   (l01d7h)=0ffh
l1f25h:     ;<----; ; ; ;
    ld a,2        ; ; ; ;   ;1f25
    ld (SizeID),a ; ; ; ;   ;1f27   (SizeID)=2
    dec a         ; ; ; ;   ;1f2a
    ld (KindID),a ; ; ; ;   ;1f2b   (KindID)=1 (Constant)
    inc a         ; ; ; ;   ;1f2e
    ld (TypeID),a ; ; ; ;   ;1f2f   (TypeID)=2 (BYTE)
    call g_n_chr  ; ; ; ;   ;1f32   Get next character
    jp l1d9fh     ; ; ; ;   ;1f35   --> ...
                  ; ; ; ;
;   found "FALSE" ; ; ; ;
                  ; ; ; ;
l1f38h:     ;<----)-+ ; ;
    call g_n_chr  ;   ; ;   ;1f38   Get next character
    cp '.'        ;   ; ;   ;1f3b
    jp z,l1f25h ;-+   ; ;   ;1f3d   if chr.eq.'.' --> ...
    jp l1e44h         ; ;   ;1f40   --> ...
                      ; ;
l1f43h:               ; ;
    ld a,b            ; ;   ;1f43   78
    rla               ; ;   ;1f44   17
    jp c,l1e90h       ; ;   ;1f45   if --> ...
    ld a,c            ; ;   ;1f48   Restore chr
    sub 'H'           ; ;   ;1f49
    jp nz,l1e2fh      ; ;   ;1f4b   if chr.ne.48h --> ...
    ld (TypeID),a     ; ;   ;1f4e   Save value type variable
    ld a,4            ; ;   ;1f51
    ld (SizeID),a     ; ;   ;1f53   (SizeID)=4
    ld a,1            ; ;   ;1f56
    ld (l01ceh),a     ; ;   ;1f58   (l01ceh)=1
    ld hl,(l01d8h)    ; ;   ;1f5b
    ld a,h            ; ;   ;1f5e
    or l              ; ;   ;1f5f
    ld hl,(l01d6h)    ; ;   ;1f60
    or h              ; ;   ;1f63
    or l              ; ;   ;1f64
    jp nz,l1e44h      ; ;   ;1f65   if (l01d8h).ne.0.or.(l01d6h).ne.0.or.(l01d5h).ne.0 --> ...
    ld hl,(l01d4h)    ; ;   ;1f68
    ld a,h            ; ;   ;1f6b
    or a              ; ;   ;1f6c
    jp nz,l1e44h      ; ;   ;1f6d   if (l01d4h).ne.0 --> ...
    ld (l01d8h),hl    ; ;   ;1f70   (l01d8h)=(l01d4h)
    ld hl,(l01d2h)    ; ;   ;1f73
    ld (l01d6h),hl    ; ;   ;1f76   (l01d6h)=(l01d2h)
    ld a,(l0278h)     ; ;   ;1f79
    cp '-'            ; ;   ;1f7c
    jp nz,l1da2h      ; ;   ;1f7e   if (l0278h).ne.02dh --> ...
    call err.msg      ; ;   ;1f81   Error (109)
    db 109            ; ;   ;1f84   Incorrect Integer Constant
    jp l1da2h         ; ;   ;1f85   --> ...
                      ; ;
l1f88h:     ;<--------+ ;
    ld hl,l0279h        ;   ;1f88
    inc (hl)            ;   ;1f8b   (l0279h)=(l0279h)+1
l1f8ch:                 ;
    call g_n_chr        ;   ;1f8c   Get next character
    jp p,l1e44h         ;   ;1f8f   if Special character or Letter --> ...
l1f92h:   ;<------;     ;
    ld hl,l027bh  ;     ;   ;1f92
    ld a,(hl)     ;     ;   ;1f95
    add a,a       ;     ;   ;1f96                               *2
    add a,a       ;     ;   ;1f97                               *4
    jp c,l1e44h   ;     ;   ;1f98   if (l027bh)*4 < 0  --> ...
    add a,(hl)    ;     ;   ;1f9b                               *5
    jp c,l1e44h   ;     ;   ;1f9c   if (l027bh)*5 < 0  --> ...
    rla           ;     ;   ;1f9f                              *10
    jp c,l1e44h   ;     ;   ;1fa0   if (l027bh)*10 < 0  --> ...
    ld (hl),a     ;     ;   ;1fa3   (l027bh)=(l027bh)*10
    ld a,(l0299h) ;     ;   ;1fa4   a=(l0299h)
    sub '0'       ;     ;   ;1fa7   Make binary from ASCII
    add a,(hl)    ;     ;   ;1fa9
    jp c,l1e44h   ;     ;   ;1faa   if (l0299h)-'0'+(l027bh) < 0 --> ...
    jp m,l1e44h   ;     ;   ;1fad   if (l0299h)-'0'+(l027bh) < 0 --> ...
    ld (hl),a     ;     ;   ;1fb0   (l027bh)=(l0299h)-'0'+(l027bh)
    call g_n_chr  ;     ;   ;1fb1   Get next character
    jp m,l1f92h ;-+     ;   ;1fb4   if chr Digit --> ...
    ld a,(l0279h)       ;   ;1fb7
    or a                ;   ;1fba
l1fbbh:     ;<----------+
    ld hl,l027bh            ;1fbb
    ld a,(hl)               ;1fbe   a=(l027bh)
    jp z,l1fc4h  ;--;       ;1fbf   if (l0279h).eq.0 --> ...
    cpl             ;       ;1fc2   2f
    inc a           ;       ;1fc3   a=a+1
l1fc4h:         ;<--+
    ex de,hl                ;1fc4   de=l027bh
    ld hl,l027ah            ;1fc5
    sub (hl)                ;1fc8   (l027ah)=(l027fh)-1
    ld (de),a               ;1fc9   (l027bh)=a
    xor a                   ;1fca
    ld (l0243h),a           ;1fcb   (l0243h)=0
    xor a                   ;1fce   a=0
    ld hl,l01d2h            ;1fcf   hl=l01d2h 
    ld b,8                  ;1fd2   b=8
l1fd4h:        ;<---;
      or (hl)       ;       ;1fd4   a=a.or.(hl)
      inc hl        ;       ;1fd5   hl=hl+1
      dec b         ;       ;1fd6   b=b-1
    jp nz,l1fd4h ;--+       ;1fd7   if b.ne.0 --> ...
    or a                    ;1fda
    jp z,l1d9fh             ;1fdb   if a.eq.0 --> ...
    ld a,0c0h               ;1fde
    ld (l027ah),a           ;1fe0   (l027ah)=0c0h
l1fe3h:      ;<------;
    ld a,(l01d9h)    ;      ;1fe3
    or a             ;      ;1fe6
    jp m,l1ff7h ;--; ;      ;1fe7   if (l01d9h) < 0 --> ...
    ld hl,l027ah   ; ;      ;1fea
    dec (hl)       ; ;      ;1fed   (l027ah)=(l027ah)-1
    jp z,l2085h ;--)-)---;  ;1fee   if (l027fh).eq.0 --> ...
    call s_20adh   ; ;   ;  ;1ff1   cd ad 20
    jp l1fe3h  ;---)-;   ;  ;1ff4   --> ...
                   ; ;   ;
l1ff7h:     ;<-----+ ;   ;
    ld hl,l027bh     ;   ;  ;1ff7
    ld a,(hl)        ;   ;  ;1ffa
    or a             ;   ;  ;1ffb
    jp z,l2049h ;----)-; ;  ;1ffc   if (l027bh).eq.0 --> ...
    jp m,l201fh ;--; ; ; ;  ;1fff   if (l027bh) < 0 --> ...
    dec (hl)       ; ; ; ;  ;2002   (l027bh)=(l027bh)-1
    call s_208bh   ; ; ; ;  ;2003   cd 8b 20    . .   
    call s_56e1h   ; ; ; ;  ;2006   Move 8 bytes from ^l01d2h to ^l01dah
    call s_208bh   ; ; ; ;  ;2009   cd 8b 20  
    call s_208bh   ; ; ; ;  ;200c   cd 8b 20
    call s_209ah   ; ; ; ;  ;200f   cd 9a 20 
    ld hl,l027ah   ; ; ; ;  ;2012
    ld a,4         ; ; ; ;  ;2015
    add a,(hl)     ; ; ; ;  ;2017
    ld (hl),a      ; ; ; ;  ;2018   (l027ah)=(l027ah)+4
    jp nc,l1fe3h ;-)-; ; ;  ;2019   if (l027ah)+4 >= 0  --> ...
    jp l1e44h      ; ; ; ;  ;201c   --> ...
                   ; ; ; ;
l201fh:     ;<-----+ ; ; ;
    inc (hl)         ; ; ;  ;201f   (l027bh)=(l027bh)+1
    call s_208bh     ; ; ;  ;2020   cd 8b 20 
    call s_56e1h     ; ; ;  ;2023   Move 8 bytes from ^l01d2h to ^l01dah
    call s_208bh     ; ; ;  ;2026   cd 8b 20
    call s_209ah     ; ; ;  ;2029   cd 9a 20
    call s_56e1h     ; ; ;  ;202c   Move 8 bytes from ^l01d2h to ^l01dah
    ld a,15          ; ; ;  ;202f   a=15
l2031h:      ;<----; ; ; ;
      push af      ; ; ; ;  ;2031 \
      call s_20cbh ; ; ; ;  ;2032   cd cb 20 
      call s_209ah ; ; ; ;  ;2035   cd 9a 20 
      pop af       ; ; ; ;  ;2038 /
      dec a        ; ; ; ;  ;2039   a=a-1
    jp nz,l2031h ;-+ ; ; ;  ;203a   if a.ne.0 --> ...
    call s_208bh     ; ; ;  ;203d   cd 8b 20 
    call s_208bh     ; ; ;  ;2040   cd 8b 20
    call s_208bh     ; ; ;  ;2043   cd 8b 20  
    jp l1fe3h   ;----+ ; ;  ;2046   --> ...
                       ; ;
l2049h:     ;<---------+ ;
    xor a                ;  ;2049   a=0
    call s_0953h         ;  ;204a   Initialization field l01dah 8-byte character null
    ld a,080h            ;  ;204d
    ld (l01dah),a        ;  ;204f   (l01dah)=80h
    call s_209ah         ;  ;2052   cd 9a 20
    jp nc,l2064h ;--;    ;  ;2055   d2 64 20 
    ld a,080h       ;    ;  ;2058
    ld (l01d9h),a   ;    ;  ;205a   (l01d9h)=80h
    ld hl,l027ah    ;    ;  ;205d
    inc (hl)        ;    ;  ;2060   (l027ah)=(l027ah)+1
    jp z,l1e44h     ;    ;  ;2061   if (l027ah).eq.0 --> ...
l2064h:     ;<------+    ;
    ld hl,l01d3h         ;  ;2064   21 d3 01
    ld de,l01d2h         ;  ;2067   Destination address
    ld b,6               ;  ;206a   b=6
    call l0863h          ;  ;206c   Move B bytes from ^HL to ^DE
    ld a,(l0278h)        ;  ;206f   3a 78 02
    cp 02dh              ;  ;2072   fe 2d  '-'
    ccf                  ;  ;2074   3f
    ld a,(l01d9h)        ;  ;2075   a=(l01d9h)
    rla                  ;  ;2078   17
    rrca                 ;  ;2079   0f
    ld l,a               ;  ;207a   6f
    ld a,(l027ah)        ;  ;207b   3a 7a 02
    ld h,a               ;  ;207e   67
    ld (l01d8h),hl       ;  ;207f   (l01d8h)=
    jp l1ec2h            ;  ;2082   --> ...
                         ;
l2085h:         ;<-------+
    call s_0941h            ;2085   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
    jp l1ec2h               ;2088   --> ...
;*
;*
;*
s_208bh:
    ld b,8              ;208b   b=8
    ld hl,l01d9h        ;208d   21 d9 01
    or a                ;2090   reset Carry
l2091h:         ;<--;
      ld a,(hl)     ;   ;2091   7e 
      rra           ;   ;2092   1f
      ld (hl),a     ;   ;2093   77
      dec hl        ;   ;2094   hl=hl-1
      dec b         ;   ;2095   b=b-1
    jp nz,l2091h ;--+   ;2096   if b.ne.0 --> ... 
    ret                 ;2099
;*
;*
;*
s_209ah:
    ld de,l01dah        ;209a   11 da 01
    ld hl,l01d2h        ;209d   21 d2 01
    ld b,8              ;20a0   b=8
    xor a               ;20a2   a=0
l20a3h:         ;<--;
      ld a,(de)     ;   ;20a3
      adc a,(hl)    ;   ;20a4
      ld (hl),a     ;   ;20a5   (hl)=(de)+(hl)+Carry
      inc hl        ;   ;20a6   hl=hl+1
      inc de        ;   ;20a7   de=de+1
      dec b         ;   ;20a8   b=b-1
    jp nz,l20a3h ;--+   ;20a9   if b.ne.0 --> ...
    ret                 ;20ac
;*
;*
;*
s_20adh:
    ld b,8              ;20ad   b=8
    ld hl,l01d2h        ;20af   21 d2 01
    xor a               ;20b2   a=0
l20b3h:         ;<--;
      ld a,(hl)     ;   ;20b3   7e
      rla           ;   ;20b4   17
      ld (hl),a     ;   ;20b5   77
      inc hl        ;   ;20b6   hl=hl+1
      dec b         ;   ;20b7   b=b-1
    jp nz,l20b3h ;--+   ;20b8   if b.ne.0 --> ...  
    ret                 ;20bb
;*
;*
;*
s_20bch:
    call s_56e1h        ;20bc   Move 8 bytes from ^l01d2h to ^l01dah
    call s_20adh        ;20bf   cd ad 20
    call s_20adh        ;20c2   cd ad 20 
    call s_209ah        ;20c5   cd 9a 20
    jp s_20adh          ;20c8   --> ...
;*
;*
;*
s_20cbh:
    ld c,4              ;20cb   c=4
l20cdh:         ;<----;
      ld b,8          ; ;20cd   b=8
      ld hl,l01e1h    ; ;20cf   21 e1 01
      or a            ; ;20d2   reset Carry
l20d3h:          ;<-; ;
        ld a,(hl)   ; ; ;20d3   7e 
        rra         ; ; ;20d4   1f
        ld (hl),a   ; ; ;20d5   77
        dec hl      ; ; ;20d6   hl=hl-1
        dec b       ; ; ;20d7   b=b-1
      jp nz,l20d3h;-+ ; ;20d8   if b.ne.0 --> ... 
      dec c           ; ;20db   c=c-1
    jp nz,l20cdh ;----+ ;20dc   if c.ne.0 --> ... 
    ret                 ;20df
;*
;*  Addition integer*4 ^hl=^de+^hl
;*  ENTRY:
;*    hl points to Num1 (stored little-endian)
;*    de points to Num2 (stored little-endian)
;*
s_20e0h:
    ld b,4              ;20e0   b=4
    or a                ;20e2   reset Carry
l20e3h:         ;<--;
      ld a,(de)     ;   ;20e3
      adc a,(hl)    ;   ;20e4
      ld (hl),a     ;   ;20e5   (hl)=(de)+(hl)+Carry 
      inc hl        ;   ;20e6   hl=hl+1
      inc de        ;   ;20e7   de=de+1
      dec b         ;   ;20e8   b=b-1
    jp nz,l20e3h ;--+   ;20e9   if b.ne.0 --> ...  
    ret                 ;20ec
;*
;*  Subtraction integer*4 ^de=^hl-^de
;*  ENTRY:
;*    hl points to Num1 (stored little-endian)
;*    de points to Num2 (stored little-endian)
;*
s_20edh:
    ld b,4              ;20ed   b=4
    or a                ;20ef   reset Carry
    ex de,hl            ;20f0   eb
l20f1h:         ;<--;
      ld a,(de)     ;   ;20f1
      sbc a,(hl)    ;   ;20f2
      ld (de),a     ;   ;20f3   (de)=(de)-(hl)-Carry
      inc hl        ;   ;20f4   hl=hl+1
      inc de        ;   ;20f5   de=de+1
      dec b         ;   ;20f6   b=b-1
    jp nz,l20f1h ;--+   ;20f7   if b.ne.0 --> ... 
    ret                 ;20fa
;*
;*  Negate integer*4 ^hl=-^hl
;*  ENTRY:
;*    hl points to Num (stored little-endian)
;*
s_20fbh:
    ld b,4              ;20fb   b=4
    or a                ;20fd   reset Carry
l20feh:         ;<--;
      ld a,0        ;   ;20fe   a=0
      sbc a,(hl)    ;   ;2100   a=a-(hl)-Carry
      ld (hl),a     ;   ;2101   (hl)=a
      inc hl        ;   ;2102   hl=hl+1
      dec b         ;   ;2103   b=b-1
    jp nz,l20feh ;--+   ;2104   if b.ne.0 --> ...  
    ret                 ;2107
;*
;*  Multiplication integer*4 ^hl=^de+^hl
;*    ENTRY:
;*      hl - points to Num1
;*      de - points to Num2
;*
s_2108h:
    push hl                 ;2108 \ Save points to Num1
    ld hl,00000h            ;2109
    ld (l015fh),hl          ;210c   (l015fh)=0
    ld (l0161h),hl          ;210f   (l0161h)=0
    pop hl                  ;2112 / Restore points to Num1
    ld b,020h               ;2113   b=32
l2115h:            ;<--;
      call s_2133h     ;    ;2115   cd 33 21
      call s_213ch     ;    ;2118   cd 3c 21
      jp nc,l2121h ;-; ;    ;211b   d2 21 21
      call s_214ch   ; ;    ;211e   cd 4c 21
l2121h:         ;<---+ ;
      dec b            ;    ;2121   b=b-1
    jp nz,l2115h  ;----+    ;2122   if b.ne.0 --> ...
    push de                 ;2125
    push hl                 ;2126
    ex de,hl                ;2127   eb
    ld hl,l015fh            ;2128   hl=l015fh
    ld b,4                  ;212b   b=4
    call l0863h             ;212d   Move B bytes from ^HL to ^DE
    pop hl                  ;2130
    pop de                  ;2131
    ret                     ;2132
;*
;*
;*
s_2133h:
    push hl                 ;2133
    ld hl,l015fh            ;2134   hl=l015fh
    call s_213ch            ;2137   cd 3c 21
    pop hl                  ;213a
    ret                     ;213b
;*
;*
;*
s_213ch:
    or a                ;213c   reset Carry
s_213dh:
    push hl             ;213d
    push bc             ;213e
    ld b,4              ;213f   b=4
l2141h:         ;<--;
      ld a,(hl)     ;   ;2141   7e
      rla           ;   ;2142   17
      ld (hl),a     ;   ;2143   77
      inc hl        ;   ;2144   hl=hl+1
      dec b         ;   ;2145   b=b-1
    jp nz,l2141h ;--+   ;2146   if b.ne.0 --> ...
    pop bc              ;2149
    pop hl              ;214a
    ret                 ;214b
;*
;*  ^l015fh=^de+^l015fh
;*
s_214ch:
    push hl             ;214c
    push de             ;214d
    push bc             ;214e
    ld hl,l015fh        ;214f   hl=l015fh 
    call s_20e0h        ;2152   Addition integer*4 ^hl=^de+^hl
    pop bc              ;2155
    pop de              ;2156
    pop hl              ;2157
    ret                 ;2158
;*
;*  Division integer*4 ^hl=^de+^hl
;*    ENTRY:
;*      hl - points to Num1
;*      de - points to Num2
s_2159h:
    push hl             ;2159 \ Save points to Num1
    ld hl,00000h        ;215a
    ld (l015fh),hl      ;215d   (l015fh)=0
    ld (l0161h),hl      ;2160   (l0161h)=0
    pop hl              ;2163 / Restore points to Num1
    ld b,021h           ;2164   b=33
    or a                ;2166   Clears carry flag
    jp l218dh   ;---;   ;2167   --> ...
                    ;
l216ah:     ;<------)-;
    push hl         ; ; ;216a \ e5
    ld hl,(l015fh)  ; ; ;216b   hl=(l015fh)
    ex (sp),hl      ; ; ;216e   e3
    push hl         ; ; ;216f \ e5
    ld hl,(l0161h)  ; ; ;2170   hl=(l0161h)
    ex (sp),hl      ; ; ;2173   e3
    call s_2198h    ; ; ;2174   cd 98 21
    jp c,l2182h ;-; ; ; ;2177   da 82 21
    ex (sp),hl    ; ; ; ;217a   e3 
    pop hl        ; ; ; ;217b / e1
    ex (sp),hl    ; ; ; ;217c   e3
    pop hl        ; ; ; ;217d / e1
    scf           ; ; ; ;217e   Set carry
    jp l218dh ;---)-; ; ;217f   --> ...
                  ; ; ;
l2182h:    ;<-----+ ; ;
    ex (sp),hl      ; ; ;2182   e3
    ld (l0161h),hl  ; ; ;2183   (l0161h)=
    pop hl          ; ; ;2186 / e1
    ex (sp),hl      ; ; ;2187   e3
    ld (l015fh),hl  ; ; ;2188   (l015fh)=
    pop hl          ; ; ;218b / e1
    or a            ; ; ;218c   Clears carry flag
l218dh:         ;<--+ ;
    call s_213dh      ; ;218d   cd 3d 21
    call s_21a5h      ; ;2190   cd a5 21
    dec b             ; ;2193   b=b-1
    jp nz,l216ah  ;---+ ;2194   if b.ne.0 --> ...
    ret                 ;2197
;*
;*
;*
s_2198h:
    push hl             ;2198
    push de             ;2199
    push bc             ;219a
    ld hl,l015fh        ;219b   hl=l015fh
    call s_20edh        ;219e   Subtraction integer*4 ^de=^hl-^de 
    pop bc              ;21a1
    pop de              ;21a2
    pop hl              ;21a3
    ret                 ;21a4
;*
;*
;*
s_21a5h:
    push hl             ;21a5
    ld hl,l015fh        ;21a6   hl=l015fh
    call s_213dh        ;21a9   cd 3d 21
    pop hl              ;21ac
    ret                 ;21ad
;*
;*  Processing label & Test (TypeID).eq.INTEGER
;*
s_21aeh:
    call PrLabel        ;21ae   Processing label
    ld a,(TypeID)       ;21b1
    or a                ;21b4
    ret z               ;21b5   if (TypeID).eq.0 (INTEGER) Return
    call err.msg        ;21b6   Warning (20)
    db 20               ;21b9   Invalid Statement Number Usage
    ret                 ;21ba
;*
;*  Check that the name refers to a variables
;*
ChkVar:
    call PrName         ;21bb   Processing name
    cp 5                ;21be
    jp nc,err111 ;--;   ;21c0   if (KindID) >= 5 (Routine) --> Not a Variable Name
    ld a,(ScopeID)  ;   ;21c3
    cp 3            ;   ;21c6
    ret nz          ;   ;21c8   if (ScopeID).ne.3 Return
err111:       ;<----+
    call err.msg        ;21c9   Error (111)
    db 111              ;21cc   Not a Variable Name
;*
;*  Processing READ(, WRITE(
;*      READ (LUN, Label, ERR=L1, END=L2) k - Formatted statement
;*      READ (LUN, ERR=L1, END=L2) k        - Unformatted statement
;*
PrRead:
    call s_259eh            ;21cd   Processing integer constant (LUN)
l21d0h:
    xor a                   ;21d0
    ld (NumIO),a            ;21d1   (NumIO)=0 Clear Number of parameters statement READ or WRITE
    ld (l0287h),a           ;21d4   (l0287h)=0
    call s_3fa9h            ;21d7   cd a9 3f    
    ld hl,(l02b1h)          ;21da
    ld (l0285h),hl          ;21dd   (l0285h)=(l02b1h)
    ld (l0283h),hl          ;21e0   (l0283h)=(l02b1h)
    ld (l024fh),hl          ;21e3   (l024fh)=(l02b1h)
    ld (l01cfh),hl          ;21e6   (l01cfh)=(l02b1h)
    ld hl,00000h            ;21e9   hl=0
    ld a,(l0299h)           ;21ec
    cp ','                  ;21ef
    jp nz,l222ch ;----;     ;21f1   if (l0299h).ne.',' --> ...
    call s_14dbh      ;     ;21f4   g_n_chr; (l0173h)=chr
    jp p,l2203h ;-;   ;     ;21f7   if Special character or Letter --> ...
    call PrLabel  ;   ;     ;21fa   Processing label
    call s_0e2eh  ;   ;     ;21fd   cd 2e 0e
    jp l2229h ;---)-; ;     ;2200   --> ...
                  ; ; ;
l2203h:       ;<--+ ; ;
    call s_1cbbh    ; ;     ;2203   cd bb 1c
    ld a,(l0299h)   ; ;     ;2206
    cp '='          ; ;     ;2209
    jp nz,l221eh;-; ; ;     ;220b   if (l0299h).ne.'=' --> ...
    ld (l01d6h),a ; ; ;     ;220e   32 d6 01
    call s_56e1h  ; ; ;     ;2211   Move 8 bytes from ^l01d2h to ^l01dah
    xor a         ; ; ;     ;2214   a=0
    ld h,a        ; ; ;     ;2215
    ld l,a        ; ; ;     ;2216   hl=0
    push hl       ; ; ;     ;2217
    call s_3fa9h  ; ; ;     ;2218   cd a9 3f
    jp TstERR  ;--)-)-)-;   ;221b   --> Test parameter "END=", "ERR=" or "REC="
                  ; ; ; ;
l221eh:      ;<---+ ; ; ;
    ld a,(KindID)   ; ; ;   ;221e   3a 0b 02
    call s_1cb2h    ; ; ;   ;2221   cd b2 1c
    cp 4            ; ; ;   ;2224
    jp nz,err128    ; ; ;   ;2226   if (KindID).ne.4 (Array)--> Error (128) Missing Integer Quantity
l2229h:    ;<-------+ ; ;
    ld hl,(l01cfh)    ; ;   ;2229   2a cf 01
l222ch:        ;<-----+ ;
    push hl             ;   ;222c \ e5
    xor a               ;   ;222d   a=0
    call s_3fa9h        ;   ;222e   cd a9 3f
                        ;
ExpPar:          ;<--;  ;           Expected separator (,) & string length 4 characters
    ld a,(l0299h)    ;  ;   ;2231
    cp ','           ;  ;   ;2234   Test separator
    jp nz,l2288h  ;--)--)-; ;2236   if(l0299h).ne.',' (parameters have ended) --> Continue processing operator
    ld a,4           ;  ; ; ;2239   a=4
    call GetStr      ;  ; ; ;223b   Reading string length 4 characters
                     ;  ; ;
TstERR:        ;<----)--+ ;
    ld hl,l02dah     ;    ; ;223e   hl="ERR="
    call CmpSt4      ;    ; ;2241   Compare strings length 4 characters
    jp nz,TstEND ;-; ;    ; ;2244   if not equal --> Test parameter "END="
                   ; ;    ;
;   Foubd "ERR="   ; ;    ;         Processing (ERR=label)
                   ; ;    ;
    ld hl,NumIO    ; ;    ; ;2247
    inc (hl)       ; ;    ; ;224a   (NumIO)=(NumIO)+1
    call PrLabel   ; ;    ; ;224b   Processing label
    ld (l0285h),hl ; ;    ; ;224e   (l0285h)=Address labels corresponding to the parameter "ERR="
    jp ExpPar   ;--)-;    ; ;2251   --> Expected next parameter
                   ; ;    ;
TstEND:        ;<--+ ;    ;
    ld hl,l02deh     ;    ; ;2254   hl="END="
    call CmpSt4      ;    ; ;2257   Compare strings length 4 characters
    jp nz,TstREC ;-; ;    ; ;225a   if not equal --> Test parameter "REC="
                   ; ;    ;
;   Found "END="   ; ;    ;         Processing (END=label)
                   ; ;    ;
    ld hl,NumIO    ; ;    ; ;225d
    inc (hl)       ; ;    ; ;2260   (NumIO)=(NumIO)+1
    call PrLabel   ; ;    ; ;2261   Processing label
    ld (l0283h),hl ; ;    ; ;2264   (l0283h)=Address labels corresponding to the parameter "END="
    jp ExpPar   ;--)-;    ; ;2267   --> Expected next parameter
                   ; ;    ;
TstREC:        ;<--+ ;    ;
    ld hl,l02e2h     ;    ; ;226a   hl="REC="
    call CmpSt4      ;    ; ;226d   Compare strings length 4 characters
    jp nz,err115     ;    ; ;2270   if not equal --> Error (115) Invalid Data List Element in I/O
                     ;    ;
;   Found "REC="     ;    ;         Processing (REC=constant)
                     ;    ;
    ld hl,NumIO      ;    ; ;2273
    inc (hl)         ;    ; ;2276   (NumIO)=(NumIO)+1
    call l25b5h      ;    ; ;2277   Processing integer constant with error checking
    ld (l024fh),hl   ;    ; ;227a   (l024fh)=Address constant corresponding to the parameter "REC="
    jp ExpPar   ;----+    ; ;227d   --> Expected next parameter
;                         ;
;   Compare strings length 4 characters
;                         ;
CmpSt4:                   ;
    ld de,l01deh          ; ;2280   Pointer to source string
    ld b,4                ; ;2283   b=4
    jp cmpstr             ; ;2285   --> Compare strings ^HL:^DE with length in B
                          ;
l2288h:         ;<--------+         Continue processing statement
    ld a,(NumIO)            ;2288
    or a                    ;228b
    jp z,PrMnIO  ;---;      ;228c   if (NumIO).eq.0 (missing optional parameters) --> Skip their processing
    ld hl,(l0285h)   ;      ;228f   hl=Address labels corresponding to the parameter "ERR="
    xor a            ;      ;2292   a=0
    call s_3fa6h     ;      ;2293   cd a6 3f
    ld hl,(l0283h)   ;      ;2296   hl=Address labels corresponding to the parameter "END="
    xor a            ;      ;2299   a=0
    call s_3fa6h     ;      ;229a   cd a6 3f
    ld hl,(l024fh)   ;      ;229d   hl=Address constant corresponding to the parameter "REC="
    xor a            ;      ;22a0   a=0
    call s_3fa6h     ;      ;22a1   cd a6 3f
                     ;
PrMnIO:         ;<---+
;   Preparation of mnemonics built-in routine Input/Output
;
;   For statement READ or WRITE
;     First byte (in Reg B) indicates:
;       "R" - Read operation
;       "W" - Write operation       
;     Second byte (in Reg C) indicates routine:
;       "2" - with two parameters (LUN & Label)
;       "5" - with two parameters (LUN, Label & optional parameters)
;
    ld hl,(l022eh)          ;22a4   Load 1 and 2 bytes statement
    ld b,h                  ;22a7   Load in Reg B first character source statement for setup first byte built-in routine
    ld c,l                  ;22a8
    ld a,b                  ;22a9   a=b
    cp 'R'                  ;22aa   Test 'R' - indicates Read operation
    jp z,StatRW ;---;       ;22ac   .. yeap
    cp 'W'          ;       ;22af   Test 'W' - indicates Write operation
    jp nz,StatED  ;-)-----; ;22b1   .. nope
                    ;     ;
StatRW:        ;<---+     ;         Statement READ or WRITE
    ld c,'2'              ; ;22b4   Set built-in routine with two parameters
    ld a,(NumIO)          ; ;22b6
    or a                  ; ;22b9   if (NumIO).eq.0 (missing optional parameters)
    jp z,CreaIO     ;---; ; ;22ba      --> Creating built-in routine I/O
    ld c,'5'            ; ; ;22bd   Set built-in routine with five parameters
    jp CreaIO       ;---; ; ;22bf   --> Creating built-in routine I/O
                        ; ;
StatED:         ;<------)-+         Statement ENCODE or DECODE (can not have optional parameters)
    ld a,(NumIO)        ;   ;22c2
    or a                ;   ;22c5   if (NumIO).eq.0 (missing optional parameters)
    jp z,BuilED   ;---; ;   ;22c6      --> skip error message
    call err.msg      ; ;   ;22c9   Warning (33)
    db 33             ; ;   ;22cc   Illegal Argument to ENCODE/DECODE
                      ; ;
;   For ENCODE/DECODE ; ;
;     First byte: "O" ; ; Second byte:  "D" - Decode, "E" - Encode
BuilED:       ;<------+ ;
    ld c,b              ;   ;22cd   Build second byte "E" or "D"
    ld b,'O'            ;   ;22ce   Build first byte "O"
CreaIO:         ;<------+
    call CrBuilt            ;22d0   Creating built-in routine
    xor a                   ;22d3
    ld (l024ch),a           ;22d4   (l024ch)=0
    ld hl,0ffffh            ;22d7
    ld a,h                  ;22da
    ld (l0285h),a           ;22db   (l0285h)=0ffh
    ld (l0280h),hl          ;22de   (l0280h)=0ffffh
    ld (l0283h),hl          ;22e1   (l0283h)=0ffffh
    call s_5cdeh            ;22e4   cd de 5c
;
    ld a,(l0299h)           ;22e7
l22eah:         ;<--;
    cp ','          ;       ;22ea
    jp nz,l22f5h  ;-)-;     ;22ec   if (l0299h).ne.',' --> ...
    call g_n_chr    ; ;     ;22ef   Get next character
    jp l22eah   ;---+ ;     ;22f2
                      ;
l22f5h:         ;<----+
    cp cr                   ;22f5
    pop hl                  ;22f7 / e1
    jp nz,l2327h  ;---;     ;22f8   if (l0299h).ne.cr --> ...
    ld a,h            ;     ;22fb
    or l              ;     ;22fc
    jp nz,l231ah ;--; ;     ;22fd   if(hl.ne.0) --> ... 
    call err.msg    ; ;     ;2300   Warning (10)
    db 10           ; ;     ;2303   Empty List for Unformatted WRITE
    jp l231ah    ;--; ;     ;2304   --> ...
                    ; ;
l2307h:             ; ;
    ld hl,(l0283h)  ; ;     ;2307
    inc hl          ; ;     ;230a
    ld a,h          ; ;     ;230b
    or l            ; ;     ;230c
    jp nz,err116    ; ;     ;230d   if (l0283h).ne.1 --> Error (116) Unbalanced DO Nest
    ld a,(l0287h)   ; ;     ;2310
    or a            ; ;     ;2313
    jp nz,err116    ; ;     ;2314   if (l0287h).ne.0 --> Error (116) Unbalanced DO Nest
    call s_41f7h    ; ;     ;2317   cd f7 41
l231ah:         ;<--+ ;
    ld bc,'ND'        ;     ;231a   $ND - terminates the I/O process
    call CrBuilt      ;     ;231d   Creating built-in routine
    jp l09ebh         ;     ;2320   --> Clear (l029ah) & (DO_Flg) -> Ending parsing
                      ;
err115:               ;
    call err.msg      ;     ;2323   Error (115)
    db 115            ;     ;2326   Invalid Data List Element in I/O
                      ;
l2327h:        ;<-----+
    ld a,1                  ;2327   a=1
    ld (l0173h),a           ;2329   (l0173h)=1
l232ch:        ;<-----;
    call s_1cafh      ;     ;232c   cd af 1c
    jp nz,l237ch      ;     ;232f   if (KindID).ne.0 --> ...
    ld a,'('          ;     ;2332   a='('
    call ch.chr       ;     ;2334   Check character (a character for check)
    ld hl,l0287h      ;     ;2337
    inc (hl)          ;     ;233a   (l0287h)=(l0287h)+1
    ld hl,(HeapEnd)   ;     ;233b
    ex de,hl          ;     ;233e
    ld hl,(l0209h)    ;     ;233f
    push hl           ;     ;2342 \
    call subHL.DE     ;     ;2343   hl=hl-de=(l0209h)-(HeapEnd)
    ex (sp),hl        ;     ;2346   e3
    pop bc            ;     ;2347 / bc=(l0209h)
l2348h:               ;
      ld a,b          ;     ;2348
      or c            ;     ;2349
      jp z,l235ch ;-; ;     ;234a   if bc.eq.0 -->
      ld a,(hl)     ; ;     ;234d   7e
      or 80h        ; ;     ;234e   f6 80
      ld (hl),a     ; ;     ;2350   77
      dec hl        ; ;     ;2351
      dec hl        ; ;     ;2352
      dec hl        ; ;     ;2353   hl=hl-4
      dec hl        ; ;     ;2354
      dec bc        ; ;     ;2355
      dec bc        ; ;     ;2356
      dec bc        ; ;     ;2357   bc=bc-4
      dec bc        ; ;     ;2358
    jp l2348h       ; ;     ;2359   --> ...
                    ; ;
l235ch:         ;<--+ ;
    ld hl,(l0283h)    ;     ;235c 
    ld (l01cfh),hl    ;     ;235f   (l01cfh)=(l0283h)
    ld hl,(HeapEnd)   ;     ;2362
    ex de,hl          ;     ;2365
    ld hl,(l0209h)    ;     ;2366
    call subHL.DE     ;     ;2369   hl=hl-de
    ld (l0283h),hl    ;     ;236c   (l0283h)=(l0209h)-(HeapEnd)
    ld a,0bh          ;     ;236f   a=0bh
    call s_147ah      ;     ;2371   cd 7a 14
    ld a,0ffh         ;     ;2374
    ld (l0285h),a     ;     ;2376   (l0285h)=0ffh
    jp l232ch    ;----;     ;2379   --> ...
                      ;
l237ch:               ;
    sub 3             ;     ;237c   d6 03
    jp z,l2389h ;---; ;     ;237e   ca 89 23
    dec a           ; ;     ;2381   3d
    jp z,l23abh ;-; ; ;     ;2382   ca ab 23
    call err.msg  ; ; ;     ;2385   Error (115)
    db 115        ; ; ;     ;2388   Invalid Data List Element in I/O
l2389h:        ;<-)-+ ;
    ld a,(l0299h) ;   ;     ;2389
    cp '='        ;   ;     ;238c
    jp z,l2437h   ;   ;     ;238e   if (l0299h).eq.'=' --> ...
l2391h:           ;   ;
    ld de,00001h  ;   ;     ;2391   de=1
l2394h:           ;   ;
    call s_2488h  ;   ;     ;2394   cd 88 24
l2397h:           ;   ;
    ld a,(l0299h) ;   ;     ;2397
    cp ','        ;   ;     ;239a
    jp z,l232ch ;-)---+     ;239c   if (l0299h).eq.',' --> ...
    ld hl,(l0283h);         ;239f
    inc hl        ;         ;23a2
    ld a,h        ;         ;23a3
    or l          ;         ;23a4
    jp nz,l245bh  ;         ;23a5   if (l0283h).ne.0ffh --> ...
    jp l2307h     ;         ;23a8   --> ...
                  ;
l23abh:        ;<-+
    ld a,(l0299h)           ;23ab
    cp '('                  ;23ae
    jp z,l242ch             ;23b0   if (l0299h).eq.'(' --> ...
    ld a,(ScopeID)          ;23b3
    cp 3                    ;23b6
    jp nz,l2426h   ;------; ;23b8   if (ScopeID).eq.3 --> ...
    call s_556ah          ; ;23bb   cd 6a 55
    ld a,(l0230h)         ; ;23be
    ld b,a                ; ;23c1   b=(l0230h)
    ld a,(l0276h)         ; ;23c2
    or a                  ; ;23c5
    jp z,l2426h    ;------; ;23c6   if (l0276h).eq.0 --> ...
    ld c,a                ; ;23c9   c=(l0276h)
    ld hl,l241eh          ; ;23ca
    push hl               ; ;23cd \ Save l241eh
    ld hl,(l01cfh)        ; ;23ce
    push hl               ; ;23d1 \ Save (l01cfh)
    ld a,(TypeID)         ; ;23d2
    push af               ; ;23d5 \ Save (TypeID)
    ld hl,(l026ah)        ; ;23d6
    ld (l0235h),hl        ; ;23d9   (l0235h)=(l026ah)
    dec b                 ; ;23dc
    jp z,l2410h ;-------; ; ;23dd   if (l0230h).eq.1 --> ...
    ld a,2              ; ; ;23e0
    ld (l0243h),a       ; ; ;23e2   (l0243h)=2
    ld hl,(l026ch)      ; ; ;23e5   2a 6c 02
    dec b               ; ; ;23e8
    jp nz,l23fdh ;--;   ; ; ;23e9   if (l0230h).ne.2 --> ...
    ld a,c          ;   ; ; ;23ec
    rra             ;   ; ; ;23ed
    jp c,l23f4h ;-; ;   ; ; ;23ee   if (l0276h) ?? --> ...
l23f1h:       ;<--)-)-; ; ;
    call s_0523h  ; ; ; ; ; ;23f1   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
             ;<---+ ; ; ; ;
l23f4h:      ;<---; ; ; ; ;
    ld (l0237h),hl; ; ; ; ; ;23f4   (l0237h)=
    call s_0ecdh  ; ; ; ; ; ;23f7   cd cd 0e
    jp l2410h  ;--)-)-)-; ; ;23fa   --> ...
                  ; ; ; ; ;
l23fdh:      ;<---)-+ ; ; ;
    ld (l0237h),hl;   ; ; ; ;23fd   (l0237h)= 
    push bc       ;   ; ; ; ;2400 \
    call s_0ecdh  ;   ; ; ; ;2401   cd cd 0e
    pop bc        ;   ; ; ; ;2404 /
    ld a,c        ;   ; ; ; ;2405   79
    rra           ;   ; ; ; ;2406   1f
    ld hl,(l026eh);   ; ; ; ;2407   hl=(l026eh)
    jp c,l23f4h ;-+   ; ; ; ;240a   if a ??  --> ...
    jp l23f1h ;-------+ ; ; ;240d   --> ...
                        ; ;
l2410h:         ;<------+ ;
    ld hl,(l0235h)        ; ;2410
    ld (l01cfh),hl        ; ;2413   (l01cfh)=(l0235h)
    pop af                ; ;2416 / Restore (TypeID)
    push af               ; ;2417 \ f5
    ld (l0285h),a         ; ;2418   (l0285h)=
    jp l24a1h             ; ;241b   --> ...
                          ;
l241eh:                   ;
    ld hl,l0285h          ; ;241e
    ld (hl),0ffh          ; ;2421   (l0285h)=0ffh
    jp l2397h             ; ;2423   --> ...
                          ;
l2426h:             ;<----+
    call l68bbh             ;2426   cd bb 68
    jp l2394h               ;2429   --> ...

l242ch:
    call s_59a5h            ;242c   cd a5 59
    ld hl,l0285h            ;242f
    ld (hl),0ffh            ;2432   (l0285h)=0ffh
    jp l2391h               ;2434   --> ...

l2437h:
    ld hl,l0287h            ;2437
    dec (hl)                ;243a   (l0287h)=(l0287h)-1
    ld hl,(l0283h)          ;243b
    inc hl                  ;243e
    ld a,h                  ;243f
    or l                    ;2440
    jp nz,l2448h            ;2441   if (l0283h).eq.1 --> skip error message
err116:
    call err.msg            ;2444   Error (116)
    db 116                  ;2447   Unbalanced DO Nest

l2448h:
    ld a,(TypeID)           ;2448
    or a                    ;244b
    jp z,l2458h             ;244c   if (TypeID).eq.0 (INTEGER)   --> skip error message
    cp 2                    ;244f
    jp z,l2458h             ;2451   if (TypeID).eq.2 (INTEGER*4) --> skip error message
    call err.msg            ;2454   Error (128)
    db 128                  ;2457   Missing Integer Quantity

l2458h:
    call s_0d7ch            ;2458   Processing DO loop parameters m1,m2, m3
l245bh:
    ld hl,(l01b0h)          ;245b
    ld (l01cfh),hl          ;245e   (l01cfh)=(l01b0h)
    ld b,h                  ;2461
    ld c,l                  ;2462   bc=hl=(l01b0h)
    ld hl,(l0283h)          ;2463
    ex de,hl                ;2466
    ld hl,(l0209h)          ;2467
    call subHL.DE           ;246a   hl=hl-de=(l0209h)-(l0283h)
    dec hl                  ;246d
    dec hl                  ;246e   hl=(l0209h)-(l0283h)-2
    ld d,(hl)               ;246f   56
    ld (hl),b               ;2470   70
    dec hl                  ;2471   2b
    ld e,(hl)               ;2472   5e
    ld (hl),c               ;2473   71
    ex de,hl                ;2474   eb
    ld (l0283h),hl          ;2475   (l0283h)=
    ld a,14h                ;2478   a=14h 
    call s_147ah            ;247a   cd 7a 14
    call s_5cdeh            ;247d   cd de 5c
    ld hl,l0285h            ;2480
    ld (hl),0ffh            ;2483   (l0285h)=0ffh
    jp l2397h               ;2485   --> ...
;*
;*    ENTRY Reg DE=PAR
;*
s_2488h:
    ld a,(l0285h)           ;2488
    or a                    ;248b
    jp p,l24b6h  ;--;       ;248c   if (l0285h) > 0 --> ...
l248fh:       ;<----)---;
    ld a,(TypeID)   ;   ;   ;248f
    ld (l0285h),a   ;   ;   ;2492   (l0285h)=(TypeID)
    ld hl,(l01cfh)  ;   ;   ;2495
    push hl         ;   ;   ;2498 \ Save (l01cfh)
    push af         ;   ;   ;2499 \ Save (l0285h)
    ex de,hl        ;   ;   ;249a   hl=PAR      de=(l01cfh)
    ld (l0280h),hl  ;   ;   ;249b   (l0280h)=PAR
    call s_0523h    ;   ;   ;249e   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
l24a1h:             ;   ;
    call s_24c9h    ;   ;   ;24a1   Make call $Ix
    pop af          ;   ;   ;24a4 / Restore (l0285h)
    ld (l0285h),a   ;   ;   ;24a5   (l0285h)=a
    ld a,6          ;   ;   ;24a8   a=6
    call s_147ah    ;   ;   ;24aa   cd 7a 14
    pop hl          ;   ;   ;24ad / Restore (l01cfh)
    call ExtAttr    ;   ;   ;24ae   Extract Attributes from the symbol table
l24b1h:    ;<-------)-; ;
    ld a,6          ; ; ;   ;24b1   a=6
    jp s_147ah      ; ; ;   ;24b3   --> ...
                    ; ; ;
l24b6h:       ;<----+ ; ;
    ld hl,TypeID      ; ;   ;24b6
    cp (hl)           ; ;   ;24b9
    jp nz,l248fh   ;--)-;   ;24ba   if (l0285h).ne.(TypeID) --> ...
    ld hl,(l0280h)    ; ;   ;24bd   2a 80 02 
    call cmpHL.DE     ; ;   ;24c0   Compare HL with DE
    jp z,l24b1h  ;----+ ;   ;24c3   if HL.eq.DE --> ...
    jp l248fh ;---------+   ;24c6   --> ...
;*
;*  Make call $Ix
;*
s_24c9h:
    ld a,(l0285h)           ;24c9   a=(l0284h)
    ld hl,(l01cfh)          ;24cc
    push hl                 ;24cf \ Save (l01cfh)
    ld hl,l01d9h            ;24d0
    ld (hl),'$'             ;24d3   (l01d9h)='$'
    dec hl                  ;24d5
    ld (hl),'I'             ;24d6   (l01d8h)='I'
    dec hl                  ;24d8
    add a,'0'               ;24d9   Convert binary decimal to ASCII from (l0284h)
    ld (hl),a               ;24db   (l01d7h)=ASCII from (l0284h)
    ld a,3                  ;24dc
    ld (SizeID),a           ;24de   (SizeID)=3
    ld a,5                  ;24e1
    ld (KindID),a           ;24e3   (KindID)=5 (Routine)
    ld a,(l0299h)           ;24e6
    push af                 ;24e9 \ Save (l0299h)
    ld a,028h               ;24ea
    ld (l0299h),a           ;24ec   (l0299h)=028h or "("
    call s_055ah            ;24ef   cd 5a 05
    call s_1479h            ;24f2   cd 79 14
    pop af                  ;24f5 / Restore (l0299h)
    ld (l0299h),a           ;24f6
    ld a,0ffh               ;24f9
    ld (l0285h),a           ;24fb   (l0285h)=0ffh
    pop hl                  ;24fe / Restore (l01cch)
    jp ExtAttr              ;24ff   --> Extract Attributes from the symbol table
;*
;*  Processing Dimension declarators
;*
DimDecl:
    ld hl,(l01cfh)          ;2502
    push hl                 ;2505 \ Save (l01cfh)
    xor a                   ;2506
    ld (NumDim),a           ;2507   (NumDim)=0 Clear Number of Dimension declarators
    ld a,'('                ;250a   a='('
    call ch.chr             ;250c   Check character (a character for check)
    ld a,(ScopeID)          ;250f
    ld (l021bh),a           ;2512   (l021bh)=(ScopeID)
    ld hl,l0270h            ;2515   21 70 02    ! p . 
l2518h:         ;<----;
    push hl           ;     ;2518 \ Save hl
    ld a,(l0268h)     ;     ;2519
    or a              ;     ;251c
    jp z,l252eh  ;--; ;     ;251d   if (l0268h).eq.0 --> ...
    ld a,(l021bh)   ; ;     ;2520
    cp 3            ; ;     ;2523
    jp nz,l252eh ;--; ;     ;2525   if (l021bh).ne.3 --> ...
    call s_259eh    ; ;     ;2528   Processing integer constant
    jp l2531h  ;--; ; ;     ;252b   --> ...
                  ; ; ;
l252eh:       ;<--)-+ ;
    call s_1b2ch  ;   ;     ;252e   Processing integer constant with test (KindID)=Constant
l2531h:     ;<----+   ;
    ex de,hl          ;     ;2531   de=Addres declarator
    pop hl            ;     ;2532 / Restore hl
    ld (hl),e         ;     ;2533
    inc hl            ;     ;2534   hl=hl+1
    ld (hl),d         ;     ;2535   (hl)=Addres declarator
    inc hl            ;     ;2536   hl=hl+1
    ld a,(NumDim)     ;     ;2537
    inc a             ;     ;253a
    ld (NumDim),a     ;     ;253b   (NumDim)=(NumDim)+1
    cp 3              ;     ;253e
    jp z,l254bh   ;-; ;     ;2540   if (NumDim).eq.3 --> Processing is complete, permitted 3 declarator
    ld a,(l0299h)   ; ;     ;2543
    cp ','          ; ;     ;2546   Test separator
    jp z,l2518h   ;-)-+     ;2548   if (l0299h).eq.',' --> Processing next Dimension declarators
                    ;
l254bh:         ;<--+
    call s_5cdeh            ;254b   cd de 5c
    pop hl                  ;254e / hl=(l01cfh)
    jp ExtAttr              ;254f   --> Extract Attributes from the symbol table
;*
;*  Processing label
;*
PrLabel:
    call s_0941h            ;2552   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
l2555h:          ;<-;
    call g_n_chr    ;       ;2555   Get next character
    jp p,err110   ;-)---;   ;2558   if chr.eq.Special character or Letter --> Error (110) Invalid Statement Number
    cp '0'          ;   ;   ;255b
    jp z,l2555h  ;--+   ;   ;255d   if chr.eq.'0'  skip leading 0
                        ;
    ld hl,l01d9h        ;   ;2560   Pointer to start of the buffer
    ld b,-5             ;   ;2563   Length label
l2565h:      ;<-----;   ;
      ld (hl),a     ;   ;   ;2565   (hl)=chr
      dec hl        ;   ;   ;2566   hl=hl-1
      push bc       ;   ;   ;2567
      push hl       ;   ;   ;2568
      call g_n_chr  ;   ;   ;2569   Get next character
      pop hl        ;   ;   ;256c
      pop bc        ;   ;   ;256d
      jp p,l2579h ;-)-; ;   ;256e   if chr.eq.Special character or Letter --> Found chr not related to label
      inc b         ; ; ;   ;2571   b=b+1
    jp m,l2565h ;---+ ; ;   ;2572   if b<0 next char
                      ; ;
err110:      ;<-------)-+
    call err.msg      ;     ;2575   Error (110)
    db 110            ;     ;2578   Invalid Statement Number
                      ;
l2579h:         ;<----+             Found chr not related to label
    xor a                   ;2579
    ld (TypeID),a           ;257a   (TypeID)=0 (INTEGER)
    ld a,2                  ;257d
    ld (KindID),a           ;257f   (KindID)=2 (Label)
    ld a,6                  ;2582
    add a,b                 ;2584
    ld (SizeID),a           ;2585   (SizeID)=b+6
    jp s_055ah              ;2588   --> ...
;*
;*  Processing integer constant & Test (KindID).ne.1
;*
s_258bh:
    call s_259eh        ;258b   Processing integer constant
l258eh:       ;<----;
    ld a,(KindID)   ;   ;258e
    dec a           ;   ;2591
    ret nz          ;   ;2592   if (KindID).ne.1 (Constant) return
    call err.msg    ;   ;2593   Warning (14)
    db 14           ;   ;2596   Missing Integer Variable
    ret             ;   ;2597
;*                  ;
;*  Processing integer constant with error checking & Test (KindID).ne.1
;*                  ;
s_2598h:            ;
    call l25b5h     ;   ;2598   Processing integer constant with error checking
    jp l258eh   ;---+   ;259b   --> ...
;*
;*  Processing integer constant
;*
s_259eh:
    call s_1cafh        ;259e   cd af 1c
    dec a               ;25a1
    jp z,l25aah  ;---;  ;25a2   if (KindID).eq.1 (Constant) --> ...
    dec a            ;  ;25a5
    dec a            ;  ;25a6
    jp nz,err128 ;-; ;  ;25a7   if (KindID).ne.3 (Variable) --> Error (128) Missing Integer Quantity
l25aah:       ;<---)-+
    ld a,(TypeID)  ;    ;25aa
    dec a          ;    ;25ad
    ret m          ;    ;25ae   if (TypeID) < 1 Return
    dec a          ;    ;25af
    ret z          ;    ;25b0   if (TypeID).eq.2 (BYTE) Return
err128:     ;<-----+
    call err.msg        ;25b1   Error (128)
    db 128              ;25b4   Missing Integer Quantity
;*
;*  Processing integer constant with error checking
;*
l25b5h:
    call s_259eh        ;25b5   Processing integer constant
    jp z,err128         ;25b8   --> Error (128) Missing Integer Quantity
    ret                 ;25bb
;*
;*  Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement
;*
l25bch:
    ld a,1              ;25bc   a=1
;*
;*  Save (l029ah) & (DO_Flg) -> Ending parsing statement
;*
l25beh:
    ld (l029ah),a       ;25be
;*
;*  Save (DO_Flg) -> Ending parsing statement
;*
l25c1h:
    ld (DO_Flg),a       ;25c1
    jp l65fah           ;25c4   --> Ending parsing statement

;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################

RELflg: db 0        ;25c7   REL file flag [0x80 is empty]
vStack: dw 0        ;25c8   Stack
IncChr:
extdot: db 0        ;25ca   Extension dot flag [0 is extension given]
ExtStk: db 0        ;25cb   Extra stack page count
l25cch: db 0        ;25cc   list file selected ?
l25cdh: db 0        ;25cd   Drive *d*
CpuFlg: db 0        ;25ce   /I flag [0-z80]
enaLST: db 0        ;25cf   /L flag [0 is not]
StkFlg: db 0        ;25d0   /P flag
enaOBJ: db 0        ;25d1   REL flag [0 is not]
LstFlg: db 0        ;25d2   00
CCPflg: db 0        ;25d3   CCP line indicator [0 is not]
HexFlg: db 0        ;25d4   /O  flag [0-hex]
NoCode: db 0        ;25d5   /N  flag
RomFlg: db 0        ;25d6   /M  flag
PRNCol: db 0        ;25d7   Printer column

F$OBJ:  ds FCBlen   ;25d8   Object FCB
F$LST:  ds FCBlen   ;25f9   List FCB *n*
F$SRC:  ds FCBlen   ;261a   Source FCB

        ds 54       ;263b   ???

TmpAdr:                     ;2671   Address Start F80
;
; Filename
;
l2671h: ds  .drv            ;2671
l2672h: ds  .nam            ;2672
l267ah: ds  .ext            ;267a
;
;   Default extension filename
;
ExtREL: db  'REL'           ;267d
ExtCRF: db  'CRF'           ;2680
ExtPRN: db  'PRN'           ;2683

owrptr: dw 0                ;2686   REL buffer pointer
BF$OBJ: ds RELlen*reclng    ;       Object buffer

lwrptr: dw 0                ;2788   List buffer pointer
BF$LST: ds LSTlen*reclng    ;278a   List buffer

rdptr:  dw 0                ;298a   Source buffer pointer
BF$SRC: ds SRClen*reclng    ;298c   Source buffer
;
; Command buffer
;
ConBuf: db CMDLEN           ;2b8c   Length of console buffer [050h]
ConSiz: db 0                ;2b8d   Length of command (resulting size after read)
ConLin: ds CMDLEN;-1         ;2b8e   1st command character

ConPtr: dw 0                ;2bde   Current command pointer
;
l2be0h: db  '?Command error',null
l2befh: db  '?File not found',null
l2bffh: db  '?Can''t enter file',null
;
;   Print string from ^HL to console
;
PrString:
    ld a,(hl)           ;2c11   Get next
    and 07fh            ;2c12   Reset bit 7
    ret z               ;2c14   Zero is end
    call conout         ;2c15   .. print
    inc hl              ;2c18
    jp PrString         ;2c19
;
; -> Command error
;
l2c1ch:
    ld hl,l2be0h        ;2c1c   hl="Command error"
    jp l2c2bh           ;2c1f   Give message -> Restart
;
; -> File not found
;
l2c22h:
    ld hl,l2befh        ;2c22   hl="?File not found"
    jp l2c2bh           ;2c25   Give message -> Restart
;
; -> File not to be entered
;
l2c28h:
    ld hl,l2bffh        ;2c28   hl="?Cant enter file"
l2c2bh:
    call PrString       ;2c2b   Give message
    jp Restart          ;2c2e   --> Restart

;   %%% MYSTERIOUS DATA %%%
;
    db  'COM'           ;2c31
    db  'SCN'           ;2c34

l2c37h: db  0           ;2c37
        ds 23           ;2c37
;
l2c4fh:
    scf                 ;2c4f   37  7
l2c50h:
    inc l               ;2c50   2c  ,
;
;   %%% END OF MYSTERIOUS DATA %%%

;
;   Parse command line (Continue main)
;
l2c51h:
    ld (TmpAdr),hl          ;2c51   Save address Start F80

;   %%% MYSTERIOUS CODE %%%
;
    ld de,l2c37h            ;2c54   Get pointer
    ld a,(de)               ;2c57   Get byte
    or a                    ;2c58   Test set
    jp z,l2c81h ;--------;  ;2c59   if (l2c37h).eq.0 --> ...
                         ;
    ld a,(l2c50h)        ;  ;2c5c
    ld b,a               ;  ;2c5f   b=(l2c50h)
l2c60h:      ;<--------; ;
    ld a,(l2c4fh)      ; ;  ;2c60
    ld c,a             ; ;  ;2c63   c=(l2c4fh)
    ld hl,(TPATOP)     ; ;  ;2c64   Get top of memory
    ld l,0             ; ;  ;2c67   l=0 (page boundary)
l2c69h:    ;<------;   ; ;
    ld a,(de)      ;   ; ;  ;2c69   
    cp (hl)        ;   ; ;  ;2c6a   
    jp nz,l2c77h ;-)-; ; ;  ;2c6b   if (hl).ne.(de) --> ...
    inc hl         ; ; ; ;  ;2c6e   hl=hl+1
    inc de         ; ; ; ;  ;2c6f   de=de+1
    dec c          ; ; ; ;  ;2c70   c=c-1
    jp nz,l2c69h ;-+ ; ; ;  ;2c71   if c.ne.0 --> ...
    jp l2c81h ;------)-)-;  ;2c74   continue
                     ; ; ;
l2c77h:    ;<--------; ; ;
    inc de           ; ; ;  ;2c77   de=de+1
    dec c            ; ; ;  ;2c78   c=c-1
    jp nz,l2c77h ;---+ ; ;  ;2c79   
    dec b              ; ;  ;2c7c   b=b-1
    ret z              ; ;  ;2c7d   if b.eq.0 Return
    jp l2c60h  ;-------+ ;  ;2c7e   --> ...
                         ;
l2c81h:     ;<-----------+
    xor a                   ;2c81
    ld (l2c37h),a           ;2c82   (l2c37h)=0
;
;   %%% END OF MYSTERIOUS CODE %%%

    ld hl,(TPATOP)          ;2c85   (BDOS+1) Get top of memory
    dec hl                  ;2c88
    ld sp,hl                ;2c89   Set for stack
    dec hl                  ;2c8a
    dec hl                  ;2c8b
    ld (vStack),hl          ;2c8c   Save address
    ld hl,(TmpAdr)          ;2c8f   Get entry address
    push hl                 ;2c92   Save return address
    ld a,(CCPflg)           ;2c93   Get CCP line flag
    or a                    ;2c96   Test if from CCP
    jp nz,00000h            ;2c97   .. yeap, exit
    ld (ExtStk),a           ;2c9a   (ExtStk)=0 Clear extra stack page count
;
;   Restart
;
Restart:        ;<--;
    ld hl,(vStack)  ;   ;2c9d   Reload stack
    ld sp,hl        ;   ;2ca0   Set for stack
    call ComLin     ;   ;2ca1   Prepare command line
    ld a,(ConLin)   ;   ;2ca4   Get first character
    cp cr           ;   ;2ca7   Test empty command line (0dh)
    jp z,Restart ;--+   ;2ca9   .. yeap, retry
    xor a               ;2cac   a=0
    ld (PRNCol),a       ;2cad   Clear printer column
    ld (enaLST),a       ;2cb0   Clear /L option
    ld (NoCode),a       ;2cb3   Clear /N option
    ld (HexFlg),a       ;2cb6   Clear /O option
    ld (LstFlg),a       ;2cb9   Clear /C list file flag
    ld (enaOBJ),a       ;2cbc   Clear REL file flag
    ld (RomFlg),a       ;2cbf   Clear /M option
    inc a               ;2cc2   a=1
    ld (StkFlg),a       ;2cc3   Set /P flag
    ld (CpuFlg),a       ;2cc6   Set /I flag
    ld bc,l2c1ch        ;2cc9   bc= 'Command error'
    push bc             ;2ccc   Set error to return
    xor a               ;2ccd   a=0
    ld (RELflg),a       ;2cce   Set REL file found
    call parse.file     ;2cd1   Scan line for filename and options
    ret c               ;2cd4   if Error Return
    ld de,ExtREL        ;2cd5   Set "REL"
    call set.ext        ;2cd8   .. as extension
    ld de,l2672h        ;2cdb   Point to name
    ld a,(de)           ;2cde
    cp ' '              ;2cdf   .. check the specified name
    jp nz,l2ce9h ;--;   ;2ce1   .. yeap
    ld a,080h       ;   ;2ce4   a=10000000b
    ld (RELflg),a   ;   ;2ce6   Set no REL file
l2ce9h:         ;<--+
    push hl             ;2ce9
    ld hl,F$OBJ         ;2cea
    call s_2dfah        ;2ced   Unpack REL file
    pop hl              ;2cf0
    ld a,' '            ;2cf1
    ld (l2672h),a       ;2cf3   Clear name and extension
    ld (l267ah),a       ;2cf6
    xor a               ;2cf9   a=0
    ld (l2671h),a       ;2cfa   Set default drive
    ld a,c              ;2cfd
    sub ','             ;2cfe   Test file delimiter
    or a                ;2d00
    ld (enaOBJ),a       ;2d01   .. set REL file flag
    jp nz,l2d13h ;--;   ;2d04   .. nope
    ld a,(RELflg)   ;   ;2d07   Get REL file flag
    xor 080h        ;   ;2d0a   Toggle bit
    ld (enaOBJ),a   ;   ;2d0c   0x00 if REL file empty
    call parse.file ;   ;2d0f   Parse file
    ret c           ;   ;2d12   return if Error
l2d13h:         ;<--+
    ld de,ExtPRN        ;2d13   Take .PRN
    ld a,(LstFlg)       ;2d16   Get list file flag
    or a                ;2d19   Test type
    jp z,l2d20h  ;--;   ;2d1a
    ld de,ExtCRF    ;   ;2d1d   Take .CRF
l2d20h:         ;<--+
    call set.ext        ;2d20   .. set as extension
    ld de,l2672h        ;2d23   Point to name
    ld a,(l2671h)       ;2d26
    ld (l25cdh),a       ;2d29   (l25cdh)=(l2671h) Save drive *d*
    ld a,(de)           ;2d2c
    sub ' '             ;2d2d   Test empty file
    ld (l25cch),a       ;2d2f
    jp nz,l2d3dh ;--;   ;2d32   Nope
    ld a,(RELflg)   ;   ;2d35   Get REL file flag
    add a,040h      ;   ;2d38   Insert bit
    ld (RELflg),a   ;   ;2d3a   Save REL file flag
l2d3dh:         ;<--+
    push hl             ;2d3d
    ld hl,F$LST         ;2d3e *f*
    call s_2dfah        ;2d41   Unpack list file
    pop hl              ;2d44
    ld a,c              ;2d45   Get last character
    cp '='              ;2d46   Must be assignment
    scf                 ;2d48
    ret nz              ;2d49
    call parse.file     ;2d4a   Parse file
    cp cr               ;2d4d   Must be last entry
    scf                 ;2d4f
    ret nz              ;2d50
    ld de,l0321h        ;2d51   Get .FOR
    call set.ext        ;2d54   .. set as extension
    ld de,l2671h        ;2d57
    ld a,(de)           ;2d5a   Get drive
    inc de              ;2d5b
    or a                ;2d5c   Test character I/O
    jp m,l2d65h ;---;   ;2d5d   Yeap
    ld a,(de)       ;   ;2d60
    cp ' '          ;   ;2d61   Verify not empty source file
    scf             ;   ;2d63
    ret z           ;   ;2d64
l2d65h:         ;<--+
    push hl             ;2d65
    ld hl,F$SRC         ;2d66
    call s_2dfah        ;2d69   Unpack source file
    pop hl              ;2d6c
    ld a,(RELflg)       ;2d6d   Get REL file flag
    add a,a             ;2d70   Test REL file empty
    ld hl,F$OBJ         ;2d71   Point to REL file
    call c,s_2ddah      ;2d74   Empty REL file, ^HL=Parsed FCB
    add a,a             ;2d77
    ld hl,F$LST         ;2d78   Point to list file *f*
    push af             ;2d7b
    ld a,(LstFlg)       ;2d7c   Get list file flag
    or a                ;2d7f   Test type
    jp z,l2d95h  ;----; ;2d80   Got .PRN
    ld de,F$LST+.drv+.nam   ;2d83 *f*
    ld bc,ExtCRF      ; ;2d86   .. .CRF
    ld a,3            ; ;2d89   a=.ext
l2d8bh:         ;<--; ;
      push af       ; ; ;2d8b
      ld a,(bc)     ; ; ;2d8c   Set extension
      ld (de),a     ; ; ;2d8d
      inc de        ; ; ;2d8e
      inc bc        ; ; ;2d8f
      pop af        ; ; ;2d90
      dec a         ; ; ;2d91
    jp nz,l2d8bh ;--+ ; ;2d92
l2d95h:         ;<----+
    pop af              ;2d95   Test list file selected
    call c,s_2ddah      ;2d96   Empty list file, ^HL=Parsed FCB
    ld a,(enaLST)       ;2d99
    or a                ;2d9c   Test /L
    jp nz,l2daah ;--;   ;2d9d   if(enaLST).ne.0 -->
    ld a,(l25cch)   ;   ;2da0
    or a            ;   ;2da3   Test list file selected
    jp nz,l2daah ;--;   ;2da4   Yeap
    ld a,(l25cdh)   ;   ;2da7   *d*
l2daah:         ;<--+
    ld (enaLST),a       ;2daa   Set /L
    ld c,019h           ;2dad   c=retdsk (Return current drive)
    call BDOS           ;2daf   Get current disk
    push af             ;2db2
    ld c,00dh           ;2db3   c=resdsk (Reset discs)
    call BDOS           ;2db5   Reset entire disk system
    pop af              ;2db8
    ld e,a              ;2db9
    ld c,0eh            ;2dba   c=seldsk (Select disc)
    call BDOS           ;2dbc   .. log original one only
    xor a               ;2dbf   a=0
    ld (CCPbuf),a       ;2dc0   Force empty line
    call sreset         ;2dc3   Open source file
    call lrewrite       ;2dc6   Create list file
    call orewrite       ;2dc9   Create REL file
    pop hl              ;2dcc   Clean error return
    ld hl,(vStack)      ;2dcd   Get back top address
    inc hl              ;2dd0
    inc hl              ;2dd1
    ld a,(StkFlg)       ;2dd2   Get /P flag
    ld (ExtStk),a       ;2dd5   (ExtStk)=(StkFlg)
    ld b,a              ;2dd8
    ret                 ;2dd9   Return to Start F80
;*
;*  Unpack ^HL with parsed FCB
;*
s_2ddah:
    push af                 ;2dda
    ld de,l2671h            ;2ddb   Point to FCB
    ld c,9                  ;2dde   c=.drv+.nam
    ld a,(hl)               ;2de0   Get drive
    or a                    ;2de1   Test empty
    jp nz,l2df4h ;------;   ;2de2   Nope, go copy
    ld a,(de)           ;   ;2de5
    or a                ;   ;2de6   Get parsed device
    jp m,l2df4h  ;------;   ;2de7   Got not a file
l2deah:        ;<--;<-; ;
      ld a,(de)    ;  ; ;   ;2dea
      ld (hl),a    ;  ; ;   ;2deb   Unpack FCB
      inc hl       ;  ; ;   ;2dec
      inc de       ;  ; ;   ;2ded
      dec c        ;  ; ;   ;2dee
    jp nz,l2deah ;-+  ; ;   ;2def
l2df2h:               ; ;
    pop af            ; ;   ;2df2
    ret               ; ;   ;2df3
l2df4h:       ;<------)-+
    dec c             ;     ;2df4   Fix parameters
    inc hl            ;     ;2df5
    inc de            ;     ;2df6
    jp l2deah    ;----+     ;2df7
;*
;*  Unpack file D:NAME.EXT from ^DE to ^HL
;*
s_2dfah:
    dec de                  ;2dfa   .. fix for drive
    ld b,0ch                ;2dfb   b=.drv+.nam+.ext
l2dfdh:         ;<--;
      ld a,(de)     ;       ;2dfd   .. unpack it
      ld (hl),a     ;       ;2dfe
      inc hl        ;       ;2dff
      inc de        ;       ;2e00
      dec b         ;       ;2e01
    jp nz,l2dfdh ;--+       ;2e02
    ret                     ;2e05
;*
;*  Set extension of file
;*    ENTRY Reg DE points to extension
;*
set.ext:
    ld a,(extdot)           ;2e06   Test dot given
    or a                    ;2e09
    ret z                   ;2e0a   .. yeap
    push hl                 ;2e0b
    ld hl,l267ah            ;2e0c   hl=l3e22+.drv+.nam
    ld a,(hl)               ;2e0f   .. test any extension here
    cp ' '                  ;2e10
    jp nz,l2e21h ;---;      ;2e12   .. yeap
    ld b,3           ;      ;2e15   Set length
l2e17h:     ;<-----; ;
      ld a,(de)    ; ;      ;2e17   .. unpack extension
      and 7fh      ; ;      ;2e18   Reset bit 7
      ld (hl),a    ; ;      ;2e1a
      inc hl       ; ;      ;2e1b
      inc de       ; ;      ;2e1c
      dec b        ; ;      ;2e1d
    jp nz,l2e17h ;-+ ;      ;2e1e
l2e21h:       ;<-----+
    pop hl                  ;2e21
    ret                     ;2e22
;*
;*  Parse file - Accu holds delimiter character on exit
;*    Carry set indicates error
;*
parse.file:
l2e23h:        ;<----;
    call ChLine      ;      ;2e23   Check line
    cp ':'           ;      ;2e26   Test drive/device delimiter
    scf              ;      ;2e28
    ld a,0           ;      ;2e29
    jp nz,l2e47h ;---)-;    ;2e2b   .. nope, set default drive
    ld a,b           ; ;    ;2e2e   Get length of line
    or a             ; ;    ;2e2f   Test empty
    jp z,l2e23h ;----+ ;    ;2e30   .. yeap, get next
    ex de,hl           ;    ;2e33   .. set pointer
    call GetnCh        ;    ;2e34   Get next char
    ld c,a             ;    ;2e37
    ld a,b             ;    ;2e38   Get back count
    dec a              ;    ;2e39   Test one character for drive
    ld a,c             ;    ;2e3a
    jp nz,TstTTY ;---; ;    ;2e3b   Nope, must be device
    cp 'Z'+1         ; ;    ;2e3e   Verify valid drive
    ret nc           ; ;    ;2e40
    cp 'A'           ; ;    ;2e41
    ret c            ; ;    ;2e43
    sub 'A'-1        ; ;    ;2e44   Build drive
    ex de,hl         ; ;    ;2e46
l2e47h:        ;<----)-+
    ld (l2671h),a    ; ;    ;2e47   Save drive
    call nc,ChLine   ; ;    ;2e4a   Check line
    ld a,b           ; ;    ;2e4d   Get length
    cp 0bh           ; ;    ;2e4e   Test length .nam+.ext
    jp c,l2e55h ;--; ; ;    ;2e50   In range
    ld b,0bh       ; ; ;    ;2e53   b=.nam+.ext.. truncate
l2e55h:        ;<--+ ; ;
    push bc          ; ;    ;2e55
    ex de,hl         ; ;    ;2e56
    push de          ; ;    ;2e57
    ld de,l2672h     ; ;    ;2e58   Point to filename
    inc b            ; ;    ;2e5b
l2e5ch:         ;<-; ; ;
      dec b        ; ; ;    ;2e5c
      jp z,EndPrs;-)-)-)-;  ;2e5d
      call GetnCh  ; ; ; ;  ;2e60   Get next char
      ld (de),a    ; ; ; ;  ;2e63   Unpack name of file
      inc de       ; ; ; ;  ;2e64
    jp l2e5ch  ;---+ ; ; ;  ;2e65
                     ; ; ;
;*  Test devices     ; ; ;
                     ; ; ;
;*  1 - Test TTY     ; ; ;
                     ; ; ;
TstTTY:         ;<---+ ; ;
    cp 'T'             ; ;  ;2e68   Test TTY
    jp nz,TstLST  ;--; ; ;  ;2e6a   .. nope
    call GetnCh      ; ; ;  ;2e6d   Get next char
    cp 'T'           ; ; ;  ;2e70   Verify TTY
    scf              ; ; ;  ;2e72
    ret nz           ; ; ;  ;2e73
    call GetnCh      ; ; ;  ;2e74
    cp 'Y'           ; ; ;  ;2e77
    scf              ; ; ;  ;2e79
    ret nz           ; ; ;  ;2e7a
    sbc a,a          ; ; ;  ;2e7b   Return 0xFF
    ex de,hl         ; ; ;  ;2e7c
    or a             ; ; ;  ;2e7d
    jp l2e47h ;------)-; ;  ;2e7e
                     ; ; ;
;*  2 - Test LST     ; ; ;
                     ; ; ;
TstLST:         ;<---+ ; ;
    cp 'L'             ; ;  ;2e81   Test LST
    jp nz,TstRDR  ;--; ; ;  ;2e83   .. nope
    call GetnCh      ; ; ;  ;2e86   Get next char
    cp 'S'           ; ; ;  ;2e89   Verify LST
    scf              ; ; ;  ;2e8b
    ret nz           ; ; ;  ;2e8c
    call GetnCh      ; ; ;  ;2e8d
    cp 'T'           ; ; ;  ;2e90
    scf              ; ; ;  ;2e92
    ret nz           ; ; ;  ;2e93   .
    ld a,0feh        ; ; ;  ;2e94   Return 0xFE
    ex de,hl         ; ; ;  ;2e96
    or a             ; ; ;  ;2e97
    jp l2e47h ;------)-; ;  ;2e98
                     ; ; ;
;*  3 - Test RDR     ; ; ;
                     ; ; ;
TstRDR:         ;<---+ ; ;
    cp 'R'             ; ;  ;2e9b   Test RDR
    scf                ; ;  ;2e9d
    ret nz             ; ;  ;2e9e   .. nope
    call GetnCh        ; ;  ;2e9f   Get next char
    cp 'D'             ; ;  ;2ea2   Verify RDR
    scf                ; ;  ;2ea4
    ret nz             ; ;  ;2ea5
    cp 'R'             ; ;  ;2ea6
    scf                ; ;  ;2ea8
    ret nz             ; ;  ;2ea9
    ld a,0feh          ; ;  ;2eaa   Return 0xFE
    ex de,hl           ; ;  ;2eac
    or a               ; ;  ;2ead
    jp l2e47h ;--------+ ;  ;2eae
                         ;
;*  End of parse         ;
                         ;
EndPrs:         ;<-------+
    pop hl                  ;2eb1   End of parse
    pop bc                  ;2eb2
    ld a,0ah                ;2eb3   a=.nam+.ext-1
    sub b                   ;2eb5   Test length
    jp c,l2ec2h ;----;      ;2eb6
    ex de,hl         ;      ;2eb9
l2ebah:     ;<-----; ;
      ld (hl),' '  ; ;      ;2eba   Blank remainder
      inc hl       ; ;      ;2ebc
      dec a        ; ;      ;2ebd
    jp p,l2ebah ;--+ ;      ;2ebe
    ex de,hl         ;      ;2ec1
l2ec2h:         ;<---+
    ld a,c                  ;2ec2   Get back last character
    ld b,0                  ;2ec3
    sub '.'                 ;2ec5   Test dot
    ld (extdot),a           ;2ec7   Set dot flag
    call z,ChLine           ;2eca   Check line if dot
    ex de,hl                ;2ecd   .. get back start
    push de                 ;2ece
    ld de,l267ah            ;2ecf   Point to extension
    ld a,b                  ;2ed2
    cp 4                    ;2ed3   .ext+1 Test length
    jp c,l2edah ;--;        ;2ed5
    ld b,3         ;        ;2ed8   Set max extension
l2edah:         ;<-+
    inc b                   ;2eda
l2edbh:         ;<----;
      dec b           ;     ;2edb
      jp z,l2ee7h ;---)-;   ;2edc   --> Set option flag
      call GetnCh     ; ;   ;2edf   Get extension character
      ld (de),a       ; ;   ;2ee2   Unpack it
      inc de          ; ;   ;2ee3
    jp l2edbh  ;------+ ;   ;2ee4
                        ;
;*  Set option flag     ;
                        ;
l2ee7h:     ;<----------+
    pop hl                  ;2ee7
l2ee8h:       ;<--------;
    ld a,c              ;   ;2ee8
    sub '/'             ;   ;2ee9   Test option prefix
    or a                ;   ;2eeb
    ld a,c              ;   ;2eec
    ret nz              ;   ;2eed   Nope
    call GetnCh         ;   ;2eee   Get option char
    cp 'L'              ;   ;2ef1   Test /L listing
    jp nz,l2f00h ;----; ;   ;2ef3
    ld (enaLST),a     ; ;   ;2ef6   Set /L option (Enable list file)
l2ef9h:            ;<-)-)-;
    call GetnCh       ; ; ; ;2ef9   Get next char
    ld c,a            ; ; ; ;2efc   Save it
    jp l2ee8h  ;------)-+ ; ;2efd   .. test more options
l2f00h:          ;<---+   ;
    cp 'N'                ; ;2f00   Test /N option
    jp nz,l2f0bh ;--;     ; ;2f02
    ld (NoCode),a   ;     ; ;2f05   Set /N option
    jp l2ef9h  ;----)-----; ;2f08
l2f0bh:    ;<-------+     ;
    cp 'O'                ; ;2f0b   Test /O octal listing
    jp nz,l2f16h ;--;     ; ;2f0d
    ld (HexFlg),a   ;     ; ;2f10   Set /O option
    jp l2ef9h  ;----)-----; ;2f13
l2f16h:    ;<-------+     ;
    cp 'R'                ; ;2f16   Test /R rel file
    jp nz,l2f21h ;--;     ; ;2f18
    ld (enaOBJ),a   ;     ; ;2f1b   Set /R option (REL file enabled)
    jp l2ef9h  ;----)-----; ;2f1e
l2f21h:    ;<-------+     ;
    cp 'C'                ; ;2f21   Test /C cross reference
    jp nz,l2f2fh ;--;     ; ;2f23
    ld (LstFlg),a   ;     ; ;2f26   Set /C option
    ld (enaLST),a   ;     ; ;2f29   Set /L option
    jp l2ef9h  ;----)-----; ;2f2c
l2f2fh:    ;<-------+     ;
    cp 'M'                ; ;2f2f   Test /M
    jp nz,l2f3ah ;--;     ; ;2f31
    ld (RomFlg),a   ;     ; ;2f34   Set /M option (Enable)
    jp l2ef9h  ;----)-----; ;2f37   
l2f3ah:    ;<-------+     ;
    cp 'I'                ; ;2f3a   Test /I INTEL
    jp nz,l2f45h ;--;     ; ;2f3c   
    ld (CpuFlg),a   ;     ; ;2f3f   Set /I option
    jp l2ef9h  ;----)-----; ;2f42   
l2f45h:    ;<-------+     ;
    cp 'Z'                ; ;2f45   Test /Z ZILOG
    jp nz,l2f51h ;--;     ; ;2f47   
    xor a           ;     ; ;2f4a   
    ld (CpuFlg),a   ;     ; ;2f4b   Clear /I option
    jp l2ef9h  ;----)-----; ;2f4e   
l2f51h:    ;<-------+     ;
    cp 'P'                ; ;2f51   Test /P extra stack page
    scf                   ; ;2f53   Set carry
    ret nz                ; ;2f54   
    ld a,(StkFlg)         ; ;2f55   
    inc a                 ; ;2f58   Advance /P count
    ld (StkFlg),a         ; ;2f59   
    jp l2ef9h  ;----------+ ;2f5c
;*
;*  Count symbolic characters in ^HL
;*  On exit Accu and reg C hold closing character
;*  Reg B holds length of characters
;*  ^HL points to closing character
;*  ^DE holds start of character
;*
ChLine:
    ld b,0                  ;2f5f   Clear count
    push hl                 ;2f61   Save pointer
l2f62h:         ;<--------;
      call GetnCh         ; ;2f62   Get next char
      cp 'Z'+1            ; ;2f65   Test range A..Z
      jp nc,l2f7dh  ;---; ; ;2f67
      cp '0'            ; ; ;2f6a   or 0..9
      jp c,l2f7dh   ;---; ; ;2f6c
      cp 'A'            ; ; ;2f6f
      jp nc,l2f79h ;-;  ; ; ;2f71
      cp '9'+1       ;  ; ; ;2f74
      jp nc,l2f7dh ;-)--; ; ;2f76
l2f79h:       ;<-----+  ; ;
      inc b             ; ; ;2f79   Count characters
    jp l2f62h   ;-------)-+ ;2f7a
l2f7dh:     ;<----------+
    ld c,a                  ;2f7d   Save closing one
    pop de                  ;2f7e   Get back start pointer
    ret                     ;2f7f   
;*
;*  Prepare command line
;*
ComLin:
    push bc                 ;2f80
    push de                 ;2f81
    ld hl,CCPbuf            ;2f82   Point to command line
    ld a,(hl)               ;2f85   Get length
    ld (hl),0               ;2f86   Clear for later
    or a                    ;2f88   Test any in buffer
    ld b,a                  ;2f89
l2f8ah:       ;<----;
      jp z,l2fafh ;-)---;   ;2f8a   Buffer empty
      inc hl        ;   ;   ;2f8d
      ld a,(hl)     ;   ;   ;2f8e
      cp ' '        ;   ;   ;2f8f   Skip leadinf blanks
      jp nz,l2f98h;-)-; ;   ;2f91
      dec b         ; ; ;   ;2f94
    jp l2f8ah    ;--+ ; ;   ;2f95
l2f98h:       ;<------+ ;
    ld de,ConSiz        ;   ;2f98   Init line
    ld a,b              ;   ;2f9b   Get back remaining length
    dec hl              ;   ;2f9c
    inc b               ;   ;2f9d
l2f9eh:         ;<--;   ;
      ld (de),a     ;   ;   ;2f9e   Unpack CCP line
      inc de        ;   ;   ;2f9f
      inc hl        ;   ;   ;2fa0
      dec b         ;   ;   ;2fa1
      jp z,l2fa9h ;-)-; ;   ;2fa2
      ld a,(hl)     ; ; ;   ;2fa5
    jp l2f9eh   ;---+ ; ;   ;2fa6
l2fa9h:           ;<--+ ;
    ld (CCPflg),a       ;   ;2fa9   Set stop flag
    jp l2fcfh   ;-----; ;   ;2fac
l2fafh:       ;<------)-+
    xor a             ;     ;2faf
    ld (CCPflg),a     ;     ;2fb0   Reset stop flag
    ld a,(ExtStk)     ;     ;2fb3
    or a              ;     ;2fb6
    jp nz,l2fc2h ;--; ;     ;2fb7
    call n_line     ; ;     ;2fba   Close console line
    ld a,'*'        ; ;     ;2fbd
    call conout     ; ;     ;2fbf   Indicate input
l2fc2h:          ;<-+ ;
    ld c,0ah          ;     ;2fc2   rdcon (Buffered console input)
    ld de,ConBuf      ;     ;2fc4
    call BDOS         ;     ;2fc7   Read line from keyboard
    ld a,lf           ;     ;2fca
    call conout       ;     ;2fcc   .. close line
l2fcfh:         ;<----+
    pop de                  ;2fcf
    pop bc                  ;2fd0
    ld a,(ConSiz)           ;2fd1   Get length of command
    ld hl,ConLin            ;2fd4   Init command pointer
    push hl                 ;2fd7
    ld (ConPtr),hl          ;2fd8   .. init console pointer
    add a,l                 ;2fdb
    ld l,a                  ;2fdc   Point to end
    ld a,0                  ;2fdd
    adc a,h                 ;2fdf
    ld h,a                  ;2fe0
    ld (hl),cr              ;2fe1   Close command line
    inc hl                  ;2fe3
    ld a,lf                 ;2fe4   
    ld (hl),a               ;2fe6
    pop hl                  ;2fe7
;
;   new code
;
    ld a,(ExtStk)           ;2fe8
    or a                    ;2feb
    jp nz,l300bh  ;-------; ;2fec
    push hl               ; ;2fef
    ld hl,ConLin          ; ;2ff0   Point to start again
l2ff3h:     ;<--------;   ;
    ld a,(hl)         ;   ; ;2ff3   Get character
    cp cr             ;   ; ;2ff4   Test end of line
    jp z,l300ah ;-----)-; ; ;2ff6
    sub 'a'           ; ; ; ;2ff9   Test lower case
    jp c,l3006h  ;--; ; ; ; ;2ffb
    cp 'z'-'a'+1    ; ; ; ; ;2ffe
    jp nc,l3006h ;--; ; ; ; ;3000
    add a,'A'       ; ; ; ; ;3003   Convert to upper case
    ld (hl),a       ; ; ; ; ;3005
l3006h:          ;<-+ ; ; ;
    inc hl            ; ; ; ;3006
    jp l2ff3h     ;---+ ; ; ;3007
l300ah:         ;<------+ ;
    pop hl                ; ;300a
l300bh:     ;<------------+
    ret                     ;300b
;*
;*  Get next character from buffer ^HL
;*    Carry set indicates end of file
;*
GetnCh:
l300ch:       ;<--;
    ld a,(hl)     ;     ;300c   Get character
    inc hl        ;     ;300d
    cp ' '        ;     ;300e   Skip blanks
    jp z,l300ch ;-;     ;3010
    cp lf         ;     ;3013   and line feeds
    jp z,l300ch ;-+     ;3015
    cp cr               ;3018   Test return
    jp nz,TstEOF        ;301a   Nope -> Test end of file
    inc hl              ;301d
    ld (ConPtr),hl      ;301e   .. set pointer
    ret                 ;3021
;*
;*  Put character on stack to console
;*
outCON:
    pop af              ;3022   Get character back
;*
;*  Put character in Accu to console
;*
conout:
    push hl             ;3023
    push de             ;3024
    push bc             ;3025
    push af             ;3026
    ld c,2              ;3027   c=conout (Console output)
    and 07fh            ;3029   Less hi bit
    ld e,a              ;302b
    call BDOS           ;302c   Put to console
    pop af              ;302f
    pop bc              ;3030
    pop de              ;3031
    pop hl              ;3032
    or a                ;3033
    ret                 ;3034
;*
;*  Get character from command buffer
;*    EXIT  Accu holds character
;*    Carry set on end of file
;*    (Fall in error if so)
;*
getchr:
    push hl             ;3035
    ld hl,(ConPtr)      ;3036   Get command pointer
    dec hl              ;3039
    ld a,(hl)           ;303a   Get from buffer
    and 7fh             ;303b   Less hi bit
    cp lf               ;303d   Test end of line
    inc hl              ;303f
    call z,ComLin       ;3040   Get new command line if end
    inc hl              ;3043
    ld (ConPtr),hl      ;3044
    dec hl              ;3047
l3048h:
    ld a,(hl)           ;3048   Get character
    pop hl              ;3049
TstEOF:
    cp eof              ;304a   Test end of file
    scf                 ;304c   Set carry to indicate error
    ret z               ;304d   .. yeap
    or a                ;304e   Clear carry
    ret                 ;304f
;*
;*  Close console line
;*
n_line:
    ld a,cr             ;3050
    call conout         ;3052   Put new line to console
    ld a,lf             ;3055
    jp conout           ;3057
;*
;*  Create list file
;*
lrewrite:
    push af             ;305a
    push bc             ;305b
    push de             ;305c
    push hl             ;305d
    ld de,BF$LST        ;305e   Get FCB list buffer
    ld hl,00000h        ;3061
    ld (lwrptr),hl      ;3064   Clear buffer position
    ld hl,F$LST         ;3067   Point to list file *f*
    ld a,(enaLST)       ;306a   Get /L option
    jp Create_file      ;306d   Create file
;*
;*  Create REL file
;*
orewrite:
    push af             ;3070
    push bc             ;3071
    push de             ;3072
    push hl             ;3073
    ld de,BF$OBJ        ;3074   Get FCB object buffer
    ld hl,00000h        ;3077
    ld (owrptr),hl      ;307a   Clear buffer position
    ld hl,F$OBJ         ;307d   Point to REL file
    ld a,(enaOBJ)       ;3080   Get /R option
;*
;*  Create file
;*    ENTRY Reg DE points to file buffer
;*          Reg HL points to FCB
;*          Accu   holds enable flag
;*
Create_file:
    or a                ;3083   Test file enabled
    jp z,l30b4h  ;--;   ;3084   .. nope
    push hl         ;   ;3087
    ld c,1ah        ;   ;3088   c=setdma (Set DMA address)
    call BDOS       ;   ;308a   Set disk buffer
    pop hl          ;   ;308d
    ld a,(hl)       ;   ;308e   Test character device
    or a            ;   ;308f
    jp m,l30b4h  ;--;   ;3090   .. yeap
    call clr.FCB    ;   ;3093   Prepare FCB
    push de         ;   ;3096
    ld c,13h        ;   ;3097   c=delete (delete file)
    call BDOS       ;   ;3099   Delete existent file
    pop de          ;   ;309c
    push de         ;   ;309d
    ld c,16h        ;   ;309e   c=make (create file)
    call BDOS       ;   ;30a0   Create new file
    inc a           ;   ;30a3   Test success
    jp z,l2c28h     ;   ;30a4   .. error -> File not to be entered
    pop hl          ;   ;30a7
                    ;
;*  Open file ^DE   ;
                    ;
l30a8h:             ;
    call clr.FCB    ;   ;30a8   Clear parts of FCB
    ld c,0fh        ;   ;30ab   c=open (Open file)
    call BDOS       ;   ;30ad   Reopen file
    inc a           ;   ;30b0   Test success
    jp z,l2c22h     ;   ;30b1   .. error -> File not found
l30b4h:         ;<--+
    pop hl              ;30b4
    pop de              ;30b5
    pop bc              ;30b6
    pop af              ;30b7
    ret                 ;30b8
;*
;*  Open source file
;*
sreset:
    push af                 ;30b9
    push bc                 ;30ba
    push de                 ;30bb
    push hl                 ;30bc
    ld hl,SRClen*reclng     ;30bd   hl=0200h
    ld (rdptr),hl           ;30c0   Init source buffer position
    ld de,BF$SRC            ;30c3
    ld c,1ah                ;30c6   c=setdma (Set DMA address)
    call BDOS               ;30c8   Set disk buffer
    ld hl,F$SRC             ;30cb   Point to source device
    ld a,(hl)               ;30ce   Test char device (CON/RDR)
    or a                    ;30cf
    jp m,l30b4h             ;30d0   .. Yeap, skip it
    jp l30a8h               ;30d3   --> Open file
;*
;*  Clear parts of FCB in ^HL
;*
clr.FCB:
    push hl             ;30d6
    push de             ;30d7
    ld de,0000ch        ;30d8   de=_EX
    add hl,de           ;30db   Point to extent
    xor a               ;30dc
    ld d,4              ;30dd
l30dfh:         ;<--;
      ld (hl),a     ;   ;30df   .. clear next bytes
      inc hl        ;   ;30e0
      dec d         ;   ;30e1
    jp nz,l30dfh ;--+   ;30e2
    ld de,00010h        ;30e5   de=_CR-_EX-4
    add hl,de           ;30e8
    ld (hl),a           ;30e9   Clear current record
    pop hl              ;30ea
    pop de              ;30eb
    ret                 ;30ec
;*
;*  Close source file
;*
sclose:
    push af             ;30ed
    push de             ;30ee
    ld de,F$SRC         ;30ef   Point to source device
    ld a,(de)           ;30f2
    or a                ;30f3   Test CON/RDR
    jp m,l310dh  ;--;   ;30f4   .. yeap
    push bc         ;   ;30f7
    push hl         ;   ;30f8
    push de         ;   ;30f9
    ld de,BF$SRC    ;   ;30fa
    ld c,1ah        ;   ;30fd   c=setdma (Set DMA address)
    call BDOS       ;   ;30ff   Set disk buffer
    pop de          ;   ;3102
    db 1            ;   ;3103   ld bc,0e5c5h (in the original)  trap_ms
                    ;
;*  Close file ^DE  ;
                    ;
l3103h:             ;
    push bc         ;   ;3104
    push hl         ;   ;3105
    ld c,10h        ;   ;3106   c=close (Close file)
    call BDOS       ;   ;3108   .. close file
    pop hl          ;   ;310b
    pop bc          ;   ;310c
l310dh:         ;<--+
    pop de              ;310d
    pop af              ;310e
    ret                 ;310f
;*
;*  Close list file
;*
lclose:
    push af             ;3110
    ld a,(enaLST)       ;3111   Test list file /L
    or a                ;3114
    jp z,l2df2h         ;3115   if(enaLST).eq.0 --> ..nope
    push de             ;3118
    ld a,(F$LST)        ;3119   Get list device *f*
    inc a               ;311c   Test console
    jp z,l310dh         ;311d   .. yeap
    jp m,l3199h         ;3120   .. skip if other
    ld a,cr             ;3123   a=cr
    call lput           ;3125   Give new line
    ld a,lf             ;3128   a=lf
    call lput           ;312a
    ld a,eof            ;312d   a=eof
    call lput           ;312f   .. close file
    push hl             ;3132
    ld hl,(lwrptr)      ;3133   Get buffer pointer
    ld de,BF$LST        ;3136   Get buffer
    push bc             ;3139
    ld bc,F$LST         ;313a   Point to list file *f*
    call Calc_num_rec   ;313d   Empty buffer
    ld de,BF$LST        ;3140
    ld c,1ah            ;3143   c=setdma (Set DMA address)
    call BDOS           ;3145   Set disk buffer
    pop bc              ;3148
    pop hl              ;3149
    ld de,F$LST         ;314a   Point to list file *f*
    jp l3103h           ;314d   Close file ^DE  trap_ms (064d4h) ***
;*
;*  Close REL file
;*
oclose:
    push af             ;3150
    ld a,(enaOBJ)       ;3151   Test REL file enabled
    or a                ;3154
    jp z,l2df2h         ;3155   .. no REL file
    push de             ;3158
    ld a,(F$OBJ)        ;3159   Get REL file device
    or a                ;315c   Test file
    jp m,l310dh         ;315d   .. nope
    ld a,eof            ;3160   a=eof
    call oput           ;3162   Write end of file
    push hl             ;3165
    ld hl,(owrptr)      ;3166   Get REL buffer pointer
    ld de,BF$OBJ        ;3169
    push bc             ;316c
    ld bc,F$OBJ         ;316d   Point to REL file
    call Calc_num_rec   ;3170   Empty buffer
    ld de,BF$OBJ        ;3173
    ld c,1ah            ;3176   c=setdma (Set DMA address)
    call BDOS           ;3178   Set disk buffer
    pop bc              ;317b
    pop hl              ;317c
    ld de,F$OBJ         ;317d   Point to REL file
    jp l3103h           ;3180   Close file ^DE  trap_ms (064d4h) ***
;*
;*  Calculate number of records
;*
Calc_num_rec:
    ld a,h              ;3183
    or l                ;3184   Test any in buffer
    ret z               ;3185   Nope
    ld a,l              ;3186
    and reclng-1        ;3187   Mask pointer
    jp z,l318eh  ;--;   ;3189
    add a,reclng    ;   ;318c   Add carry
l318eh:         ;<--+
    rla                 ;318e
    rla                 ;318f
    and 3               ;3190
    add hl,hl           ;3192
    add a,h             ;3193   Calculate record count
    ld h,b              ;3194   Get FCB`
    ld l,c              ;3195
    jp wrtrec           ;3196   Write buffer to disk
;*
;*  Close printer page
;*
l3199h:
    ld a,cr             ;3199   a=cr
    call lput           ;319b   Close line
    ld a,lf             ;319e   a=lf
    call lput           ;31a0
    ld a,ff             ;31a3   a=ff
    call lput           ;31a5   .. give form feed
    pop de              ;31a8
    pop af              ;31a9
    ret                 ;31aa
;*
;*  Put character to list device
;*
lput:
    push af                 ;31ab   Save character
    ld a,(enaLST)           ;31ac
    or a                    ;31af   Test list file enabled /L
    jp z,l2df2h             ;31b0   if(enaLST).eq.0 --> (pop af ret)
    ld a,(F$LST)            ;31b3   Get list device *f*
    inc a                   ;31b6
    jp z,outCON             ;31b7   0xFF is CON
    jp m,outLST             ;31ba   0xFE is LST
    ex (sp),hl              ;31bd
    push hl                 ;31be
    push de                 ;31bf
    ld hl,(lwrptr)          ;31c0   Get list buffer pointer
    ld a,h                  ;31c3
    cp HIGH(LSTlen*reclng)  ;31c4   Test buffer filled (2)
    call z,lwrrec           ;31c6   .. write record if filled
    inc hl                  ;31c9   Advance position
    ld (lwrptr),hl          ;31ca   
    ld de,BF$LST-1          ;31cd   de=2789h *f*
    add hl,de               ;31d0
    pop de                  ;31d1
    pop af                  ;31d2
    push af                 ;31d3
    and 07fh                ;31d4   Reset bit 7
    ld (hl),a               ;31d6   .. store character
    pop af                  ;31d7
    pop hl                  ;31d8
    ret                     ;31d9
;*  
;*  Write buffer to list file
;*
lwrrec:                     ;       Init parameters
    ld de,BF$LST            ;31da     Point to list buffer
    ld hl,F$LST             ;31dd     Point to list file *f*
    ld a,LSTlen             ;31e0     Set length (a=4)
;*
;*  Write A records to file ^HL with buffer ^DE
;*
wrtrec:
    push af             ;31e2
    push bc             ;31e3
    push de             ;31e4
    push hl             ;31e5
    ld c,1ah            ;31e6   c=setdma (Set DMA address)
    call BDOS           ;31e8   Set disk buffer
    pop de              ;31eb
    push de             ;31ec
    ld c,15h            ;31ed   c=wrseq (Write next record)
    call BDOS           ;31ef   Write record
    or a                ;31f2   Test success
    jp nz,dskful        ;31f3   Nope, disk full
    pop de              ;31f6
    pop hl              ;31f7
    ld bc,reclng        ;31f8   bc=080h
    add hl,bc           ;31fb   Advance to next address
    ex de,hl            ;31fc
    pop bc              ;31fd
    pop af              ;31fe
    dec a               ;31ff   Count down
    jp nz,wrtrec        ;3200
    ld hl,00000h        ;3203   Return base position
    ret                 ;3206
;*
;*  Write buffer to REL file
;*
owrrec:                 ;       Init parameters:
    ld de,BF$OBJ        ;3207     Point to object buffer
    ld a,RELlen         ;320a     Set length (a=2)
    ld hl,F$OBJ         ;320c     Point to object file
    jp wrtrec           ;320f   Write buffer
;*
;*  Put byte to REL file
;*
oput:
    push af             ;3212   Save byte
    ld a,(enaOBJ)       ;3213   Test REL file enabled
    or a                ;3216
    jp z,l2df2h         ;3217   .. nope
    ld a,(F$OBJ)        ;321a   Test character device
    or a                ;321d
    jp m,outCON         ;321e   .. yeap, Put character to console
    ex (sp),hl          ;3221
    push hl             ;3222
    push de             ;3223
    ld hl,(owrptr)      ;3224   Get ut character to console
    ld a,h              ;3227
    dec a               ;3228   Test buffer filled
    call z,owrrec       ;3229   .. write buffer if so
    inc hl              ;322c
    ld (owrptr),hl      ;322d   Update pointer
    ld de,BF$OBJ-1      ;3230   de=2687h
    add hl,de           ;3233   Get address
    pop de              ;3234
    pop af              ;3235
    ld (hl),a           ;3236   Store byte
    pop hl              ;3237
    ret                 ;3238
;*
;*  Get character from source file
;*  Carry set indicates end of file
;*
sget:
    ld a,(F$SRC)            ;3239   Test char device
    inc a                   ;323c
    jp z,getchr             ;323d   0xFF is from console
    jp m,getio              ;3240   0xFE is from auxiliary device
    push hl                 ;3243
    push de                 ;3244
    ld hl,(rdptr)           ;3245   Get source buffer pointer
    ld a,h                  ;3248   Test buffer done
    cp HIGH(SRClen*reclng)  ;3249   2
    call z,rdrec            ;324b   .. yeap, read new record
    inc hl                  ;324e
    ld (rdptr),hl           ;324f   Update pointer
    ld de,BF$SRC-1          ;3252   de=298bh
    add hl,de               ;3255   Position buffer
    pop de                  ;3256
    jp l3048h               ;3257   Get character
;*
;*  Read buffer from source file
;*
rdrec:
    ld de,BF$SRC        ;325a   Point to buffer
    ld a,SRClen         ;325d   Get record count (a=4)
l325fh:         ;<--;
    push af         ;   ;325f
    push de         ;   ;3260
    push bc         ;   ;3261
    ld c,01ah       ;   ;3262   c=setdma (Set DMA address)
    call BDOS       ;   ;3264   Set buffer
    ld de,F$SRC     ;   ;3267   Point to source file
    ld c,014h       ;   ;326a   c=rdseq (read next record)
    call BDOS       ;   ;326c   Read from source file
    pop bc          ;   ;326f
    pop de          ;   ;3270
    dec a           ;   ;3271   Test end of file
    jp z,l3283h ;---)-; ;3272   Yeap
    ld hl,reclng    ; ; ;3275   hl=080h
    add hl,de       ; ; ;3278   Advance address
    ex de,hl        ; ; ;3279
    pop af          ; ; ;327a
    dec a           ; ; ;327b
    jp nz,l325fh ;--+ ; ;327c
l327fh:               ;
    ld hl,00000h ;<-; ; ;327f   Return zero position
    ret             ; ; ;3282
                    ; ;
l3283h:         ;<--)-+
    pop af          ;   ;3283
    ld a,eof        ;   ;3284   a=eof
    ld (de),a       ;   ;3286   Set end of file
    jp l327fh ;-----+   ;3287
;*
;*  0xFF is to console from lput
;*
outLST:
    pop af              ;328a   Get character
    push hl             ;328b
    push de             ;328c
    push bc             ;328d
    push af             ;328e
    ld c,5              ;328f   c=lstout (Printer output)
    and 07fh            ;3291   Clear high bit
    ld e,a              ;3293   Save character
    ld hl,PRNCol        ;3294   Point to printer column
    cp ' '              ;3297   Test printable
    jp nc,l32a8h ;--;   ;3299   Yeap
    sub cr          ;   ;329c   Test start of line
    jp z,l32a6h ;-; ;   ;329e   Yeap
    inc a         ; ;   ;32a1   Test form feed
    jp z,l32a6h ;-; ;   ;32a2   Yeap
    ld a,(hl)     ; ;   ;32a5   Get current column
l32a6h:       ;<--+ ;
    dec a           ;   ;32a6   Get previous column
    ld (hl),a       ;   ;32a7   Save
l32a8h:       ;<----+
    inc (hl)            ;32a8   Advance column
    ld a,e              ;32a9   Get character
    cp tab              ;32aa   Test tabulator
    jp nz,l32bdh ;----; ;32ac   Nope
l32afh:       ;<----; ;
      ld a,' '      ; ; ;32af
      call lput     ; ; ;32b1   Put ' ' to list device
      ld a,(hl)     ; ; ;32b4   Get position
      and 007h      ; ; ;32b5   Test tab stop 00000111b
    jp nz,l32afh ;--+ ; ;32b7   Nope
    jp l32c0h    ;-;  ; ;32ba   --> ...
                   ;  ;
l32bdh:      ;<----)--+
    call BDOS      ;    ;32bd   Put to printer
l32c0h:      ;<----+
    pop af              ;32c0
    pop bc              ;32c1
    pop de              ;32c2
    pop hl              ;32c3
    ret                 ;32c4
;*
;*  Get character from paper tape reader (auxiliary device)
;*
getio:
    push hl             ;32c5
    push de             ;32c6
    push bc             ;32c7
    ld c,3              ;32c8   c=rdr (Auxiliary (Reader) input)
    call BDOS           ;32ca   Get character
    pop bc              ;32cd
    pop de              ;32ce
    pop hl              ;32cf
    cp eof              ;32d0   Test end of file
    scf                 ;32d2   Set carry to indicate error
    ret z               ;32d3
    or a                ;32d4   Clear carry
    ret                 ;32d5
;*
;*  Print message disk full
;*
dskful:
    ld hl,l32f6h        ;32d6   'DISK '
    call PrString       ;32d9   Give error message
    pop de              ;32dc
    ld a,(de)           ;32dd   Get drive
    add a,'A'-1         ;32de   Make ASCII
    cp 'A'-1            ;32e0   Test default drive
    jp nz,l32e7h ;--;   ;32e2   Nope
    ld a,' '        ;   ;32e5   Print blank if default
l32e7h:         ;<--+
    call conout         ;32e7   Print drive
    ld hl,l32fch        ;32ea   ' FULL'
    call PrString       ;32ed   Give error message
    call n_line         ;32f0   Give new line
    jp 00000h           ;32f3   jp OS
;
l32f6h:
    db  'DISK ',null
l32fch:
    db  ' FULL',null

;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################

F$INC:  ds fcblen   ;       Include FCB
IncPtr: db 0        ;3323   Include file record pointer
IncAdr: dw 0        ;3324   Include file buffer address
BF$INC: ds reclng   ;3326   Include file buffer
;
;   Parsing include file name from ^DE
;
ParsName:
    push hl             ;33a6
    push de             ;33a7
    push bc             ;33a8
    ex de,hl            ;33a9
    ld hl,F$INC         ;33aa   Point to include file
    inc de              ;33ad   Skip possible drive
    ld a,(de)           ;33ae   Get next character
    dec de              ;33af
    cp ':'              ;33b0   Test drive delimiter
    ld a,0              ;33b2
    jp nz,l33c1h ;--;   ;33b4   if eq. ':' --> Set default disk
    ld a,(de)       ;   ;33b7   Get drive
    inc de          ;   ;33b8
    sub 'A'-1       ;   ;33b9   Make binary
    cp 'Z'+1-('A'-1);   ;33bb   Verify correct range (01bh)
    jp nc,l3425h ;--)-; ;33bd   Nope
    inc de          ; ; ;33c0
l33c1h:         ;<--+ ;
    ld (hl),a         ; ;33c1   Save drive
    inc hl            ; ;33c2
    ld b,8            ; ;33c3   Set length of file name
l33c5h:     ;<----;   ;
    ld a,(de)     ;   ; ;33c5   Get character
    inc de        ;   ; ;33c6
    ld (IncChr),a ;   ; ;33c7   Save it
    cp '.'        ;   ; ;33ca   Test extension delimiter
    jp z,l33ech ;-)-; ; ;33cc   if (IncChr).eq.'.' --> ...
    cp ' '+1      ; ; ; ;33cf   Test valid range
    jp c,l33ech ;-)-; ; ;33d1   Nope
    ld (hl),a     ; ; ; ;33d4   Unpack name
    inc hl        ; ; ; ;33d5
    dec b         ; ; ; ;33d6
    jp nz,l33c5h;-+ ; ; ;33d7
l33dah:      ;<---; ; ;
    ld a,(de)     ; ; ; ;33da   Get character
    inc de        ; ; ; ;33db
    ld (IncChr),a ; ; ; ;33dc   Save it
    cp '.'        ; ; ; ;33df   Test extension delimiter
    jp z,l33f3h   ; ; ; ;33e1   if (IncChr).eq.'.' --> ...
    cp ' '+1      ; ; ; ;33e4
    jp nc,l33dah;-+ ; ; ;33e6   Skip valid characters
    jp l33f3h       ; ; ;33e9   --> ...
                    ; ;
l33ech:         ;<--+ ;
    ld (hl),' '     ; ; ;33ec   Blank final name part
    inc hl          ; ; ;33ee
    dec b           ; ; ;33ef
    jp nz,l33ech ;--+ ; ;33f0
l33f3h:               ;
    ld b,3            ; ;33f3   Set length of extension
    ld a,(IncChr)     ; ;33f5   Get last character
    cp '.'            ; ;33f8   Test extension delimiter
    jp z,l3400h  ;--; ; ;33fa   if (IncChr).eq.'.' --> skip
    ld de,l0321h    ; ; ;33fd   Set default .FOR
l3400h:     ;<------; ;
    ld a,(de)       ; ; ;3400
    inc de          ; ; ;3401
    ld (hl),a       ; ; ;3402   Unpack extension
    inc hl          ; ; ;3403
    dec b           ; ; ;3404
    jp nz,l3400h ;--+ ; ;3405
    ld (hl),b         ; ;3408   Clear extent
    ld de,BF$INC      ; ;3409
    ld c,01ah         ; ;340c   c=setdma (Set DMA address)
    call BDOS         ; ;340e   Set include file buffer
    ld de,F$INC       ; ;3411
    ld c,0fh          ; ;3414   c=open (Open file)
    call BDOS         ; ;3416   Open include file
    cp 0ffh           ; ;3419   Test error
    jp z,l3425h ;---; ; ;341b   if error
    xor a           ; ; ;341e
    ld (F$INC+32),a ; ; ;341f   (03322h)=0 Clear current record
    ld (IncPtr),a   ; ; ;3422   (IncPtr)=0 Clear record pointer
l3425h:     ;<------+-+
    pop bc              ;3425
    pop de              ;3426
    pop hl              ;3427
    ret                 ;3428
;
;   Get character from include file
;
iget:
    push hl             ;3429
    push de             ;342a
    push bc             ;342b
    ld a,(IncPtr)       ;342c   Test any in buffer
    dec a               ;342f
    jp p,l3450h ;--;    ;3430   .. yeap
    ld de,BF$INC   ;    ;3433
    ld c,1ah       ;    ;3436   c=setdma (Set DMA address)
    call BDOS      ;    ;3438   Set include buffer
    ld de,F$INC    ;    ;343b
    ld c,14h       ;    ;343e   c=rdseq (read next record)
    call BDOS      ;    ;3440   Read from include file
    add a,0ffh     ;    ;3443
    jp c,l3465h  ;-)--; ;3445   .. end of file
    ld hl,BF$INC   ;  ; ;3448   Init address
    ld (IncAdr),hl ;  ; ;344b   .. Save save it
    ld a,reclng-1  ;  ; ;344e
l3450h:        ;<--+  ;
    ld (IncPtr),a     ; ;3450   Update record pointer
    ld hl,(IncAdr)    ; ;3453   Get buffer address
    ld a,(hl)         ; ;3456   Get character
    cp eof            ; ;3457   Test end of file
    jp nz,l3460h ;-;  ; ;3459   .. nope
    scf            ;  ; ;345c   Indicate it
    jp l3465h   ;--)--; ;345d
l3460h:     ;<-----+  ;
    inc hl            ; ;3460   Update address
    ld (IncAdr),hl    ; ;3461   save it
    or a              ; ;3464
l3465h:     ;<--------+
    pop bc              ;3465
    pop de              ;3466
    pop hl              ;3467
    ret                 ;3468
iclose:                 ;       Close include file (not implemented)
    ret                 ;3469

;#################
;# START MODULE  #
;#################

;#################
;# START MODULE  #
;#################
;
; Table Mnemonic
;
;     Opcode Mnemonic
OpcTab: ;     ;
    db  086h,'ADD',tab,0cdh         ;346a 'ADD M'
    db  0c6h,'ADI',.tab             ;3470 'ADI '
    db  0a2h,'ANA',tab,0c4h         ;3475 'ANA D'
    db  0a3h,'ANA',tab,0c5h         ;347b 'ANA E'
    db  0a6h,'ANA',tab,0cdh         ;3481 'ANA M'
    db  0e6h,'ANI',.tab             ;3487 'ANI '
    db  0cdh,'CALL',.tab            ;348c 'CALL '
    db  02fh,'CM',0c1h              ;3492 'CMA'
    db  03fh,'CM',0c3h              ;3496 'CMC'
    db  0b8h,'CMP',tab,0c2h         ;349a 'CMP B'
    db  0beh,'CMP',tab,0cdh         ;34a0 'CMP M'
    db  0feh,'CPI',.tab             ;34a6 'CPI '
    db  019h,'DAD',tab,0c4h         ;34ab 'DAD D'
    db  029h,'DAD',tab,0c8h         ;34b1 'DAD H'
    db  02bh,'DCX',tab,0c8h         ;34b7 'DCX H'
    db  03dh,'DCR',tab,0c1h         ;34bd 'DCR A'
    db  03ch,'INR',tab,0c1h         ;34c3 'INR A'
    db  023h,'INX',tab,0c8h         ;34c9 'INX H'
    db  0dah,'JC',.tab              ;34cf 'JC '
    db  0e2h,'JPO',.tab             ;34d3 'JPO '
    db  0eah,'JPE',.tab             ;34d8 'JPE '
    db  0fah,'JM',.tab              ;34dd 'JM '
    db  0c3h,'JMP',.tab             ;34e1 'JMP '
    db  0d2h,'JNC',.tab             ;34e6 'JNC '
    db  0c2h,'JNZ',.tab             ;34eb 'JNZ '
    db  0f2h,'JP',.tab              ;34f0 'JP '
    db  0cah,'JZ',.tab              ;34f4 'JZ '
    db  03ah,'LDA',.tab             ;34f8 'LDA '
    db  001h,'LXI',tab,'B',0ach     ;34fd 'LXI B,'
    db  02ah,'LHLD',.tab            ;3504 'LHLD '
    db  011h,'LXI',tab,'D',0ach     ;350a 'LXI D,'
    db  021h,'LXI',tab,'H',0ach     ;3511 'LXI H,'
    db  0b7h,'ORA',tab,0c1h         ;3518 'ORA A'
    db  0b2h,'ORA',tab,0c4h         ;351e 'ORA D'
    db  0b3h,'ORA',tab,0c5h         ;3524 'ORA E'
    db  0f6h,'ORI',.tab             ;352a 'ORI '
    db  07ah,'MOV',tab,'A,',0c4h    ;352f 'MOV A,D'
    db  07bh,'MOV',tab,'A,',0c5h    ;3537 'MOV A,E'
    db  07dh,'MOV',tab,'A,',0cch    ;353f 'MOV A,L'
    db  07eh,'MOV',tab,'A,',0cdh    ;3547 'MOV A,M'
    db  07ch,'MOV',tab,'A,',0c8h    ;354f 'MOV A,H'
    db  078h,'MOV',tab,'A,',0c2h    ;3557 'MOV A,B'
    db  047h,'MOV',tab,'B,',0c1h    ;355f 'MOV B,A'
    db  044h,'MOV',tab,'B,',0c8h    ;3567 'MOV B,H'
    db  04dh,'MOV',tab,'C,',0cch    ;356f 'MOV C,L'
    db  054h,'MOV',tab,'D,',0c8h    ;3577 'MOV D,H'
    db  05dh,'MOV',tab,'E,',0cch    ;357f 'MOV E,L'
    db  067h,'MOV',tab,'H,',0c1h    ;3587 'MOV H,A'
    db  060h,'MOV',tab,'H,',0c2h    ;358f 'MOV H,B'
    db  065h,'MOV',tab,'H,',0cch    ;3597 'MOV H,L'
    db  066h,'MOV',tab,'H,',0cdh    ;359f 'MOV H,M'
    db  069h,'MOV',tab,'L,',0c3h    ;35a7 'MOV L,C'
    db  06fh,'MOV',tab,'L,',0c1h    ;35af 'MOV L,A'
    db  06bh,'MOV',tab,'L,',0c5h    ;35b7 'MOV L,E'
    db  06ch,'MOV',tab,'L,',0c8h    ;35bf 'MOV L,H'
    db  077h,'MOV',tab,'M,',0c1h    ;35c7 'MOV M,A'
    db  072h,'MOV',tab,'M,',0c4h    ;35cf 'MOV M,D'
    db  073h,'MOV',tab,'M,',0c5h    ;35d7 'MOV M,E'
    db  03eh,'MVI',tab,'A',0ach     ;35df 'MVI A,'
    db  02eh,'MVI',tab,'L',0ach     ;35e6 'MVI L,'
    db  0b4h,'ORA',tab,0c8h         ;35ed 'ORA H'
    db  0b5h,'ORA',tab,0cch         ;35f3 'ORA L'
    db  0b6h,'ORA',tab,0cdh         ;35f9 'ORA M'
    db  0e9h,'PCH',0cch             ;35ff 'PCHL'
    db  0e1h,'POP',tab,0c8h         ;3604 'POP H'
    db  0e5h,'PUSH',tab,0c8h        ;360a 'PUSH H'
    db  017h,'RA',0cch              ;3611 'RAL'
    db  01fh,'RA',0d2h              ;3615 'RAR'
    db  0c9h,'RE',0d4h              ;3619 'RET'
    db  007h,'RL',0c3h              ;361d 'RLC'
    db  09fh,'SBB',tab,0c1h         ;3621 'SBB A'
    db  09ah,'SBB',tab,0c4h         ;3627 'SBB D'
    db  09ch,'SBB',tab,0c8h         ;362d 'SBB H'
    db  09eh,'SBI',.tab             ;3633 'SBI '
    db  022h,'SHLD',.tab            ;3638 'SHLD '
    db  032h,'STA',.tab             ;363e 'STA '
    db  098h,'SUB',tab,0c2h         ;3643 'SUB B'
    db  093h,'SUB',tab,0c5h         ;3649 'SUB E'
    db  095h,'SUB',tab,0cch         ;364f 'SUB L'
    db  096h,'SUB',tab,0cdh         ;3655 'SUB M'
    db  0d6h,'SUI',.tab             ;365b 'SUI '
    db  0ebh,'XCH',0c7h             ;3660 'XCH'
    db  0afh,'XRA',tab,0c1h         ;3665 'XRA A'
    db  0aah,'XRA',tab,0c4h         ;366b 'XRA D'
    db  0abh,'XRA',tab,0c5h         ;3671 'XRA E'
    db  0aeh,'XRA',tab,0cdh         ;3677 'XRA M'
    db  0eeh,'XRI',089h             ;367d 'XRI '

;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################
;*
;*  'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
;*
s_3682h:
    push bc             ;3682
    ld a,06fh           ;3683   'LD L,A'
    call PutOpc         ;3685
    ld a,017h           ;3688   'RLA'
    call PutOpc         ;368a
    ld a,09fh           ;368d   'SBC A,A'
    call PutOpc         ;368f
    ld a,067h           ;3692   'LD H,A'
    call PutOpc         ;3694
    xor a               ;3697   a=0
    pop bc              ;3698
    ret                 ;3699   
;*
;*
;*
s_369ah:
    call s_5609h            ;369a   cd 09 56
    ld hl,(l01aeh)          ;369d   hl=(l01aeh)
    call ExtAttr            ;36a0   Extract Attributes from the symbol table
    call s_3ecch            ;36a3   cd cc 3e
    ld a,(TypeID)           ;36a6
    cp 2                    ;36a9
    jp z,l3765h  ;------;   ;36ab   if (TypeID).eq.2 (BYTE) --> ...
    ld hl,(l01a8h)      ;   ;36ae   hl=(l01a8h)
    call ExtAttr        ;   ;36b1   Extract Attributes from the symbol table
    xor a               ;   ;36b4
    ld (TypeID),a       ;   ;36b5   (TypeID)=0 (INTEGER)
    ld a,1              ;   ;36b8   a=1
    call s_3a2ah        ;   ;36ba   cd 2a 3a
    ld hl,(l01a6h)      ;   ;36bd   hl=(l01a6h)
    call ExtAttr        ;   ;36c0   Extract Attributes from the symbol table
    dec a               ;   ;36c3
    jp nz,l36eah ;--;   ;   ;36c4   if (KindID).ne.1 (Constant) --> ...
    ld a,03eh       ;   ;   ;36c7   'LD A,byte'
    call PutOpc     ;   ;   ;36c9
    ld a,(l01d6h)   ;   ;   ;36cc   a=(l01d6h)
    call p.byte     ;   ;   ;36cf   Put byte in reg A to REL file
    ld a,095h       ;   ;   ;36d2   'SUB L'
    call PutOpc     ;   ;   ;36d4
    ld a,03eh       ;   ;   ;36d7   'LD A,byte'
    call PutOpc     ;   ;   ;36d9
    ld a,(l01d7h)   ;   ;   ;36dc   a=(l01d7h)
    call p.byte     ;   ;   ;36df   Put byte in reg A to REL file
    ld a,09ch       ;   ;   ;36e2   'SBC A,H'
    call PutOpc     ;   ;   ;36e4
    jp l3712h   ;---)-; ;   ;36e7   --> ...
                    ; ; ;
l36eah:         ;<--+ ; ;
    ld a,0ebh         ; ;   ;36ea   'EX DE,HL'
    call PutOpc       ; ;   ;36ec
    call s_3ecch      ; ;   ;36ef   cd cc 3e
    ld a,(i_Type)     ; ;   ;36f2
    or a              ; ;   ;36f5
    call nz,s_3682h   ; ;   ;36f6   if (i_Type).eq.0 (INTEGER) 'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld a,0ebh         ; ;   ;36f9   'EX DE,HL'
    call PutOpc       ; ;   ;36fb
    ld a,07bh         ; ;   ;36fe   'LD A,E'
    call PutOpc       ; ;   ;3700
    ld a,095h         ; ;   ;3703   'SUB L'
    call PutOpc       ; ;   ;3705
    ld a,07ah         ; ;   ;3708   'LD A,D'
    call PutOpc       ; ;   ;370a
    ld a,09ch         ; ;   ;370d   'SBC A,H'
    call PutOpc       ; ;   ;370f
l3712h:         ;<----; ;
    ld a,0f2h         ; ;   ;3712   'JP P,word'
l3714h:      ;<-------)-)-;
    push af           ; ; ; ;3714 \ Save opcode ------------;
    ld hl,(l01aah)    ; ; ; ;3715                           ;
    ld (DataID),hl    ; ; ; ;3718   (DataID)=(l01aah)       ;
    ld a,2            ; ; ; ;371b                           ;
    ld (ScopeID),a    ; ; ; ;371d   (ScopeID)=2             ;
    dec a             ; ; ; ;3720                           ;
    ld (KindID),a     ; ; ; ;3721   (KindID)=1 (Constant)   ;
    ld hl,0ffffh      ; ; ; ;3724   21 ff ff                ;
    pop af            ; ; ; ;3727 / Restore opcode <--------+
    call s_3fa6h      ; ; ; ;3728   cd a6 3f
    ld hl,(l01a4h)    ; ; ; ;372b
    ex de,hl          ; ; ; ;372e
    ld hl,(HeapPtr)   ; ; ; ;372f
    call subHL.DE     ; ; ; ;3732   hl=hl-de
    ld b,h            ; ; ; ;3735
    ld c,l            ; ; ; ;3736 \ bc=(HeapPtr)-(l01a4h)
    push de           ; ; ; ;3737   Save (l01a4h)      -----+
    ld hl,-10         ; ; ; ;3738                           ;
    push hl           ; ; ; ;373b \ Save -10                ;
    add hl,de         ; ; ; ;373c                           ;
    ld (l01a4h),hl    ; ; ; ;373d   (l01a4h)=(l01a4h)-10    ;
    pop de            ; ; ; ;3740 / Restore -10             ;
    push hl           ; ; ; ;3741 \ Save (l01a4h)      ---+ ;
    ld hl,(l0217h)    ; ; ; ;3742                         ; ;
    add hl,de         ; ; ; ;3745                         ; ;
    ld (l0217h),hl    ; ; ; ;3746   (l0217h)=(l0217h)-10  ; ;
    pop hl            ; ; ; ;3749 / hl=(l01a4h)-10     <--+ ;
    pop de            ; ; ; ;374a / de=(l01a4h)        <----+
;                     ; ; ;         bc=(HeapPtr)-(l01a4h)
    ld a,b            ; ; ; ;374b
    or c              ; ; ; ;374c
    jp z,l375bh  ;--; ; ; ; ;374d   if (HeapPtr)-(l01a4h).eq.0 --> ...
l3750h:      ;<---; ; ; ; ;
      ld a,(de)   ; ; ; ; ; ;3750
      ld (hl),a   ; ; ; ; ; ;3751   (hl)=(de)
      inc hl      ; ; ; ; ; ;3752   hl=hl+1
      inc de      ; ; ; ; ; ;3753   de=de+1
      dec bc      ; ; ; ; ; ;3754   bc=bc-1
      ld a,b      ; ; ; ; ; ;3755
      or c        ; ; ; ; ; ;3756
    jp nz,l3750h;-+ ; ; ; ; ;3757   if bc.ne.0 --> ...
    ex de,hl        ; ; ; ; ;375a   eb
l375bh:         ;<--+ ; ; ;
    ld (HeapPtr),hl   ; ; ; ;375b   (HeapPtr)=
l375eh:               ; ; ;
    ld hl,00000h      ; ; ; ;375e
    ld (l0251h),hl    ; ; ; ;3761   (l0251h)=0
    ret               ; ; ; ;3764
                      ; ; ;
l3765h:         ;<----)-+ ;
    ld hl,(l01a6h)    ;   ; ;3765   hl=(l01a6h)
    call ExtAttr      ;   ; ;3768   Extract Attributes from the symbol table
    ld a,(KindID)     ;   ; ;376b
    dec a             ;   ; ;376e
    push af           ;   ; ;376f \ Save value ------------------------------;
    ld hl,(l01a8h)    ;   ; ;3770   hl=(l01a8h)                              ;
    call ExtAttr      ;   ; ;3773   Extract Attributes from the symbol table ;
    ld a,2            ;   ; ;3776   a=2                                      ;
    ld (TypeID),a     ;   ; ;3778   (TypeID)=2 (BYTE)                        ;
    pop af            ;   ; ;377b / Restore value <--------------------------+
    jp nz,l379bh ;--; ;   ; ;377c   if (KindID).ne.1 (Constant) --> ...
    ld a,1          ; ;   ; ;377f   a=1
    call s_3a2ah    ; ;   ; ;3781   cd 2a 3a
    ld a,0feh       ; ;   ; ;3784   'CP byte'
    call PutOpc     ; ;   ; ;3786
    ld hl,(l01a6h)  ; ;   ; ;3789   hl=(l01a6h)
    call ExtAttr    ; ;   ; ;378c   Extract Attributes from the symbol table
    ld a,(l01d6h)   ; ;   ; ;378f
    inc a           ; ;   ; ;3792   a=(l01d6h)+1
    call p.byte     ; ;   ; ;3793   Put byte in reg A to REL file
    ld a,0fah       ; ;   ; ;3796   'JP M,word'
    jp l3714h    ;--)-)---; ;3798   --> ...
                    ; ;   ;
l379bh:      ;<-----+ ;   ;
    ld a,(KindID)     ;   ; ;379b
    dec a             ;   ; ;379e
    jp z,l37c7h ;---; ;   ; ;379f   if (KindID).eq.1 (Constant) --> ...
l37a2h:       ;<--; ; ;   ;
    ld a,1        ; ; ;   ; ;37a2   a=1
    call s_3a2ah  ; ; ;   ; ;37a4   cd 2a 3a
    ld a,047h     ; ; ;   ; ;37a7   'LD B,A'
    call PutOpc   ; ; ;   ; ;37a9
    ld hl,(l01a6h); ; ;   ; ;37ac   hl=(l01a6h)
    call ExtAttr  ; ; ;   ; ;37af   Extract Attributes from the symbol table
    ld a,2        ; ; ;   ; ;37b2   a=2
    ld (TypeID),a ; ; ;   ; ;37b4   (TypeID)=2 (BYTE)
    call s_3ecch  ; ; ;   ; ;37b7   cd cc 3e
    ld a,0b8h     ; ; ;   ; ;37ba   'CP B'
    call PutOpc   ; ; ;   ; ;37bc
    ld a,078h     ; ; ;   ; ;37bf   'LD A,B'
    call PutOpc   ; ; ;   ; ;37c1
    jp l3712h   ;-)-)-+   ; ;37c4   --> ...
                  ; ;     ;
l37c7h:     ;<----)-+     ;
    ld a,(l01d6h) ;       ; ;37c7
    dec a         ;       ; ;37ca
    jp nz,l37a2h;-+       ; ;37cb   if (l01d6h).ne.1 --> ...
    ld hl,(l01a6h)        ; ;37ce   hl=(l01a6h)
    call ExtAttr          ; ;37d1   Extract Attributes from the symbol table
    call s_3f9bh          ; ;37d4   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    ld a,0beh             ; ;37d7   'CP (HL)'
    call PutOpc           ; ;37d9
    ld hl,(l01a8h)        ; ;37dc   hl=(l01a8h)
    call ExtAttr          ; ;37df   Extract Attributes from the symbol table
    ld a,2                ; ;37e2   a=2
    ld (TypeID),a         ; ;37e4   (TypeID)=2 (BYTE)
    dec a                 ; ;37e7   a=1
    call s_3a2ah          ; ;37e8   cd 2a 3a
    ld a,0dah             ; ;37eb   3e da
    jp l3714h   ;---------+ ;37ed   --> ...
;*
;*  Processing GOTO
;*
PrGoto:
    call s_14dbh        ;37f0   g_n_chr; (l0173h)=chr
    ld hl,00000h        ;37f3   hl=0
    ld (l01cfh),hl      ;37f6   (l01cfh)=0
    jp p,l3822h   ;---; ;37f9   if chr Special character or Letter --> ...ASSIGNED GO TO
    call s_41f7h      ; ;37fc   cd f7 41
    call s_21aeh      ; ;37ff   Processing label & Test (TypeID).eq.INTEGER
    ld a,(l0222h)     ; ;3802
    or a              ; ;3805
    jp nz,l3818h ;--; ; ;3806   if (l0222h).ne.0 --> ...
    ld hl,(l01cfh)  ; ; ;3809
    ld (l020fh),hl  ; ; ;380c   (l020fh)=(l01cfh)
    ld (l0211h),hl  ; ; ;380f   (l0211h)=(l01cfh)
    ld (l0213h),hl  ; ; ;3812   (l0213h)=(l01cfh)
    jp l25bch       ; ; ;3815   --> Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement
                    ; ;
l3818h:         ;<--+ ;
    call s_4137h      ; ;3818   cd 37 41
    xor a             ; ;381b
    ld (l0222h),a     ; ;381c   (l0222h)=0
    jp l09ebh         ; ;381f   Clear (l029ah) & (DO_Flg) -> Ending parsing
                      ;
; ...ASSIGNED GO TO   ;
                      ;
l3822h:         ;<----+
    push af             ;3822 \ Save chr
    ld a,(l0222h)       ;3823
    or a                ;3826
    jp z,l3835h ;-;     ;3827   if (l0222h).eq.0 --> ...
    call s_41f7h  ;     ;382a   cd f7 41
    call s_47b3h  ;     ;382d   cd b3 47
    ld a,0cah     ;     ;3830   'JP Z,word'
    call s_485bh  ;     ;3832   cd 5b 48
l3835h:     ;<----+
    pop af              ;3835 / f1
    jp nz,l385eh;-;     ;3836   c2 5e 38
    call s_2598h  ;     ;3839   Processing integer constant with error checking & Test (KindID).ne.1
    call s_1479h  ;     ;383c   cd 79 14
    call s_41f7h  ;     ;383f   cd f7 41
    ld a,0e9h     ;     ;3842   'JP (HL)'
    call PutOpc   ;     ;3844
    ld a,1        ;     ;3847
    ld (l0276h),a ;     ;3849   (l0276h)=1
    ld a,(l0299h) ;     ;384c
    cp ','        ;     ;384f
    jp z,l386ch ;-)-;   ;3851   if (l0299h).eq.',' --> ...
l3854h:   ;<------)-)-;
    ld a,(l0222h) ; ; ; ;3854
    or a          ; ; ; ;3857   if (l0222h).eq.0 {
    jp z,l25bch   ; ; ; ;3858    --> Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement}
    jp l09ebh     ; ; ; ;385b   Clear (l029ah) & (DO_Flg) -> Ending parsing
                  ; ; ;
l385eh:     ;<----+ ; ;
    call s_41f7h    ; ; ;385e   cd f7 41
    xor a           ; ; ;3861
    ld (l0276h),a   ; ; ;3862   (l0276h)=0
    ld h,a          ; ; ;3865
    ld l,a          ; ; ;3866   hl=0
    add hl,sp       ; ; ;3867   hl=SP 
    ld (l0290h),hl  ; ; ;3868   (l0290h)=SP
    push af         ; ; ;386b \ Save a
l386ch:     ;<------+ ;
    call g_n_chr      ; ;386c   Get next character 
    ld a,'('          ; ;386f   a='('
    call ch.chr       ; ;3871   Check character (a character for check)
l3874h:        ;<---; ;
    call s_21aeh    ; ; ;3874   Processing label & Test (TypeID).eq.INTEGER
    ld a,(l0276h)   ; ; ;3877
    or a            ; ; ;387a
    jp nz,l388ch;-; ; ; ;387b   if (l0276h).ne.0 --> ...
    call ChkStack ; ; ; ;387e   Check the stack
    ld hl,(l01cfh); ; ; ;3881   2a cf 01
    ex (sp),hl    ; ; ; ;3884   e3
    inc h         ; ; ; ;3885   24
    xor a         ; ; ; ;3886   a=0
    or h          ; ; ; ;3887   b4
    jp z,err_126  ; ; ; ;3888   if eq 0 --> Error (126) Illegal Character for Syntax
    push hl       ; ; ; ;388b \ e5
l388ch:    ;<-----+ ; ;
    ld a,(l0299h)   ; ; ;388c
    cp ','          ; ; ;388f
    jp z,l3874h ;---+ ; ;3891   if (l0299h).eq.',' --> ...
    call s_5cdeh      ; ;3894   cd de 5c
    ld a,(l0276h)     ; ;3897
    or a              ; ;389a
    jp nz,l3854h ;----+ ;389b   if (l0276h).ne.0 --> ...
    call ChComma        ;389e   Check ','
    call s_258bh        ;38a1   cd 8b 25
    call s_3ecch        ;38a4   cd cc 3e
    ld a,(i_Type)       ;38a7
    or a                ;38aa
    jp z,l38b4h ;-;     ;38ab   if (i_Type).eq.0 --> ...
    call s_3682h  ;     ;38ae   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (i_Type),a ;     ;38b1   (i_Type)=a
l38b4h:     ;<----+
    ld bc,'CG'          ;38b4   $CG
    call CrBuilt        ;38b7   Creating built-in routine
;
;   (hl)=index value, other parameters
;   are passed inline: no. of labels - 1 byte
;   addres of lavel 1 -- 2 bytes
;   addres of lavel 2 -- 2 bytes
;   ...
;   addres of lavel n -- 2 bytes
;
    ld a,(NoCode)       ;38ba
    or a                ;38bd   Test /N
    jp nz,l38d0h;-;     ;38be   if (NoCode).ne.0  --> skip output
    call s_5dcbh  ;     ;38c1   if (Column).ne.0 Put cr lf to console
    call s_146ch  ;     ;38c4   Print *****
    call s_501bh  ;     ;38c7   Put addres DATA' to console
    ld hl,l391fh  ;     ;38ca   hl="DB"
    call PrStrg   ;     ;38cd   Print string
l38d0h:     ;<----+
    pop af              ;38d0 / f1
    push af             ;38d1 \ f5
    call p.byte         ;38d2   Put byte in reg A to REL file
    ld hl,(l0290h)      ;38d5   2a 90 02
    dec hl              ;38d8   2b  +
l38d9h:         ;<----;
    ld d,(hl)         ; ;38d9   56
    dec hl            ; ;38da   2b
    ld e,(hl)         ; ;38db   5e
    dec hl            ; ;38dc   2b
    ex (sp),hl        ; ;38dd   e3
    push hl           ; ;38de \ e5
    ex de,hl          ; ;38df   eb
    call ExtAttr      ; ;38e0   Extract Attributes from the symbol table
    ld a,(NoCode)     ; ;38e3
    or a              ; ;38e6   Test /N
    jp nz,l38fch ;--; ; ;38e7   if (NoCode).ne.0  --> skip output
    call s_5dcbh    ; ; ;38ea   if (Column).ne.0 Put cr lf to console
    call s_146ch    ; ; ;38ed   Print *****
    call s_501bh    ; ; ;38f0   Put addres DATA' to console
    ld hl,l391ch    ; ; ;38f3   hl="DW"
    call PrStrg     ; ; ;38f6   Print string
    call s_5093h    ; ; ;38f9   cd 93 50
l38fch:         ;<--+ ;
    call s_3fc7h      ; ;38fc   cd c7 3f
    pop af            ; ;38ff / f1
    dec a             ; ;3900   3d
    ld h,a            ; ;3901   67
    ex (sp),hl        ; ;3902   e3
    jp nz,l38d9h  ;---+ ;3903   c2 d9 38
    ld hl,(l0290h)      ;3906   2a 90 02
    ld sp,hl            ;3909   Set for stack
    ld a,(l0222h)       ;390a
    or a                ;390d
    jp nz,l09ebh        ;390e   if (l0222h).ne.0 --> Clear (l029ah) & (DO_Flg) -> Ending parsing
    ld (l029ah),a       ;3911   (l029ah)=0
    inc a               ;3914   a=1 (DO_Flg)
    jp l25c1h           ;3915   --> Save (DO_Flg) -> Ending parsing statement
;
err_126:
    call err.msg        ;3918   Error (126)
    db 126              ;391b   Illegal Character for Syntax
;
l391ch:
    db tab              ;391c
    dc 'DW'             ;391d
;
l391fh:
    db tab,'DB',.tab    ;391f
;*
;*
;*
s_3923h:
    ld hl,(l020fh)          ;3923                               hl=(l020fh)
    ld a,h                  ;3926
    or l                    ;3927
    ret z                   ;3928   if(l020fh).eq.0 Return
    ex de,hl                ;3929                                           de=(l020fh)
    ld hl,(l0211h)          ;392a                               hl=(l0211h)
    call cmpHL.DE           ;392d
    jp nz,l395dh  ;---;     ;3930   if (l0211h).ne.(l020fh) --> ...
    ld hl,(l0213h)    ;     ;3933                               hl=(l0213h)
    call cmpHL.DE     ;     ;3936
    jp z,l3950h   ;-; ;     ;3939   if (l0213h).ne.(l020fh) --> ...
    ld (l020fh),hl  ; ;     ;393c   (l020fh)=(l0213h)
    ex de,hl        ; ;     ;393f                               hl=(l020fh) de=(l0213h)
    ld (l0213h),hl  ; ;     ;3940   (l0213h)=old value(l020fh)
    ld a,02fh       ; ;     ;3943   'CPL'
    call PutOpc     ; ;     ;3945
    ld a,03ch       ; ;     ;3948   'INC A'
    call PutOpc     ; ;     ;394a
    jp l3998h   ;---)-)-;   ;394d   --> ...
                    ; ; ;
l3950h:       ;<----+ ; ;
    ld hl,(l0264h)    ; ;   ;3950                               hl=(l0264h) de=(l020fh)
    call cmpHL.DE     ; ;   ;3953
    ret z             ; ;   ;3956   if (l0264h).eq.(l020fh) Return
    ex de,hl          ; ;   ;3957                               hl=(l020fh) de=(l0264h)
l3958h:    ;<---------)-)-;
    ld a,0c3h         ; ; ; ;3958   'JP word'
    jp s_3fa6h        ; ; ; ;395a   --> ...
                      ; ; ;
l395dh:         ;<----+ ; ;
    ld hl,(l0213h)      ; ; ;395d                               hl=(l0213h) de=(l020fh)
    call cmpHL.DE       ; ; ;3960
    jp nz,l398eh  ;---; ; ; ;3963   if (l0213h).ne.(l020fh) --> ...
    ld hl,(l0264h)    ; ; ; ;3966                               hl=(l0264h)
    ex de,hl          ; ; ; ;3969                               hl=(l020fh) de=(l0264h)
    ld hl,(l0211h)    ; ; ; ;396a                               hl=(l0211h)
    call cmpHL.DE     ; ; ; ;396d
    jp nz,l397bh ;--; ; ; ; ;3970   if (l0211h).ne.(l0264h) --> ...
    ld hl,(l020fh)  ; ; ; ; ;3973                               hl=(l020fh)
    ld a,0c2h       ; ; ; ; ;3976   'JP NZ,word'
    jp s_3fa6h      ; ; ; ; ;3978   --> ...
                    ; ; ; ;
l397bh:       ;<----+ ; ; ;
    ld a,0cah         ; ; ; ;397b   'JP Z,word'
    call s_3fa6h      ; ; ; ;397d   cd a6 3f
    ld hl,(l0264h)    ; ; ; ;3980                               hl=(l0264h)
    ex de,hl          ; ; ; ;3983                                           de=(l0264h)
    ld hl,(l020fh)    ; ; ; ;3984                               hl=(l020fh)
    call cmpHL.DE     ; ; ; ;3987
    ret z             ; ; ; ;398a   if (l020fh).eq.(l0264h) Return
    jp l3958h   ;-----)-)-; ;398b   --> ...
                      ; ; ;
l398eh:         ;<----+ ; ;                                     hl=(l0213h) de=(l020fh)
    ex de,hl            ; ; ;398e                               hl=(l020fh) de=(l0213h)
    ld hl,(l0211h)      ; ; ;398f                               hl=(l0211h)
    call cmpHL.DE       ; ; ;3992
    jp nz,l39c3h  ;---; ; ; ;3995   if (l0211h).ne.(l0213h) --> ...
l3998h:         ;<----)-+ ;
    ld hl,(l0264h)    ;   ; ;3998                               hl=(l0264h) de=(l0213h)
    ex de,hl          ;   ; ;399b                               hl=(l0213h) de=(l0264h)
    ld hl,(l020fh)    ;   ; ;399c                               hl=(l020fh)
    call cmpHL.DE     ;   ; ;399f
    jp nz,l39adh  ;-; ;   ; ;39a2   if (l020fh).ne.(l0264h) --> ...
    ld hl,(l0211h)  ; ;   ; ;39a5                               hl=(l0211h)
l39a8h:         ;<--)-)-; ;
    ld a,0f2h       ; ; ; ; ;39a8   'JP P,word'
    jp s_3fa6h      ; ; ; ; ;39aa   --> ...
                    ; ; ; ;
l39adh:       ;<----+ ; ; ;
    ld a,0fah         ; ; ; ;39ad   'JP M,word'
    call s_3fa6h      ; ; ; ;39af   cd a6 3f
    ld hl,(l0264h)    ; ; ; ;39b2                               hl=(l0264h)
    ex de,hl          ; ; ; ;39b5                                           de=(l0264h)
    ld hl,(l0211h)    ; ; ; ;39b6                               hl=(l0211h)
    call cmpHL.DE     ; ; ; ;39b9
    ret z             ; ; ; ;39bc   if (l0211h).eq.(l0264h) Return
    ld (l020fh),hl    ; ; ; ;39bd   (l020fh)=(l0211h)
    jp l3958h   ;-----)-)-+ ;39c0   --> ...
                      ; ;
l39c3h:           ;<--+ ;
    ld hl,(l0264h)      ;   ;39c3                               hl=(l0264h)
    ex de,hl            ;   ;39c6                                           de=(l0264h)
    ld hl,(l020fh)      ;   ;39c7                               hl=(l020fh)
    call cmpHL.DE       ;   ;39ca
    jp nz,l39deh ;--;   ;   ;39cd   if (l020fh).ne.(l0264h) --> ...
l39d0h:       ;<----)-; ;
    ld hl,(l0211h)  ; ; ;   ;39d0                               hl=(l0211h)
    ld a,0cah       ; ; ;   ;39d3   'JP Z,word'
    call s_3fa6h    ; ; ;   ;39d5   cd a6 3f
    ld hl,(l0213h)  ; ; ;   ;39d8                               hl=(l0213h)
    jp l39a8h   ;---)-)-+   ;39db   --> ...
                    ; ;
l39deh:       ;<----+ ;
    ld a,0fah         ;     ;39de   'JP M,word'
    call s_3fa6h      ;     ;39e0   cd a6 3f
    ld hl,(l0264h)    ;     ;39e3                               hl=(l0264h)
    ex de,hl          ;     ;39e6                                           de=(l0264h)
    ld hl,(l0211h)    ;     ;39e7                               hl=(l0211h)
    call cmpHL.DE     ;     ;39ea
    jp nz,l39f8h ;--; ;     ;39ed   if (l0211h).ne.(l0264h) --> ...
    ld hl,(l0213h)  ; ;     ;39f0                               hl=(l0213h)
    ld a,0c2h       ; ;     ;39f3   'JP NZ,word'
    jp s_3fa6h      ; ;     ;39f5   --> ...
                    ; ;
l39f8h:       ;<----+ ;                                         hl=(l0211h) de=(l0264h)
    ld hl,(l0213h)    ;     ;39f8                               hl=(l0213h)
    call cmpHL.DE     ;     ;39fb
    jp nz,l39d0h   ;--+     ;39fe   if (l0213h).ne.(l0264h) --> ...
    ld hl,(l0211h)          ;3a01                               hl=(l0211h)
    ld a,0cah               ;3a04   'JP Z,word'
    jp s_3fa6h              ;3a06   --> ...
;
l3a09h:
    ld a,0afh               ;3a09   'XOR A'
    call PutOpc             ;3a0b
    ld a,095h               ;3a0e   'SUB L'
    call PutOpc             ;3a10
    ld a,06fh               ;3a13   'LD L,A'
    call PutOpc             ;3a15
    ld a,09ch               ;3a18   'SBC A,H'
    call PutOpc             ;3a1a
    ld a,095h               ;3a1d   'SUB L'
    call PutOpc             ;3a1f
    ld a,067h               ;3a22   'LD H,A'
    call PutOpc             ;3a24
    jp l375eh               ;3a27   --> (l0251h)=0 ret
;
;   ENTRY
;     Reg a - Arithmetic operator:
;      0 - ?
;      1 - Addition
;      2 - Multiplication
;      3 - Subtraction
;      4 - Division
;        - Exponentiation
;      7 - ?
;
s_3a2ah:
    or a                    ;3a2a
    jp z,s_3ecch            ;3a2b   if par.eq.0 --> ...
    cp 7                    ;3a2e
    jp nc,l3d47h            ;3a30   if par >= 7 --> ...
    ld b,a                  ;3a33   Save par
    ld a,(KindID)           ;3a34
    dec a                   ;3a37
    jp nz,l3c91h            ;3a38   if (KindID).ne.1 (Constant)  --> ...
    ld a,(TypeID)           ;3a3b
    dec a                   ;3a3e
    jp z,l3bb1h             ;3a3f   if (TypeID).eq.1 (REAL)      --> ...
    cp 2                    ;3a42
    jp z,l3b86h             ;3a44   if (TypeID).eq.3 (DOUBLE)    --> ...
    cp 3                    ;3a47
    jp z,l3c91h             ;3a49   if (TypeID).eq.4 (INTEGER*4) --> ...
    ld a,(i_Type)           ;3a4c
    dec a                   ;3a4f
    jp z,l3bfch             ;3a50   if (i_Type).eq.1 (REAL)      --> ...
    cp 2                    ;3a53
    jp z,l3bfch             ;3a55   if (i_Type).eq.3 (DOUBLE)    --> ...
    cp 3                    ;3a58
    jp z,l3bfch             ;3a5a   if (i_Type).eq.4 (INTEGER*4) --> ...
    dec a                   ;3a5d
    jp z,l3ab8h  ;--------; ;3a5e   if (i_Type).eq.2 (BYTE)      --> ...
    xor a                 ; ;3a61
    ld (TypeID),a         ; ;3a62   (TypeID)=0 (INTEGER)
    ld a,b                ; ;3a65   Restore par
    cp 3                  ; ;3a66
    jp nz,l3ab1h   ;----; ; ;3a68   if par.ne.3 (Subtraction) --> ...
    ld hl,(l01d6h)      ; ; ;3a6b   hl=(l01d6h)
    call Neg_HL         ; ; ;3a6e   Negate HL
l3a71h:                 ; ;
    ld a,h              ; ; ;3a71
    or a                ; ; ;3a72
    jp m,l3a87h ;-;     ; ; ;3a73   if h < 0 --> ...
    or l          ;     ; ; ;3a76
    ret z         ;     ; ; ;3a77   if (l01d6h).eq.0 Return
    ld de,00004h  ;     ; ; ;3a78   de=4
    call cmpHL.DE ;     ; ; ;3a7b   Compare HL with DE
    jp nc,l3aa6h;-)---; ; ; ;3a7e   if HL >= DE --> ...
    ld c,l        ;   ; ; ; ;3a81   4d
    ld a,023h     ;   ; ; ; ;3a82   'INC HL'
    jp l3a98h  ;--)-; ; ; ; ;3a84   --> Put the opcode C times
                  ; ; ; ; ;
l3a87h:    ;<-----+ ; ; ; ;
    inc hl          ; ; ; ; ;3a87
    inc hl          ; ; ; ; ;3a88
    inc hl          ; ; ; ; ;3a89   hl=hl+3
    ld a,h          ; ; ; ; ;3a8a
    or a            ; ; ; ; ;3a8b
    dec hl          ; ; ; ; ;3a8c
    dec hl          ; ; ; ; ;3a8d
    dec hl          ; ; ; ; ;3a8e   hl=hl-3
    jp m,l3aa6h ;---)-; ; ; ;3a8f   if h < 0 --> ...
    ld a,l          ; ; ; ; ;3a92   7d
    cpl             ; ; ; ; ;3a93   2f
    inc a           ; ; ; ; ;3a94   3c
    ld c,a          ; ; ; ; ;3a95   4f
    ld a,02bh       ; ; ; ; ;3a96   'DEC HL'
;                   ; ; ; ;
l3a98h:      ;<-----+ ; ; ;         Put the opcode C times
t3a98h:         ;<--; ; ; ;
      push af       ; ; ; ; ;3a98
      push bc       ; ; ; ; ;3a99
      call PutOpc   ; ; ; ; ;3a9a   Put opcode
      pop bc        ; ; ; ; ;3a9d
      pop af        ; ; ; ; ;3a9e
      dec c         ; ; ; ; ;3a9f   c=c-1
    jp nz,t3a98h ;--+ ; ; ; ;3aa0   if c.ne.0 --> put next
    jp l375eh         ; ; ; ;3aa3   --> (l0251h)=0 ret
;                     ; ; ;
l3aa6h:        ;<-----+ ; ;
    ld a,011h           ; ; ;3aa6   'LD DE,word'
    call s_3f86h        ; ; ;3aa8   Put opcode & addres in HL to console & REL file
    call s_3c63h        ; ; ;3aab   {'ADD HL,DE'; (l0251h)=0 ret}
    jp l375eh           ; ; ;3aae   --> (l0251h)=0 ret
                        ; ;
;    par.ne.3           ; ;
                        ; ;
l3ab1h:         ;<------+ ;
    dec a                 ; ;3ab1
    ld hl,(l01d6h)        ; ;3ab2   hl=(l01d6h)
    jp z,l3a71h           ; ;3ab5   if par.eq.1 (Addition) --> ...
                          ;
;   (i_Type).eq.2 (BYTE)  ;
                          ;
l3ab8h:             ;<----+
    ld hl,l01d7h            ;3ab8
    ld a,(hl)               ;3abb
    or a                    ;3abc
    jp z,l3afdh   ;-----;   ;3abd   if (l01d7h).eq.0 --> ...
    dec a               ;   ;3ac0
    jp nz,l3aedh   ;--; ;   ;3ac1   if (l01d7h).ne.1 --> ...
    ld a,b            ; ;   ;3ac4   Restore par
    sub 2             ; ;   ;3ac5
    jp nz,l3aedh   ;--; ;   ;3ac7   if par.ne.2 (Multiplication) --> ...
    dec hl            ; ;   ;3aca   2b
    or (hl)           ; ;   ;3acb   b6
    jp nz,l3aedh   ;--; ;   ;3acc   c2 ed 3a --> ...
    ld a,(i_Type)     ; ;   ;3acf
    or a              ; ;   ;3ad2
    jp nz,l3ae4h;-;   ; ;   ;3ad3   if (i_Type).ne.0 (INTEGER) --> ...
    ld a,065h     ;   ; ;   ;3ad6   'LD H,L'
l3ad8h:        ;<-)-; ; ;
    call PutOpc   ; ; ; ;   ;3ad8
    ld a,02eh     ; ; ; ;   ;3adb   'LD L,byte'
    call PutOpc   ; ; ; ;   ;3add
    xor a         ; ; ; ;   ;3ae0   a=0
    jp p.byte     ; ; ; ;   ;3ae1   Put byte in reg A to REL file
                  ; ; ; ;
l3ae4h:      ;<---+ ; ; ;
    xor a           ; ; ;   ;3ae4   a=0
    ld (i_Type),a   ; ; ;   ;3ae5   (i_Type)=0 (INTEGER)
    ld a,067h       ; ; ;   ;3ae8   'LD H,A'
    jp l3ad8h   ;---+ ; ;   ;3aea
                      ; ;
l3aedh:     ;<--------+ ;
    ld a,(i_Type)       ;   ;3aed
    or a                ;   ;3af0
    jp z,l3c4ch         ;   ;3af1   if (i_Type).eq.0 (INTEGER) --> ...
    call s_3682h        ;   ;3af4   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (i_Type),a       ;   ;3af7   (i_Type)=0 (INTEGER)
    jp l3c4ch           ;   ;3afa   --> ...
                        ;
l3afdh:         ;<------+
    dec hl                  ;3afd
    ld a,(hl)               ;3afe
    or a                    ;3aff
    jp nz,l3b23h ;--;       ;3b00   if (l01d6h).ne.0 --> ...
    ld a,b          ;       ;3b03   Restore par
    dec a           ;       ;3b04
    ret z           ;       ;3b05   if par.eq.1 (Addition) Return
    dec a           ;       ;3b06
    jp z,s_3ecch    ;       ;3b07   if par.eq.2 (Multiplication) --> ...
    dec a           ;       ;3b0a
    ret z           ;       ;3b0b   if par.eq.3 (Subtraction) Return
    dec a           ;       ;3b0c
    ld hl,(l023fh)  ;       ;3b0d   hl=(l023fh)
    jp nz,l3bf6h ;--)-----; ;3b10   if par.ne.4 (Division) --> ...
    push bc         ;     ; ;3b13 \
    call err.msg    ;     ; ;3b14   Warning (30)
    db 30           ;     ; ;3b17   Division by Zero
    jp l3b1ch ;--;  ;     ; ;3b18   --> ...
                 ;  ;     ;
l3b1bh:     ;<---)--)---; ;
    push bc      ;  ;   ; ; ;3b1b \
l3b1ch:      ;<--+  ;   ; ;
    call s_3ea5h    ;   ; ; ;3b1c   cd a5 3e
    pop bc          ;   ; ; ;3b1f /
    jp l3c15h       ;   ; ; ;3b20   --> Building built-in arithmetic routine
                    ;   ; ;
l3b23h:         ;<--+   ; ;
    dec a               ; ; ;3b23
    jp nz,l3b30h ;--;   ; ; ;3b24   if (l01d6h).ne.1 --> ...
    ld a,b          ;   ; ; ;3b27   Restore par
    sub 2           ;   ; ; ;3b28
    ret z           ;   ; ; ;3b2a   if par.eq.2 (Multiplication) Return
    sub 2           ;   ; ; ;3b2b
    ret z           ;   ; ; ;3b2d   if par.ne.4 (Division) Return
    dec a           ;   ; ; ;3b2e
    ret z           ;   ; ; ;3b2f   if par.ne.5 (?) Return
l3b30h:         ;<--+   ; ;
    ld a,(i_Type)       ; ; ;3b30
    cp 2                ; ; ;3b33
    jp nz,l3b6dh  ;---; ; ; ;3b35   if (i_Type).ne.2 (REAL)   --> ...
    ld a,b            ; ; ; ;3b38   Restore par
    dec a             ; ; ; ;3b39
    jp z,l3b42h ;-;   ; ; ; ;3b3a   if par.eq.1 (Addition)    --> ...
    sub 2         ;   ; ; ; ;3b3d
    jp nz,l3b67h;-)-; ; ; ; ;3b3f   if par.ne.3 (Subtraction) --> ...
l3b42h:       ;<--+ ; ; ; ;
    ld a,(l01d6h)   ; ; ; ; ;3b42
    dec a           ; ; ; ; ;3b45
    jp nz,l3b55h;-; ; ; ; ; ;3b46   if (l01d6h).eq.1 --> ...
    ld a,b        ; ; ; ; ; ;3b49   Restore par
    dec a         ; ; ; ; ; ;3b4a
    ld a,03dh     ; ; ; ; ; ;3b4b   'DEC A'
    jp nz,PutOpc  ; ; ; ; ; ;3b4d   if par.ne.1 (Addition) 'DEC A' 
    ld a,03ch     ; ; ; ; ; ;3b50   else                   'INC A'
    jp PutOpc     ; ; ; ; ; ;3b52   --> ...
                  ; ; ; ; ;
l3b55h:       ;<--+ ; ; ; ;
    ld a,b          ; ; ; ; ;3b55   Restore par
    dec a           ; ; ; ; ;3b56
    ld a,0d6h       ; ; ; ; ;3b57   'SUB byte'
    jp nz,l3b5eh;-; ; ; ; ; ;3b59   if par.eq.1 (Addition) --> ...
    ld a,0c6h     ; ; ; ; ; ;3b5c   'ADD A,byte'
l3b5eh:       ;<--+ ; ; ; ;
    call PutOpc     ; ; ; ; ;3b5e
    ld a,(l01d6h)   ; ; ; ; ;3b61   a=(l01d6h)
    jp p.byte       ; ; ; ; ;3b64   --> Put byte in reg A to REL file
                    ; ; ; ;
l3b67h:         ;<--+ ; ; ;
    call s_3682h      ; ; ; ;3b67   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a     ; ; ; ;3b6a   (i_Type)=0 (INTEGER) 
l3b6dh:     ;<--------+ ; ;
    ld a,b              ; ; ;3b6d   Restore par
    cp 2                ; ; ;3b6e
    jp nz,l3c4ch        ; ; ;3b70   if par.ne.2 (Multiplication) --> ...
    ld a,(l01d6h)       ; ; ;3b73   3a d6 01 
    ld c,0ffh           ; ; ;3b76   0e ff
l3b78h:         ;<--;   ; ;
      rra           ;   ; ; ;3b78   1f
      inc c         ;   ; ; ;3b79   0c
    jp nc,l3b78h ;--+   ; ; ;3b7a   if c not set --> ...
    or a                ; ; ;3b7d   b7
    jp nz,l3b1bh   ;----+ ; ;3b7e   if a.ne.0 --> ...
    ld a,029h             ; ;3b81   'ADD HL,HL'
    jp l3a98h             ; ;3b83   --> Put the opcode C times
                          ;
;   (TypeID)=3 DOUBLE     ;
                    ;     ;
l3b86h:       ;<----+     ;
    ld hl,l3b9bh          ; ;3b86   Point to l3b9bh
    push hl               ; ;3b89   Save to return
    ld a,(i_Type)         ; ;3b8a 
    cp 3                  ; ;3b8d
    ret z     ;-----;     ; ;3b8f   if (i_Type).eq.3 (DOUBLE) Return to l3b9bh
    or a            ;     ; ;3b90
    jp z,l0a00h     ;     ; ;3b91   if (i_Type).eq.0 (INTEGER) --> Converting $CC Integer to Double; Return to l3b9bh
    dec a           ;     ; ;3b94   
    jp z,l0a03h     ;     ; ;3b95   if (i_Type).eq.1 (REAL) --> Converting $CK Real to Double; Return to l3b9bh
    jp l09fdh       ;     ; ;3b98   --> Converting - $CS; Return to l3b9bh
                    ;     ;
l3b9bh:         ;<--+     ;
    ld (i_Type),a         ; ;3b9b   (i_Type)= according on the type of conversion
    ld hl,(l01cfh)        ; ;3b9e
    ex de,hl              ; ;3ba1
    ld hl,(l02afh)        ; ;3ba2
    call cmpHL.DE         ; ;3ba5   Compare HL with DE
    jp z,l3be6h     ;---; ; ;3ba8   if (l02afh).eq.(l01cfh) --> ...
    ld hl,(l023dh)      ; ; ;3bab   2a 3d 02
    jp l3bd4h    ;----; ; ; ;3bae   --> ...
                      ; ; ;
;   (TypeID)=1 REAL   ; ; ;
                  ;   ; ; ;
l3bb1h:       ;<--+   ; ; ;
    ld a,(i_Type)     ; ; ; ;3bb1
    dec a             ; ; ; ;3bb4
    jp z,l3bc4h  ;--; ; ; ; ;3bb5   if (i_Type).eq.1 (REAL) --> ...
    cp 2            ; ; ; ; ;3bb8
    jp z,l3bc4h  ;--; ; ; ; ;3bba   if (i_Type).eq.3 (DOUBLE) --> ...
    dec a           ; ; ; ; ;3bbd
    call z,s_3682h  ; ; ; ; ;3bbe   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    call s_09efh    ; ; ; ; ;3bc1   Converting value Integer to Real
l3bc4h:       ;<----+ ; ; ;
    ld hl,(l01cfh)    ; ; ; ;3bc4
    ex de,hl          ; ; ; ;3bc7
    ld hl,(l02b3h)    ; ; ; ;3bc8
    call cmpHL.DE     ; ; ; ;3bcb   Compare HL with DE
    jp z,l3be6h   ;---)-; ; ;3bce   if (l02b3h).eq.(l01cfh) --> ...
    ld hl,(l0241h)    ; ; ; ;3bd1   2a 41 02
l3bd4h:         ;<----+ ; ;
    call cmpHL.DE       ; ; ;3bd4   Compare HL with DE
    ld a,b              ; ; ;3bd7   Restore par
    jp nz,l3c10h ;----; ; ; ;3bd8   if HL ne DE --> ...
    sub 2             ; ; ; ;3bdb
    ret z             ; ; ; ;3bdd   if par.eq.2 (Multiplication) Return
    sub 2             ; ; ; ;3bde
    ret z             ; ; ; ;3be0   if par.eq.4 (Division) Return
    dec a             ; ; ; ;3be1
    ret z             ; ; ; ;3be2   if par.eq.5 (?) Return
    jp l3c10h    ;----; ; ; ;3be3   --> ...
                      ; ; ;
l3be6h:      ;<-------)-+ ;
    ld a,b            ;   ; ;3be6   Restore par
    dec a             ;   ; ;3be7
    ret z             ;   ; ;3be8   if par.eq.1 (Addition) Return
    dec a             ;   ; ;3be9
    jp z,s_3ecch      ;   ; ;3bea   if par.eq.2 (Multiplication) --> ...
    dec a             ;   ; ;3bed
    ret z             ;   ; ;3bee   if par.eq.3 (Subtraction) Return
    dec a             ;   ; ;3bef
    jp z,l3c08h ;---; ;   ; ;3bf0   if par.eq.4 (Division) --> ...
    ld hl,(l0241h)  ; ;   ; ;3bf3   hl=(l0241h)
l3bf6h:      ;<-----)-)---+
    call ExtAttr    ; ;     ;3bf6   Extract Attributes from the symbol table
    jp s_3ecch      ; ;     ;3bf9   --> ...
                    ; ;
; (i_Type)=1 REAL   ; ;
;         =3 DOUBLE ; ;
;         =4 INT*4  ; ;
l3bfch:             ; ;
    push bc         ; ;     ;3bfc \
    call s_3f81h    ; ;     ;3bfd   Put "LD HL,word" & addres in (l01d6h) to console & REL file 
    pop bc          ; ;     ;3c00 /
    xor a           ; ;     ;3c01   a=0
    ld (TypeID),a   ; ;     ;3c02   (TypeID)=0 (INTEGER)
    jp l3c15h  ;--; ; ;     ;3c05   --> Building built-in arithmetic routine
                  ; ; ;
l3c08h:      ;<---)-+ ;
    push bc       ;   ;     ;3c08 \ 
    call err.msg  ;   ;     ;3c09   Warning (30)
    db 30         ;   ;     ;3c0c   Division by Zero
    jp l3c11h ;-; ;   ;     ;3c0d
                ; ;   ;
l3c10h:   ;<----)-;---+
    push bc     ; ;         ;3c10 \
l3c11h:    ;<---+ ;
    call s_3f9bh  ;         ;3c11   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    pop bc        ;         ;3c14 /
                  ;
l3c15h:       ;<--+
;
;   Building built-in arithmetic routine
;
;   Reg B - First character of the built-in routine corresponds to
;           the first letter of the name of an arithmetic operator
;
    ld a,b                  ;3c15   Restore par
    dec a                   ;3c16
    ld b,'A'                ;3c17   b='A'
    jp z,l3c30h ;-;         ;3c19   if par.eq.1 (Addition)
    dec a         ;         ;3c1c
    ld b,'M'      ;         ;3c1d   b='M'
    jp z,l3c30h ;-;         ;3c1f   if par.eq.2 (Multiplication)
    dec a         ;         ;3c22
    ld b,'S'      ;         ;3c23   b='S'
    jp z,l3c30h ;-;         ;3c25   if par.eq.3 (Subtraction)
    dec a         ;         ;3c28
    ld b,'D'      ;         ;3c29   b='D'
    jp z,l3c30h ;-;         ;3c2b   if par.eq.4 (Division)
    ld b,'E'      ;         ;3c2e   b='E'
                  ;                             (Exponentiation)
l3c30h:      ;<---+
;
;   Reg C - The Second character built-in routine is calculated
;           depending on the operands of an arithmetic expression
;
    ld a,(i_Type)           ;3c30
    rlca                    ;3c33
    rlca                    ;3c34
    rlca                    ;3c35
    add a,'9'               ;3c36
    ld hl,TypeID            ;3c38
    add a,(hl)              ;3c3b   a=(i_Type)*8+'9'+(TypeID)
    cp 'U'                  ;3c3c
    jp nz,l3c42h;-;         ;3c3e   if a.ne.'U'
    inc a         ;         ;3c41   a=a+1
l3c42h:      ;<---+
    cp 'T'                  ;3c42
    jp nz,l3c48h;-;         ;3c44   if a.ne.'T'
    inc a         ;         ;3c47   a=a+1
l3c48h:      ;<---+
    ld c,a                  ;3c48   Load Second character
    jp CrBuilt              ;3c49   --> Creating built-in routine
;
l3c4ch:
    push bc                 ;3c4c \ c5
    call s_3ea5h            ;3c4d   cd a5 3e
    pop bc                  ;3c50 / c1
    ld a,(TypeID)           ;3c51   3a ec 01
    or a                    ;3c54
    jp z,l3c5eh  ;--;       ;3c55   if (TypeID).eq.0 (INTEGER) --> ...
    call s_3682h    ;       ;3c58   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (TypeID),a   ;       ;3c5b   (TypeID)=0 (INTEGER)
l3c5eh:         ;<--+
    ld a,b                  ;3c5e   Restore par
    dec a                   ;3c5f
    jp nz,l3c6bh ;--;       ;3c60   if par.eq.1 (Addition) --> ...
s_3c63h:            ;
    ld a,019h       ;       ;3c63   'ADD HL,DE'
    call PutOpc     ;       ;3c65
    jp l375eh       ;       ;3c68   --> (l0251h)=0 ret
                    ;
l3c6bh:         ;<--+
    sub 2                   ;3c6b   if par.ne.3 (Subtraction)
    jp nz,l3c15h            ;3c6d     --> Building built-in arithmetic routine
    ld a,07bh               ;3c70   'LD A,E'
    call PutOpc             ;3c72
    ld a,095h               ;3c75   'SUB L'
    call PutOpc             ;3c77
    ld a,06fh               ;3c7a   'LD L,A'
    call PutOpc             ;3c7c
    ld a,07ah               ;3c7f   'LD A,D'
    call PutOpc             ;3c81
    ld a,09ch               ;3c84   'SBC A,H'
    call PutOpc             ;3c86
    ld a,067h               ;3c89   'LD H,A'
    call PutOpc             ;3c8b
    jp l375eh               ;3c8e   --> (l0251h)=0 ret
;
; (KindID).ne.1 Constant
; or (TypeID)=4 INTEGER*4
                        ;
l3c91h:     ;<----------+
    ld a,(i_Type)           ;3c91
    cp 2                    ;3c94
    jp nz,l3cbah ;----;     ;3c96   if (i_Type).ne.2 (BYTE) --> ...
    ld hl,TypeID      ;     ;3c99
    cp (hl)           ;     ;3c9c
    jp nz,l3cb4h ;--; ;     ;3c9d   if (i_Type).ne.(TypeID) --> ...
    ld a,b          ; ;     ;3ca0   Restore par
    dec a           ; ;     ;3ca1
    jp z,l3cafh ;-; ; ;     ;3ca2   if par.eq.1 (Addition) --> ...
    sub 2         ; ; ;     ;3ca5
    jp nz,l3cb4h;-)-; ;     ;3ca7   if par.ne.3 (Subtraction) --> ...
    ld a,096h     ; ; ;     ;3caa   'SUB A,(HL)'
    jp l3e12h     ; ; ;     ;3cac   --> ...
                  ; ; ;
l3cafh:       ;<--+ ; ;
    ld a,086h       ; ;     ;3caf   'ADD A,(HL)'
    jp l3e12h       ; ;     ;3cb1   --> ...
                    ; ;
l3cb4h:      ;<-----+ ;
    call s_3682h      ;     ;3cb4   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (i_Type),a     ;     ;3cb7   (i_Type)=0 (INTEGER)
l3cbah:         ;<----+
    ld a,(TypeID)           ;3cba
    cp 2                    ;3cbd
    jp nz,l3cebh   ;--;     ;3cbf   if (TypeID).ne.2 (BYTE) --> ...
    push bc           ;     ;3cc2 \
    ld a,(i_Type)     ;     ;3cc3
    or a              ;     ;3cc6
    jp z,l3cd7h  ;--; ;     ;3cc7   if (i_Type).eq.0 (INTEGER) --> ...
    call s_3f2ch    ; ;     ;3cca   cd 2c 3f
    call s_3682h    ; ;     ;3ccd   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (TypeID),a   ; ;     ;3cd0   (TypeID)=0 (INTEGER)
    pop bc          ; ;     ;3cd3 /
    jp l3c15h       ; ;     ;3cd4   --> Building built-in arithmetic routine
                    ; ;
l3cd7h:         ;<--+ ;
    call s_3ea5h      ;     ;3cd7   cd a5 3e
    pop bc            ;     ;3cda /
    ld a,(TypeID)     ;     ;3cdb
    or a              ;     ;3cde
    jp z,l3c5eh       ;     ;3cdf   if (TypeID).eq.0 (INTEGER) --> ...
    call s_3682h      ;     ;3ce2   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (TypeID),a     ;     ;3ce5   (TypeID)=0 (INTEGER)
    jp l3c5eh         ;     ;3ce8   --> ...
                      ;
l3cebh:         ;<----+
    ld hl,TypeID            ;3ceb
    ld a,(i_Type)           ;3cee
    cp (hl)                 ;3cf1
    jp z,l3d1ch ;-----;     ;3cf2   if (i_Type).ne.4 (INTEGER*4) --> ...
    cp 4              ;     ;3cf5
    jp nz,l3d05h ;--; ;     ;3cf7   if (i_Type).ne.4 (INTEGER*4) --> ...
    ld a,(hl)       ; ;     ;3cfa
    or a            ; ;     ;3cfb
    ld a,(i_Type)   ; ;     ;3cfc   a=(i_Type)
    jp z,l3d23h   ;-)-)-;   ;3cff   if (TypeID).eq.0 (INTEGER) --> ...
    jp l3d30h  ;----)-)-)-; ;3d02   --> Building built-in routine converting between value types
                    ; ; ; ;
l3d05h:     ;<------+ ; ; ;
    ld a,(hl)         ; ; ; ;3d05
    cp 4              ; ; ; ;3d06
    ld a,(i_Type)     ; ; ; ;3d08
    jp nz,l3d15h ;--; ; ; ; ;3d0b   if (TypeID).eq.4 (INTEGER*4) --> ...
    or a            ; ; ; ; ;3d0e   if (i_Type).eq.0 (INTEGER)
    jp z,l3d30h   ;-)-)-)-; ;3d0f     --> Building built-in routine converting between value types
    jp l3d23h   ;---)-)-; ; ;3d12   --> ...
                    ; ; ; ;
l3d15h:     ;<------+ ; ; ;
    cp (hl)           ; ; ; ;3d15   if (i_Type)  <  (TypeID)
    jp c,l3d30h    ;--)-)-; ;3d16     --> Building built-in routine converting between value types
    jp nz,l3d23h ;----)-; ; ;3d19   if (i_Type).ne. (TypeID) --> ...
l3d1ch:  ;<-----------+ ; ;
    or a                ; ; ;3d1c
    jp z,l3c4ch         ; ; ;3d1d   if i_Type).eq.0 (INTEGER) --> ...
    jp l3c10h           ; ; ;3d20   --> ...
                        ; ;
l3d23h:         ;<------+ ;
    ld a,(hl)             ; ;3d23
    or a                  ; ;3d24
    jp nz,l3c10h          ; ;3d25   if (TypeID).ne.0 (INTEGER) --> ...
    push bc               ; ;3d28 \
    call s_3ed2h          ; ;3d29   cd d2 3e
    pop bc                ; ;3d2c /
    jp l3c15h             ; ;3d2d   --> Building built-in arithmetic routine
                          ;
l3d30h:    ;<-------------+
;
;   Building  built-in routine converting between value types
;
    ld c,a                  ;3d30   Save (i_Type)
    ld a,(hl)               ;3d31
    ld (i_Type),a           ;3d32   (i_Type)=(TypeID)
    ld a,c                  ;3d35   Resrore (i_Type)
    rlca                    ;3d36
    rlca                    ;3d37
    rlca                    ;3d38   (i_Type)*8
    add a,040h              ;3d39
    add a,(hl)              ;3d3b
;
;   Building mnemonic built-in routine
;     Reg B - First character of the built-in routine "C"
;     Reg C - The second character of the built-in function is calculated
;             according to the conversion of one type to another
;
    push bc                 ;3d3c \
    ld c,a                  ;3d3d   c=(i_Type)*8+'@'+(TypeID)
    ld b,'C'                ;3d3e   $Cc
    call CrBuilt            ;3d40   Creating built-in routine
    pop bc                  ;3d43 /
    jp l3c10h               ;3d44   --> ...
;
l3d47h:
    jp nz,l3dech   ;----;   ;3d47   if par.ne.7 --> ...
l3d4ah:     ;<----;     ;
    ld a,(TypeID) ;     ;   ;3d4a
    ld hl,i_Type  ;     ;   ;3d4d
    cp (hl)       ;     ;   ;3d50
    ld a,(hl)     ;     ;   ;3d51
    jp z,l3d8ch ;-)---; ;   ;3d52   if (TypeID).eq.(i_Type) --> ...
    cp 2          ;   ; ;   ;3d55
    jp nz,l3d62h;-)-; ; ;   ;3d57   if (i_Type).eq.2 (BYTE) --> ...
    ld (hl),0     ; ; ; ;   ;3d5a   (i_Type)=0 (INTEGER)
    call s_3682h  ; ; ; ;   ;3d5c   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    jp l3d4ah  ;--+ ; ; ;   ;3d5f   --> ...
                    ; ; ;
l3d62h:       ;<----+ ; ;
    or a              ; ;   ;3d62
    jp nz,l3d76h;-;   ; ;   ;3d63   if (i_Type).eq.0 (INTEGER) --> ...
    ld a,(TypeID) ;   ; ;   ;3d66
    cp 2          ;   ; ;   ;3d69
    jp nz,l3d76h;-;   ; ;   ;3d6b   if (TypeID).ne.2 (BYTE)    --> ...
    ld a,07dh     ;   ; ;   ;3d6e   'LD A,L'
    call PutOpc   ;   ; ;   ;3d70
    jp l3da9h   ;-)-; ; ;   ;3d73   --> ...
                  ; ; ; ;
l3d76h:     ;<----+ ; ; ;
    ld a,(hl)       ; ; ;   ;3d76   a=(i_Type)
    rlca            ; ; ;   ;3d77
    rlca            ; ; ;   ;3d78
    rlca            ; ; ;   ;3d79
    add a,'@'       ; ; ;   ;3d7a
    ex de,hl        ; ; ;   ;3d7c   Save hl=i_Type
    ld hl,TypeID    ; ; ;   ;3d7d
    add a,(hl)      ; ; ;   ;3d80
    ld b,(hl)       ; ; ;   ;3d81   b=(TypeID)
    ex de,hl        ; ; ;   ;3d82   Restore hl=i_Type
    ld (hl),b       ; ; ;   ;3d83   (i_Type)=(TypeID)
    push bc         ; ; ;   ;3d84 \ Save (i_Type)
    ld c,a          ; ; ;   ;3d85   c=(i_Type)*8+'@'+(TypeID)
    ld b,'C'        ; ; ;   ;3d86   $Cc
    call CrBuilt    ; ; ;   ;3d88   Creating built-in routine
    pop af          ; ; ;   ;3d8b / Restore (i_Type)
l3d8ch:      ;<-----)-+ ;
    or a            ;   ;   ;3d8c
    ld hl,(l01cfh)  ;   ;   ;3d8d
    ld (l0251h),hl  ;   ;   ;3d90   (l0251h)=(l01cfh)
    jp z,l3dadh ;---)-; ;   ;3d93   if (i_Type).eq.0 (INTEGER) --> ...
    cp 002h         ; ; ;   ;3d96
    jp z,l3da9h  ;--; ; ;   ;3d98   if (i_Type).eq.2 (BYTE)    --> ...
    call s_3f9bh    ; ; ;   ;3d9b   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    ld a,(TypeID)   ; ; ;   ;3d9e   Load value type variable
    add a,'0'       ; ; ;   ;3da1   Convert binary decimal to ASCII
    ld c,a          ; ; ;   ;3da3   Copy to reg C
    ld b,054h       ; ; ;   ;3da4   'T' - sTore floating accumulator
    jp l3f20h       ; ; ;   ;3da6   --> Creating built-in routine "$Tc"
                    ; ; ;
l3da9h:    ;<-------+ ; ;
    scf               ; ;   ;3da9   Set carry
    jp l3daeh    ;--; ; ;   ;3daa   --> ...
                    ; ; ;
l3dadh:       ;<----)-+ ;
    xor a           ;   ;   ;3dad   clears carry flag
l3daeh:    ;<-------+   ;
    push af             ;   ;3dae \
    ld a,(ScopeID)      ;   ;3daf
    cp 3                ;   ;3db2
    jp z,l3dc9h ;---;   ;   ;3db4   if (ScopeID).eq.3 --> ...
    pop af          ;   ;   ;3db7 /
    jp nc,l4132h    ;   ;   ;3db8   if (i_Type) >= 0 --> 'LD (word),HL' ...
    ld hl,(l01cfh)  ;   ;   ;3dbb
    ld (l0251h),hl  ;   ;   ;3dbe   (l0251h)=(l01cfh)
    ld a,2          ;   ;   ;3dc1
    ld (i_Type),a   ;   ;   ;3dc3   (i_Type)=2 (BYTE)
    jp l412dh       ;   ;   ;3dc6   --> 'LD (word),A' ...
                    ;   ;
l3dc9h:         ;<--+   ;
    pop af              ;   ;3dc9 /
    jp nc,l3dd5h  ;-;   ;   ;3dca   if (i_Type) >= --> ... 
    call s_4123h    ;   ;   ;3dcd   'LD HL,(word)'
    ld a,077h       ;   ;   ;3dd0   'LD (HL),A'
    jp PutOpc       ;   ;   ;3dd2   --> ...
                    ;   ;
l3dd5h:         ;<--+   ;
    ld a,0ebh           ;   ;3dd5   'EX DE,HL'
    call PutOpc         ;   ;3dd7
    call s_4123h        ;   ;3dda   'LD HL,(word)'
    ld a,073h           ;   ;3ddd   'LD (HL),E'
    call PutOpc         ;   ;3ddf
    ld a,023h           ;   ;3de2   'INC HL'
    call PutOpc         ;   ;3de4
    ld a,072h           ;   ;3de7   'LD (HL),D'
    jp PutOpc           ;   ;3de9   --> ...
                        ;
l3dech:     ;<----------+
    sub 8                   ;3dec
    ld c,a                  ;3dee   c=par-8
    ld a,0eeh               ;3def   'XOR byte'
    jp z,l3dfdh  ;--;       ;3df1   if par.eq.8 --> ...
    dec c           ;       ;3df4
    ld a,0f6h       ;       ;3df5   'OR byte'
    jp z,l3dfdh  ;--;       ;3df7   if par.eq.9 --> ...
    dec c           ;       ;3dfa   0d
    ld a,0e6h       ;       ;3dfb   'AND byte'
l3dfdh:       ;<----+
    ld b,a                  ;3dfd   Save opcode                 --------+
    ld a,(KindID)           ;3dfe                                       ;
    dec a                   ;3e01                                       ;
    jp z,l3e5ah  ;----;     ;3e02   if (KindID).eq.1 (Constant) --> ... ;
    ld a,(TypeID)     ;     ;3e05                                       ;
    ld hl,i_Type      ;     ;3e08                                       ;
    and (hl)          ;     ;3e0b                                       ;
    jp z,l3e1ah  ;--; ;     ;3e0c   if (TypeID).eq.(i_Type) --> ...     ;
    ld a,b          ; ;     ;3e0f   Restore opcode              <-------+
    sub '@'         ; ;     ;3e10   d6 40   . @
l3e12h:             ; ;
    push af         ; ;     ;3e12 \
    call s_3f9bh    ; ;     ;3e13   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    pop af          ; ;     ;3e16 /
    jp PutOpc       ; ;     ;3e17   --> ...
                    ; ;
l3e1ah:         ;<--+ ;
    or (hl)           ;     ;3e1a
    jp z,l3e24h  ;--; ;     ;3e1b   if (i_Type).eq.0 --> (INTEGER)...
    call s_3682h    ; ;     ;3e1e   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (i_Type),a   ; ;     ;3e21   (TypeID)=0 (INTEGER)
l3e24h:         ;<--+ ;
    push bc           ;     ;3e24 \
    ld a,0ebh         ;     ;3e25   'EX DE,HL'
    call PutOpc       ;     ;3e27
    call s_3ed2h      ;     ;3e2a   cd d2 3e
    ld a,(TypeID)     ;     ;3e2d
    or a              ;     ;3e30
    jp z,l3e3ah       ;     ;3e31   if (TypeID).eq.0 (INTEGER) --> ...
    call s_3682h ;--; ;     ;3e34   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    jp l3e3fh  ;--; ; ;     ;3e37   --> ...
                  ; ; ;
l3e3ah:       ;<--)-+ ;
    ld a,07ch     ;   ;     ;3e3a   'LD A,H'
    call PutOpc   ;   ;     ;3e3c
l3e3fh:     ;<----+   ;
    pop af            ;     ;3e3f / a=b
    sub 'D'           ;     ;3e40   44h
    push af           ;     ;3e42 \ 
    call PutOpc       ;     ;3e43
    ld a,067h         ;     ;3e46   'LD H,A'
    call PutOpc       ;     ;3e48
    ld a,07dh         ;     ;3e4b   'LD A,L'
    call PutOpc       ;     ;3e4d
    pop af            ;     ;3e50 / 
    inc a             ;     ;3e51   3c
    call PutOpc       ;     ;3e52
    ld a,06fh         ;     ;3e55   'LD L,A'
    jp PutOpc         ;     ;3e57   --> ...
                      ;
l3e5ah:       ;<------+
    ld a,(TypeID)           ;3e5a
    ld hl,i_Type            ;3e5d 
    and (hl)                ;3e60
    ld a,b                  ;3e61   Restore par
    jp nz,l3b5eh            ;3e62   if (TypeID).ne.(i_Type) --> ...
    ld a,(hl)               ;3e65
    or (hl)                 ;3e66
    jp z,l3e78h  ;--;       ;3e67   if (i_Type).eq.0 (INTEGER) --> ...
    ld a,(l01d7h)   ;       ;3e6a
    or a            ;       ;3e6d
    ld a,b          ;       ;3e6e   Restore par
    jp z,l3b5eh     ;       ;3e6f   if (l01d4h).eq.0 --> ...
    call s_3682h    ;       ;3e72   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    ld (i_Type),a   ;       ;3e75   (i_Type)=0 (INTEGER)
l3e78h:         ;<--+
    ld a,07ch               ;3e78   'LD A,H'
    push bc                 ;3e7a \ -----;
    call PutOpc             ;3e7b        ;
    pop af                  ;3e7e / a=b -+
    push af                 ;3e7f \ f5
    call PutOpc             ;3e80   Put opcode
    ld a,(l01d7h)           ;3e83   a=(l01d7h)
    call p.byte             ;3e86   Put byte in reg A to REL file
    ld a,067h               ;3e89   'LD H,A'
    call PutOpc             ;3e8b
    ld a,07dh               ;3e8e   'LD A,L'
    call PutOpc             ;3e90   
    pop af                  ;3e93 / f1
    call PutOpc             ;3e94   
    ld a,(l01d6h)           ;3e97   a=(l01d6h)
    call p.byte             ;3e9a   Put byte in reg A to REL file
    ld a,06fh               ;3e9d   'LD L,A'
    call PutOpc             ;3e9f
    jp l375eh               ;3ea2   --> (l0251h)=0 ret
;*
;*
;*
s_3ea5h:
    ld hl,(l0251h)      ;3ea5
    ex de,hl            ;3ea8
    ld hl,(l01cfh)      ;3ea9
    call cmpHL.DE       ;3eac   Compare HL with DE
    jp nz,l3ec4h ;--;   ;3eaf   if (l01cfh).ne.(l0251h) --> ...
    dec hl          ;   ;3eb2
    ld (l0251h),hl  ;   ;3eb3   (l0251h)=(l01cfh)-1
    xor a           ;   ;3eb6
    ld (TypeID),a   ;   ;3eb7   (TypeID)=0 (INTEGER)
    ld a,054h       ;   ;3eba   'LD D,H'
    call PutOpc     ;   ;3ebc
    ld a,05dh       ;   ;3ebf   'LD E,L'
    jp PutOpc       ;   ;3ec1    --> ...
                    ;
l3ec4h:         ;<--+
    ld a,0ebh           ;3ec4   'EX DE,HL'
    call PutOpc         ;3ec6
    jp l3ef9h   ;---;   ;3ec9   --> ...
;*                  ;
;*                  ;
;*                  ;
s_3ecch:            ;
    ld a,(TypeID)   ;   ;3ecc
    ld (i_Type),a   ;   ;3ecf   (i_Type)=(TypeID)
s_3ed2h:            ;
    ld hl,(l0251h)  ;   ;3ed2
    ex de,hl        ;   ;3ed5
    ld hl,(l01cfh)  ;   ;3ed6
    call cmpHL.DE   ;   ;3ed9   Compare HL with DE
    ld (l0251h),hl  ;   ;3edc   if (l01cch).ne.(l0250h) {
    jp nz,l3ef9h ;--;   ;3edf       (l0250h)=(l01cch) --> ...
    ld a,(ScopeID)  ;   ;3ee2       }
    cp 3            ;   ;3ee5
    ret nz          ;   ;3ee7   if (ScopeID).ne.3 Return
    ld a,(TypeID)   ;   ;3ee8
    or a            ;   ;3eeb
    jp nz,l3ef4h;-; ;   ;3eec   if (TypeID).ne.0 (INTEGER) --> ...
    ld a,0ebh     ; ;   ;3eef   'EX DE,HL'
    jp PutOpc     ; ;   ;3ef1   --> ...
                  ; ;
l3ef4h:      ;<---+ ;
    dec a           ;   ;3ef4
    ret z           ;   ;3ef5   if (TypeID).eq.1 (REAL) Return
    jp l3f45h       ;   ;3ef6   --> ...
                    ;
l3ef9h:         ;<--+
    ld a,(KindID)       ;3ef9
    cp 2                ;3efc
    jp nz,l3f09h  ;-;   ;3efe   if (KindID).ne.2 (Label) --> ...
    call s_411eh    ;   ;3f01   'LD HL,word'
    xor a           ;   ;3f04
    ld (i_Type),a   ;   ;3f05   (i_Type)=0 (INTEGER)
    ret             ;   ;3f08
                    ;
l3f09h:         ;<--+
    ld a,(TypeID)       ;3f09
    cp 4                ;3f0c
    jp z,l3f15h  ;--;   ;3f0e   if (TypeID).eq.4 (INTEGER*4) --> ...
    rra             ;    ;3f11
    jp nc,s_3f2ch   ;   ;3f12   if (TypeID).??. --> ...
l3f15h:         ;<--+
    call s_3f9bh        ;3f15   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
;*
;*  Load floating accumulator
;*
l3f18h:
    ld b,'L'            ;3f18   'L' - Load floating accumulator
    ld a,(TypeID)       ;3f1a   Load value type variable
    add a,'0'           ;3f1d   Convert binary decimal to ASCII
    ld c,a              ;3f1f   c=(TypeID)+'0'
l3f20h:
    ld hl,(l0251h)      ;3f20
    push hl             ;3f23 \ Save (l0251h)
    call CrBuilt        ;3f24   Creating built-in routine
    pop hl              ;3f27 / Restore (l0251h)
    ld (l0251h),hl      ;3f28
    ret                 ;3f2b
;*
;*
;*
s_3f2ch:
    ld a,(KindID)       ;3f2c
    dec a               ;3f2f
    jp z,l3f66h  ;----; ;3f30   if(KindID).eq.1 (Constant) --> ...
    ld a,(TypeID)     ; ;3f33
    or a              ; ;3f36
    ld a,(ScopeID)    ; ;3f37
    jp z,l3f4ah  ;--; ; ;3f3a   if(TypeID).eq.0 (INTEGER) --> ...
    cp 3            ; ; ;3f3d
    jp nz,l4128h    ; ; ;3f3f   if(ScopeID).ne.3 --> 'LD A,(word)' ...
    call s_4123h    ; ; ;3f42   'LD HL,(word)' ...
l3f45h:             ; ;
    ld a,07eh       ; ; ;3f45   'LD A,(HL)'
    jp PutOpc       ; ; ;3f47   --> ...
                    ; ;
l3f4ah:        ;<---+ ;
    cp 3              ; ;3f4a
    jp nz,s_4123h     ; ;3f4c   if(ScopeID).ne.3 --> 'LD HL,(word)' ...
    call s_4123h      ; ;3f4f   'LD HL,(word)' ...
l3f52h:               ;
    ld a,07eh         ; ;3f52   'LD A,(HL)'
    call PutOpc       ; ;3f54
    ld a,023h         ; ;3f57   'INC HL'
    call PutOpc       ; ;3f59
    ld a,066h         ; ;3f5c   'LD H,(HL)'
    call PutOpc       ; ;3f5e
    ld a,06fh         ; ;3f61   'LD L,A'
    jp PutOpc         ; ;3f63   --> ...
                      ;
l3f66h:         ;<----+
    ld a,(TypeID)       ;3f66
    or a                ;3f69
    jp z,s_3f81h ;--;   ;3f6a   if (TypeID).eq.0 (INTEGER) call ...
    ld a,(l01d6h)   ;   ;3f6d
    or a            ;   ;3f70
    ld a,0afh       ;   ;3f71   'XOR A'
    jp z,PutOpc     ;   ;3f73   if (l01d6h).eq.0 --> ...
    ld a,03eh       ;   ;3f76   'LD A,byte'
    call PutOpc     ;   ;3f78
    ld a,(l01d6h)   ;   ;3f7b   a=(l01d6h)
    jp p.byte       ;   ;3f7e   --> Put byte in reg A to REL file
                    ;
s_3f81h:        ;<--+
;*
;*  Put "LD HL,word" & addres from (l01d6h) to console & REL file
;*
    ld a,021h           ;3f81   'LD HL,word'
    ld hl,(l01d6h)      ;3f83   hl=(l01d6h)
;*
;*  Put opcode & addres from HL to console & REL file
;*
s_3f86h:
    push hl             ;3f86 \
    call PutOpc         ;3f87   Put opcode 'LD DE,word'
    pop hl              ;3f8a /
    ld a,(NoCode)       ;3f8b
    or a                ;3f8e   Test /N
    call z,putadr       ;3f8f   if (NoCode).eq.0 Put addres in HL to console
    ld b,l              ;3f92   b=l
    push hl             ;3f93 \
    call w.const        ;3f94   Put constant byte in reg B to REL file
    pop bc              ;3f97 / b=h
    jp w.const          ;3f98   --> Put constant byte in reg B to REL file
;*
;*  if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
;*
s_3f9bh:
    ld a,(ScopeID)      ;3f9b
    cp 3                ;3f9e
    jp z,s_4123h        ;3fa0   if(ScopeID).eq.3 --> 'LD HL,(word)'
    jp s_411eh          ;3fa3   --> 'LD HL,word'
;*
;*  ENTRY
;*    Reg  A - opcode
;*    Reg HL -
;*
s_3fa6h:
    ld (l01cfh),hl      ;3fa6   22 cf 01
;*
;*  ENTRY
;*    Reg  A - opcode
;*
s_3fa9h:
    or a                        ;3fa9   b7
    jp z,l4075h   ;-----------; ;3faa   if a.eq.0 --> ...
    call PutOpc               ; ;3fad   Put OpCode
    ld hl,(l01cfh)            ; ;3fb0
    inc hl                    ; ;3fb3
    ld a,h                    ; ;3fb4
    or l                      ; ;3fb5
    jp z,s_3fc7h  ;---;       ; ;3fb6   if (l01cfh).eq.1 --> ...
    call s_54c8h      ;       ; ;3fb9   Extract Attributes from the symbol table, entry( l01cfh)
    or a              ;       ; ;3fbc
    jp z,s_3fc7h  ;---;       ; ;3fbd   if (KindID).eq.0 --> ...
    ld a,(NoCode)     ;       ; ;3fc0
    or a              ;       ; ;3fc3   Test /N
    call z,s_5096h    ;       ; ;3fc4   cc 96 50    . . P
                      ;       ;
                      ;       ;
                      ;       ;
                      ;       ;
                      ;       ;
                      ;       ;
                      ;       ;
s_3fc7h:     ;<-------+       ;
    ld hl,(DataID)            ; ;3fc7
    push hl                   ; ;3fca \ Save (DataID)
    ld a,(ScopeID)            ; ;3fcb
    or a                      ; ;3fce
    jp z,l403ah ;-----------; ; ;3fcf   if(ScopeID).eq.0 --> ...
    dec a                   ; ; ;3fd2
    jp z,l4032h    ;------; ; ; ;3fd3   if(ScopeID).eq.1 --> ...
    cp 2                  ; ; ; ;3fd6
    jp z,l400eh ;---;     ; ; ; ;3fd8   if(ScopeID).eq.2 --> ...
    ld a,(KindID)   ;     ; ; ; ;3fdb
    dec a           ;     ; ; ; ;3fde
    jp z,l4009h   ;-)-;   ; ; ; ;3fdf   if(KindID).eq.1 (Constant) --> ...
    dec a           ; ;   ; ; ; ;3fe2
    jp nz,l3ff7h ;--)-)-; ; ; ; ;3fe3   if(KindID).ne.2 (Label) --> ...
    ld a,(RomFlg)   ; ; ; ; ; ; ;3fe6
    or a            ; ; ; ; ; ; ;3fe9   Test /M
    jp nz,l4009h  ;-)-; ; ; ; ; ;3fea   if (RomFlg).ne.0 --> ...
    ld a,(TypeID)   ; ; ; ; ; ; ;3fed
    dec a           ; ; ; ; ; ; ;3ff0
    jp z,l400eh ;---; ; ; ; ; ; ;3ff1   if (TypeID).eq.1 (REAL) --> ...
    jp l4009h     ;-)-; ; ; ; ; ;3ff4   --> ...
                    ; ; ; ; ; ;
                    ; ; ; ; ; ;
l3ff7h:   ;<--------)-)-+ ; ; ;
    cp 3            ; ;   ; ; ; ;3ff7
    jp nz,l400eh ;--; ;   ; ; ; ;3ff9   if(KindID).ne.3 --> ...
    ld hl,(l01cfh)  ; ;   ; ; ; ;3ffc
    ex de,hl        ; ;   ; ; ; ;3fff
    ld hl,(l0268h)  ; ;   ; ; ; ;4000
    call cmpHL.DE   ; ;   ; ; ; ;4003   Compare HL with DE
    jp z,l400eh  ;--; ;   ; ; ; ;4006   if (l0268h).eq.(l01cfh) --> ...
l4009h:     ;<------)-+   ; ; ;
    ld b,1          ; ;   ; ; ; ;4009   b=1
    jp l4010h ;---; ; ;   ; ; ; ;400b
                  ; ; ;   ; ; ;
l400eh:     ;<----)-+ ;   ; ; ;
    ld b,2        ;   ;   ; ; ; ;400e   b=2
l4010h:       ;<--+   ;   ; ; ;
    ld hl,(l01cfh)    ;   ; ; ; ;4010
    ld a,h            ;   ; ; ; ;4013
    and l             ;   ; ; ; ;4014
    inc a             ;   ; ; ; ;4015
    jp nz,l402ch ;--; ;   ; ; ; ;4016   if (l01cfh).ne.0ffffh (-1) --> ...
l4019h:     ;<------)-)-; ; ; ;
    ld a,(NoCode)   ; ; ; ; ; ; ;4019
    or a            ; ; ; ; ; ; ;401c   Test /N
    jp nz,l402ch ;--; ; ; ; ; ; ;401d   if (NoCode).ne.0  --> skip output
                    ; ; ; ; ; ;
    pop hl          ; ; ; ; ; ; ;4020 / e1
    push hl         ; ; ; ; ; ; ;4021 \ e5
                    ; ; ; ; ; ;
    ld a,b          ; ; ; ; ; ; ;4022   78
    dec a           ; ; ; ; ; ; ;4023   3d
    push af         ; ; ; ; ; ; ;4024 \ f5
    call z,s_5020h  ; ; ; ; ; ; ;4025   if eq.0 Put addres DATA' to console trap_ms
    pop af          ; ; ; ; ; ; ;4028 / f1
    call nz,s_5030h ; ; ; ; ; ; ;4029   if ne.0 Put addres DATA" to console trap_ms
                    ; ; ; ; ; ;
                    ; ; ; ; ; ;
l402ch:      ;<--;<-+ ; ; ; ; ;
    call w.code  ;    ; ; ; ; ; ;402c   Output control prefix 1.b2.b1 (Reg B holds two bit control)
    jp l4063h  ;-)--; ; ; ; ; ; ;402f   --> ...
                 ;  ; ; ; ; ; ;
l4032h:   ;<-----)--)-)-)-+ ; ;
    call s_64bah ;  ; ; ;   ; ; ;4032   cd ba 64
    ld b,3       ;  ; ; ;   ; ; ;4035   b=3
    jp l402ch ;--+  ; ; ;   ; ; ;4037   --> Output control prefix ...
                    ; ; ;   ; ;
l403ah:    ;<-------)-)-)---+ ;
    ld hl,(PrgSiz)  ; ; ;     ; ;403a   Load Program size
    ld (DataID),hl  ; ; ;     ; ;403d   (DataID)=(PrgSiz)
    ld hl,SegmID    ; ; ;     ; ;4040
    ld a,(l01a3h)   ; ; ;     ; ;4043
    ld d,(hl)       ; ; ;     ; ;4046   d=(SegmID) Flag Address mode
    ld (hl),a       ; ; ;     ; ;4047   (SegmID)=(l01a3h)
    push de         ; ; ;     ; ;4048 \ d5
    call PutAttr    ; ; ;     ; ;4049   Put Attributes in Symbol table
    pop de          ; ; ;     ; ;404c / d1
    pop bc          ; ; ;     ; ;404d / c1
    ld a,b          ; ; ;     ; ;404e
    or c            ; ; ;     ; ;404f   Test bc
    jp nz,l405ah;-; ; ; ;     ; ;4050   if bc.ne.0 skip output to REL file
    call w.const  ; ; ; ;     ; ;4053   Put constant byte in reg B to REL file
    xor a         ; ; ; ;     ; ;4056   a=0
    jp w.const    ; ; ; ;     ; ;4057   --> Put constant byte in reg B to REL file
                  ; ; ; ;     ;
l405ah:       ;<--+ ; ; ;     ;
    push bc         ; ; ;     ; ;405a \ c5
    ld a,d          ; ; ;     ; ;405b   Restore (SegmID)
    or a            ; ; ;     ; ;405c   Test Flag Address mode
    jp nz,l400eh    ; ; ;     ; ;405d   if (SegmID).ne.0 --> ...
    jp l4009h  ;----)-+ ;     ; ;4060   --> ...
                    ;   ;     ;
l4063h:     ;<------+   ;     ;
    pop bc              ;     ; ;4063 / c1
    push bc             ;     ; ;4064 \ Save bc
    ld b,c              ;     ; ;4065   41
    call w.byte         ;     ; ;4066   Put byte to REL file from Reg B
    ld hl,(PrgSiz)      ;     ; ;4069
    inc hl              ;     ; ;406c
    inc hl              ;     ; ;406d
    ld (PrgSiz),hl      ;     ; ;406e   (PrgSiz)=(PrgSiz)+2
    pop bc              ;     ; ;4071 / Resrore bc
    jp w.byte           ;     ; ;4072   --> Put byte to REL file from Reg B
                        ;     ;
l4075h:         ;<------)-----+
    call s_54c8h        ;       ;4075   Extract Attributes from the symbol table, entry( l01cfh)
    ld hl,l024ch        ;       ;4078
    inc (hl)            ;       ;407b   (l024ch)=(l024ch)*2
    ld a,(hl)           ;       ;407c
    cp 4                ;       ;407d
    jp nc,l4093h ;--;   ;   ;407f   if (l024ch) >= 4 --> ...
    ld hl,(l01cfh)  ;   ;   ;4082   2a cf 01
    ex de,hl        ;   ;   ;4085   eb
    dec a           ;   ;   ;4086   3d
    rlca            ;   ;   ;4087   Multiply by 2
    ld c,a          ;   ;   ;4088   4f
    ld b,0          ;   ;   ;4089   b=0
    ld hl,l0246h    ;   ;   ;408b   Pointer to ...
    add hl,bc       ;   ;   ;408e   Calculate the offset
    ld (hl),e       ;   ;   ;408f   73
    inc hl          ;   ;   ;4090   23
    ld (hl),d       ;   ;   ;4091   72
    ret             ;   ;   ;4092
                    ;   ;
l4093h:       ;<----+   ;
    jp nz,s_40afh ;-;   ;   ;4093   c2 af 40
    ld hl,(DatSiz)  ;   ;   ;4096
    push hl         ;   ;   ;4099 \ Save (DatSiz)
    ld hl,(l01cfh)  ;   ;   ;409a
    push hl         ;   ;   ;409d \ Save (l01cfh)
    ld hl,(l024ah)  ;   ;   ;409e   hl=(l024ah)
    call ExtAttr    ;   ;   ;40a1   Extract Attributes from the symbol table
    call s_40afh    ;   ;   ;40a4   cd af 40
    pop hl          ;   ;   ;40a7 / Restore (l01cfh)
    call ExtAttr    ;   ;   ;40a8   Extract Attributes from the symbol table
    pop hl          ;   ;   ;40ab / Restore (DatSiz)
    ld (l024ah),hl  ;   ;   ;40ac   (l024ah)=(DatSiz)
s_40afh:        ;<--+   ;
    ld a,(ScopeID)      ;   ;40af
    cp 3                ;   ;40b2
    jp z,l40c4h  ;--;   ;   ;40b4   if (ScopeID).eq.3 --> ...
    ld a,(RomFlg)   ;   ;   ;40b7
    or a            ;   ;   ;40ba   Test /M
    jp z,l40dah  ;--)-; ;   ;40bb   if (RomFlg).eq.0 --> ...
    call s_411eh    ; ; ;   ;40be   'LD HL,word' ...
    jp l40c7h  ;--; ; ; ;   ;40c1   --> ...
                  ; ; ; ;
l40c4h:      ;<---)-+ ; ;
    call s_4123h  ;   ; ;   ;40c4   'LD HL,(word)' ...
l40c7h:   ;<------+   ; ;
    ld a,022h         ; ;   ;40c7   'LD (word),HL'
    call PutOpc       ; ;   ;40c9
    ld hl,(DatSiz)    ; ;   ;40cc   Load Data size
    push hl           ; ;   ;40cf \
    inc hl            ; ;   ;40d0
    inc hl            ; ;   ;40d1
    ld (DatSiz),hl    ; ;   ;40d2   (DatSiz)=(DatSiz)+2
    ld b,2            ; ;   ;40d5   b=2
    jp l4019h    ;----)-+   ;40d7   --> ...
                      ;
l40dah:     ;<--------+
    ld hl,(DatSiz)          ;40da   Load Data size
    ld bc,020bh             ;40dd   Address modes DSEG (2), REL type - Set loading location counter (11)
    call s_6575h            ;40e0   cd 75 65
    call s_3fc7h            ;40e3   cd c7 3f
    ld hl,(PrgSiz)          ;40e6
    ld (DatSiz),hl          ;40e9   (DatSiz)=(PrgSiz)
    ld hl,(l021eh)          ;40ec   2a 1e 02 
    jp l6572h               ;40ef   --> ...
;
;
;
s_40f2h:
    ld hl,(l0248h)      ;40f2   hl=(l0248h)
    call ExtAttr        ;40f5   Extract Attributes from the symbol table
    ld a,(ScopeID)      ;40f8
    cp 3                ;40fb
    jp z,l4108h  ;--;   ;40fd   if(ScopeID).eq.3 --> ...
    ld a,011h       ;   ;4100   'LD DE,word'
    call s_3fa9h    ;   ;4102   cd a9 3f
    jp l4110h   ;-; ;   ;4105   --> ...
                  ; ;
l4108h:     ;<----)-+
    call s_4123h  ;     ;4108   'LD HL,(word)'
    ld a,0ebh     ;     ;410b   'EX DE,HL'
    call PutOpc   ;     ;410d
l4110h:      ;<---+
    ld hl,(l0246h)      ;4110   hl=(l0246h)
    call ExtAttr        ;4113   Extract Attributes from the symbol table
    ld a,(ScopeID)      ;4116
    cp 3                ;4119
    jp z,s_4123h ;--;   ;411b   if(ScopeID).eq.3 --> 'LD HL,(word)'
                    ;
s_411eh:            ;
    ld a,021h       ;   ;411e   'LD HL,word'
    jp s_3fa9h      ;   ;4120   --> ...
                    ;
s_4123h:        ;<--+
    ld a,02ah           ;4123   'LD HL,(word)'
    jp s_3fa9h          ;4125   --> ...

l4128h:
    ld a,03ah           ;4128   'LD A,(word)'
    jp s_3fa9h          ;412a   --> ...

l412dh:
    ld a,032h           ;412d   'LD (word),A'
    jp s_3fa9h          ;412f   --> ...

l4132h:
    ld a,022h           ;4132   'LD (word),HL'
    jp s_3fa9h          ;4134   --> ...
;
;
;
s_4137h:
    ld b,0c2h           ;4137   'JP NZ,word'
    jp l413eh   ;---;   ;4139   --> ...
;?                  ;        !! No execution path to here !!
    ld b,0cah       ;   ;413c   'JP Z,word'
l413eh:        ;<---+
    ld a,(l0222h)       ;413e
    or a                ;4141
    ret z               ;4142   if (l0222h).eq.0 Return
    push bc             ;4143 \ c5
    call s_41f7h        ;4144   cd f7 41
    call s_47b3h        ;4147   cd b3 47
    pop af              ;414a / 'JP NZ,word'
    jp s_3fa9h          ;414b   --> ...
;
;
;
s_414eh:
    ld a,(MainFlg)      ;414e
    or a                ;4151
    ret z               ;4152   if (MainFlg).eq.0 (Main program) Return
    ld hl,(l0167h)      ;4153
    ld (DataID),hl      ;4156   (DataID)=(l0167h)
    xor a               ;4159
    ld (TypeID),a       ;415a   (TypeID)=0 (INTEGER)
    ld h,a              ;415d
    ld l,a              ;415e
    ld (l0167h),hl      ;415f   (l0167h)=0
    call s_5853h        ;4162   cd 53 58
;
;   Generation instructions calling sequence for actual parameters
;
s_4165h:
    ld a,(NumArg)       ;4165   Test number of arguments to transfer
    or a                ;4168
    ret z               ;4169   if(NumArg).eq.0 Return
    ld b,a              ;416a
    ld a,(BlkDat)       ;416b
    or a                ;416e
    ret nz              ;416f   if(BlkDat).ne.0 (Block data) Return
    ld hl,(l01cfh)      ;4170
    push hl             ;4173 \ Save (l01cfh)
    push bc             ;4174 \ Save (l0293h)
    call s_41dfh        ;4175   cd df 41
    ld a,022h           ;4178   'LD (word),HL'
    call s_3fa6h        ;417a   cd a6 3f
    pop bc              ;417d /
    dec b               ;417e
    jp z,l41ach  ;--;   ;417f   if (NumArg).eq.1 --> ...
    push bc         ;   ;4182 \
    ld a,0ebh       ;   ;4183   'EX DE,HL'
    call PutOpc     ;   ;4185
    call s_41dfh    ;   ;4188   cd df 41
    ld a,022h       ;   ;418b   'LD (word),HL'
    call s_3fa6h    ;   ;418d   cd a6 3f
    pop af          ;   ;4190 /
    dec a           ;   ;4191
    jp z,l41ach  ;--;   ;4192   if (NumArg).eq.2 --> ...
    cp 1            ;   ;4195
    jp nz,l41c4h ;--)-; ;4197   if (NumArg).ne.3 --> ...
    ld a,060h       ; ; ;419a   'LD H,B'
    call PutOpc     ; ; ;419c
    ld a,069h       ; ; ;419f   'LD L,C'
    call PutOpc     ; ; ;41a1
    call s_41dfh    ; ; ;41a4   cd df 41
    ld a,022h       ; ; ;41a7   'LD (word),HL'
    call s_3fa6h    ; ; ;41a9   cd a6 3f
l41ach:         ;<--+ ;
    ld hl,(l0264h)    ; ;41ac
    ld a,h            ; ;41af
    or l              ; ;41b0
    jp z,l41c0h ;---; ; ;41b1   if(l0264h).eq.0 --> ...
    call ExtAttr    ; ; ;41b4   Extract Attributes from the symbol table
    ld hl,(PrgSiz)  ; ; ;41b7
    ld (DataID),hl  ; ; ;41ba   (DataID)=(PrgSiz)
    call PutAttr    ; ; ;41bd   Put Attributes in Symbol table
l41c0h:         ;<--+ ;
    pop hl            ; ;41c0   hl=(l01cfh)
    jp ExtAttr        ; ;41c1   --> Extract Attributes from the symbol table
                      ;
l41c4h:         ;<----+
    push af             ;41c4 \ a=(NumArg)-2 number of arguments to transfer
    ld a,03eh           ;41c5   'LD A,byte'
    call PutOpc         ;41c7   cd ef 47
    pop af              ;41ca / Restore a
    call p.byte         ;41cb   Put byte in reg A to REL file
    call s_41dfh        ;41ce   cd df 41
    ld a,021h           ;41d1   'LD HL,word'
    call s_3fa6h        ;41d3   cd a6 3f
    ld bc,'AT'          ;41d6   $AT - argument transfer routine
    call CrBuilt        ;41d9   Creating built-in routine
    jp l41ach           ;41dc   --> ...
;*
;*
;*
s_41dfh:
    ld hl,(l0296h)      ;41df
    ld (DataID),hl      ;41e2   (DataID)=(l0296h)
    inc hl              ;41e5
    inc hl              ;41e6
    ld (l0296h),hl      ;41e7   (l0296h)=(l0296h)+2
    ld a,3              ;41ea
    ld (KindID),a       ;41ec   (KindID)=3 (Variable)
    dec a               ;41ef
    ld (ScopeID),a      ;41f0   (ScopeID)=2
    ld hl,0ffffh        ;41f3   hl=0ffffh
    ret                 ;41f6
;
;
;
s_41f7h:
    ld hl,(l01cfh)      ;41f7
    push hl             ;41fa \ Save (l01cfh) ----------------------------;
    call l375eh         ;41fb   { (l0251h)=0; ret }                       ;
    ex de,hl            ;41fe                                             ;
    jp l4204h   ;---;   ;41ff   --> ... hl=0            de=0              ;
                    ;                                                     ;
l4202h:             ;                                                     ;
    pop de          ;   ;4202 / Restore de                                ;
    dec de          ;   ;4203   de=de-1                                   ;
l4204h:        ;<---+                                                     ;
    push de             ;4204 \ Save de         ------------------------; ;
    ld hl,(l0209h)      ;4205           hl=(l0209h)                     ; ;
    add hl,de           ;4208           hl=(l0209h)+de                  ; ;
    ex de,hl            ;4209                           de=(l0209h)+de  ; ;
    ld hl,(HeapEnd)     ;420a           hl=(HeapEnd)                    ; ;
    call cmpHL.DE       ;420d                                           ; ;
    jp c,l422ah  ;--;   ;4210   if (HeapEnd) < (l0209h)+de --> ...      ; ;
    pop hl          ;   ;4213 /         hl=de   <-----------------------+ ;
    ld hl,(l0209h)  ;   ;4214                                             ;
    ld (HeapEnd),hl ;   ;4217   (HeapEnd)=(l0209h)                        ;
    ld (l020ch),hl  ;   ;421a   (l020ch) =(l0209h)                        ;
    ld hl,00000h    ;   ;421d                                             ;
    ld (l029dh),hl  ;   ;4220   (l029dh)=0                                ;
    ld (l029fh),hl  ;   ;4223   (l029fh)=0                                ;
    pop hl          ;   ;4226 / hl=(l01cfh) <-----------------------------+
    jp ExtAttr      ;   ;4227   --> Extract Attributes from the symbol table
                    ;
l422ah:         ;<--+
    ld a,(de)           ;422a   1a
    and 00011111b       ;422b
    ld (l0243h),a       ;422d   (l0243h)=
    ld b,a              ;4230   b=(l0243h)
    dec de              ;4231   de=de-1 
    ld a,(de)           ;4232   1a
    ld (TypeID),a       ;4233   (TypeID)=
    ex de,hl            ;4236   eb 
    dec hl              ;4237   2b
    ld d,(hl)           ;4238   56
    dec hl              ;4239   2b
    ld e,(hl)           ;423a   5e
    pop hl              ;423b / e1
    dec hl              ;423c   2b
    dec hl              ;423d   2b
    dec hl              ;423e   2b
    push hl             ;423f \ e5
    ex de,hl            ;4240   eb
    ld (l023bh),hl      ;4241   (l023bh)=
    ld (l01cfh),hl      ;4244   (l01cfh)=
    ld a,b              ;4247   Restore (l0243h)
    cp 6                ;4248
    jp z,l42deh         ;424a   if (l0243h).eq.6 --> ...
    or a                ;424d
    jp z,l4307h         ;424e   if (l0243h).eq.0 --> ...
    cp 0bh              ;4251
    jp c,l44bch         ;4253   if (l0243h) <  11 --> ...
    jp z,l43b5h         ;4256   if (l0243h).eq.11 --> ...
    cp 0ch              ;4259
    jp z,l43d0h         ;425b   if (l0243h).eq.12 --> ...
    cp 13h              ;425e
    jp z,l43f9h         ;4260   if (l0243h).eq.19 --> ...
    cp 14h              ;4263
    jp z,l43c4h         ;4265   if (l0243h).eq.20 --> ...
    cp 17h              ;4268
    jp z,l4461h         ;426a   if (l0243h).eq.23 --> ...
    cp 15h              ;426d
    jp z,l4436h         ;426f   if (l0243h).eq.21 --> ...
    push af             ;4272 \ Save (l0243h) --;
    call s_47b3h        ;4273   cd b3 47        ;
    pop af              ;4276 / <---------------+
    ld bc,l42d1h        ;4277   Point to l42d1h
    push bc             ;427a   Save to return
    sub 0dh             ;427b
    jp nz,l428ah ;--;   ;427d   if (l0243h).ne.13 --> ...
    ld a,017h       ;   ;4280   'RLA'
    call PutOpc     ;   ;4282
    ld a,03fh       ;   ;4285   'CCF'
    jp PutOpc       ;   ;4287   --> ...
                    ;
l428ah:       ;<----+
    dec a               ;428a
    jp nz,l429dh ;--;   ;428b   if (l0243h).ne.14 --> ...
    ld a,03dh       ;   ;428e   'DEC A'
    call PutOpc     ;   ;4290
    ld a,0c6h       ;   ;4293   'ADD A,byte'
    call PutOpc     ;   ;4295
    ld a,081h       ;   ;4298   a=81h
    jp p.byte       ;   ;429a   --> Put byte in reg A to REL file
                    ;
l429dh:       ;<----+
    dec a               ;429d
    jp nz,l42abh ;--;   ;429e   if (l0243h).ne.15 --> ...
    ld a,0c6h       ;   ;42a1   'ADD A,byte'
    call PutOpc     ;   ;42a3
    ld a,0ffh       ;   ;42a6   a=0ffh
    jp p.byte       ;   ;42a8   --> Put byte in reg A to REL file
                    ;
l42abh:       ;<----+
    dec a               ;42ab
    jp nz,l42b4h ;--;   ;42ac   if (l0243h).ne.16 --> ...
    ld a,017h       ;   ;42af   'RLA'
    jp PutOpc       ;   ;42b1   --> ...
                    ;
l42b4h:       ;<----+
    dec a               ;42b4
    jp nz,l42c7h ;--;   ;42b5   if (l0243h).ne.17 --> ...
    ld a,03dh       ;   ;42b8   'DEC A'
    call PutOpc     ;   ;42ba
    ld a,0d6h       ;   ;42bd   'SUB byte'
    call PutOpc     ;   ;42bf
    ld a,07fh       ;   ;42c2   a=7fh
    jp p.byte       ;   ;42c4   --> Put byte in reg A to REL file
                    ;
l42c7h:       ;<----+
    ld a,0d6h           ;42c7   'SUB byte'
    call PutOpc         ;42c9
    ld a,1              ;42cc   a=1
    jp p.byte           ;42ce   --> Put byte in reg A to REL file

l42d1h:
    ld a,09fh           ;42d1   'SBC A,A'
    call PutOpc         ;42d3
    ld a,002h           ;42d6
    ld (i_Type),a       ;42d8   (i_Type)=2 (BYTE)
    jp l44c4h           ;42db   --> ...
;
l42deh:
    xor a                   ;42de   a=0
    call s_3fa9h            ;42df   cd a9 3f
    pop de                  ;42e2 / d1
    push de                 ;42e3 \ d5
    dec de                  ;42e4   de=de-1
    ld hl,(l0209h)          ;42e5   2a 09 02 
    add hl,de               ;42e8   19
    ex de,hl                ;42e9   eb
    ld hl,(HeapEnd)         ;42ea   2a 15 02
    call cmpHL.DE           ;42ed   Compare HL with DE
    jp nc,l42fbh ;--;       ;42f0   if HL >= DE --> ...
    ld a,(de)       ;       ;42f3   1a
    and 00011111b   ;       ;42f4
    cp 6            ;       ;42f6
    jp z,l4202h     ;       ;42f8   if eq.6 --> ...
l42fbh:          ;<-+
    ld hl,(l0171h)          ;42fb
    ld (l023bh),hl          ;42fe   (l023bh)=(l0171h)
    call ExtAttr            ;4301   Extract Attributes from the symbol table
    jp l4366h   ;-------;   ;4304   --> ...
                        ;
l4307h:                 ;
    call s_54c8h        ;   ;4307   Extract Attributes from the symbol table, entry( l01cfh)
    cp 5                ;   ;430a
    jp z,l4346h  ;----; ;   ;430c   if (KindID).eq.5 (Routine) --> ...
    ld hl,TypeID      ; ;   ;430f
    ld a,(hl)         ; ;   ;4312
    or a              ; ;   ;4313
    jp nz,l4340h ;--; ; ;   ;4314   if (TypeID).ne.0 (INTEGER) --> ...
    pop de          ; ; ;   ;4317 / d1
    push de         ; ; ;   ;4318 \ d5
    push hl         ; ; ;   ;4319 \ 
    dec de          ; ; ;   ;431a   de=de-1
    ld hl,(l0209h)  ; ; ;   ;431b   2a 09 02
    add hl,de       ; ; ;   ;431e   19
    ex de,hl        ; ; ;   ;431f   eb
    ld hl,(HeapEnd) ; ; ;   ;4320   2a 15 02 
    call cmpHL.DE   ; ; ;   ;4323   Compare HL with DE
    ex de,hl        ; ; ;   ;4326   eb
    ld a,(hl)       ; ; ;   ;4327   7e
    dec hl          ; ; ;   ;4328   2b
    ld b,(hl)       ; ; ;   ;4329   46
    pop hl          ; ; ;   ;432a / e1
    jp nc,l4340h ;--; ; ;   ;432b   if (HeapEnd) >= DE --> ...
    and 00011111b   ; ; ;   ;432e
    cp 7            ; ; ;   ;4330
    jp nz,l4340h ;--; ; ;   ;4332   if ne 7 --> ...
    ld a,b          ; ; ;   ;4335   78
    cp 2            ; ; ;   ;4336
    jp nz,l4340h ;--; ; ;   ;4338   if ne 2 --> ...
    ld (hl),a       ; ; ;   ;433b   77
    ld hl,l0251h    ; ; ;   ;433c
    dec (hl)        ; ; ;   ;433f   (l0251h)=(l0251h)-1
l4340h:         ;<--+ ; ;
    call s_3ecch      ; ;   ;4340   cd cc 3e
    jp l4202h         ; ;   ;4343   --> ...
                      ; ;
l4346h:      ;<-------+ ;
    pop de              ;   ;4346 / d1
    push de             ;   ;4347 \ d5
    dec de              ;   ;4348   de=de-1
    ld hl,(l0209h)      ;   ;4349   2a 09 02
    add hl,de           ;   ;434c   19
    ex de,hl            ;   ;434d   eb
    ld hl,(HeapEnd)     ;   ;434e
    call cmpHL.DE       ;   ;4351   Compare HL with DE
    jp nc,l4366h  ;-----;   ;4354   if (HeapEnd) >= DE --> ...
    ex de,hl            ;   ;4357   eb
    ld a,(hl)           ;   ;4358   7e
    and 00011111b       ;   ;4359
    cp 6                ;   ;435b
    ld hl,(l023bh)      ;   ;435d
    ld (l0171h),hl      ;   ;4360   (l0171h)=(l023bh)
    jp z,l4202h         ;   ;4363   if eq 6 --> ...
l4366h:         ;<------+
    ld a,(ScopeID)          ;4366
    cp 3                    ;4369
    jp nz,l4387h ;--;       ;436b   if (ScopeID).ne.3 --> ...
    ld hl,(PrgSiz)  ;       ;436e
    inc hl          ;       ;4371
    ld (l0169h),hl  ;       ;4372   (l0169h)=(PrgSiz)+1
    ld a,021h       ;       ;4375   'LD HL,word'
    call s_486eh    ;       ;4377   Put opcode & word=0000 to REL file
    ld a,0e5h       ;       ;437a   'PUSH HL'
    call PutOpc     ;       ;437c
    call s_4123h    ;       ;437f   'LD HL,(word)'...
    ld a,0e5h       ;       ;4382   'PUSH HL'
    call PutOpc     ;       ;4384
l4387h:         ;<--+
    call s_4551h            ;4387   cd 51 45
    jp l44c4h               ;438a   --> ...

l438dh:
    ld a,001h           ;438d   'LD BC,word'
    call PutOpc         ;438f
    ld b,2              ;4392   b=2
    call w.code         ;4394   Output control prefix 1.b2.b1 (Reg B holds two bit control)
    ld hl,(l024ah)      ;4397   hl=(l024ah)
    ld a,(NoCode)       ;439a
    or a                ;439d   Test /N
    call z,s_5030h      ;439e   if (NoCode).eq.0 Put addres DATA" to console
    push hl             ;43a1 \ e5
    ld b,l              ;43a2   b=l
    call w.byte         ;43a3   Put byte to REL file from Reg B
    pop bc              ;43a6 / b=h
    call w.byte         ;43a7   Put byte to REL file from Reg B
    ld hl,(PrgSiz)      ;43aa
    inc hl              ;43ad
    inc hl              ;43ae
    ld (PrgSiz),hl      ;43af   (PrgSiz)=(PrgSiz)+2
    jp l4591h           ;43b2   --> ...
l43b5h:
    ld hl,(l023bh)      ;43b5
    ld (l01b0h),hl      ;43b8   (l01b0h)=(l023bh)
    call s_0dabh        ;43bb   Code generation DO statement
l43beh:         ;<--;
    call l375eh     ;   ;43be   (l0251h)=0 ret
    jp l4202h       ;   ;43c1   --> ...
                    ;
l43c4h:             ;
    ld hl,(l023bh)  ;   ;43c4
    ld (l01b0h),hl  ;   ;43c7   (l01b0h)=(l023bh)
    call s_369ah    ;   ;43ca   cd 9a 36
    jp l43beh   ;---+   ;43cd   --> ...
;
l43d0h:
    ld hl,l44c4h        ;43d0   Point to l44c4h
    push hl             ;43d3   Save to return
    ld a,(i_Type)       ;43d4
    or a                ;43d7
    jp z,l3a09h         ;43d8   if (i_Type).eq.0 (INTEGER) --> ...
    dec a               ;43db
    ld bc,'NB'          ;43dc   bc='NB'
    jp z,CrBuilt        ;43df   if (i_Type).eq.1 (REAL) --> Creating built-in routine $NB
    ld c,'U'            ;43e2   c='U'
    dec a               ;43e4
    dec a               ;43e5
    jp z,CrBuilt        ;43e6   if (i_Type).eq.3 (DOUBLE) --> Creating built-in routine $NU
    ld c,'1'            ;43e9   c='1'
    dec a               ;43eb
    jp z,CrBuilt        ;43ec   if (i_Type).eq.4 (INTEGER*4)--> Creating built-in routine $N1
    ld a,02fh           ;43ef   'CPL'
    call PutOpc         ;43f1
    ld a,03ch           ;43f4   'INC A'
    jp PutOpc           ;43f6   --> ...
;
l43f9h:
    call s_54c8h        ;43f9   Extract Attributes from the symbol table, entry (l01cfh)
    pop de              ;43fc / d1
    push de             ;43fd \ d5
    inc de              ;43fe
    inc de              ;43ff
    inc de              ;4400   de=de+3
    ld a,d              ;4401
    or e                ;4402   Test de
    jp z,l44a9h         ;4403   if de.eq.0 --> ...
    inc de              ;4406
    inc de              ;4407
    inc de              ;4408
    inc de              ;4409   de=de+4
    ld hl,(l0209h)      ;440a   2a 09 02
    add hl,de           ;440d   hl=(l0209h)+de
    ld a,(hl)           ;440e   7e
    and 00011111b       ;440f
    cp 6                ;4411
    jp z,l44a9h         ;4413   if eq 6 --> ...
    cp 7                ;4416
    jp z,l44a9h         ;4418   if eq 7 --> ...
    cp 13h              ;441b
    jp z,l44a9h         ;441d   if eq 13h --> ...
    ld hl,0ffffh        ;4420
    ld (l0251h),hl      ;4423   (l0251h)=-1
    ld a,(ScopeID)      ;4426
    cp 3                ;4429
    jp z,l447dh         ;442b   if(ScopeID).eq.3 --> ...
    ld a,011h           ;442e   'LD DE,word'
    call s_3fa9h        ;4430   cd a9 3f
    jp l4492h           ;4433   --> ...

l4436h:
    ld a,(i_Type)       ;4436
    or a                ;4439
    ld hl,l44c4h        ;443a   Point to l44c4h
    push hl             ;443d   save to return
    ld a,02fh           ;443e
    jp nz,PutOpc        ;4440   if(i_Type).ne.0 (INTEGER) --> 'CPL'
    ld a,07dh           ;4443   'LD A,L'
    call PutOpc         ;4445
    ld a,02fh           ;4448   'CPL'
    call PutOpc         ;444a
    ld a,06fh           ;444d   'LD L,A'
    call PutOpc         ;444f
    ld a,07ch           ;4452   'LD A,H'
    call PutOpc         ;4454
    ld a,02fh           ;4457   'CPL'
    call PutOpc         ;4459
    ld a,067h           ;445c   'LD H,A'
    jp PutOpc           ;445e   --> ...
;
l4461h:
    ld hl,l44c4h        ;4461   Point to l44c4h
    push hl             ;4464   save to return
    call l375eh         ;4465   { (l0251h)=0; ret }
    ld a,(TypeID)       ;4468
    ld (i_Type),a       ;446b   (i_Type)=(TypeID)
    or a                ;446e
    jp z,l3f52h         ;446f   if (i_Type).eq.0 (INTEGER) --> ...
    dec a               ;4472
    jp z,l3f18h         ;4473   if (i_Type).eq.1 (REAL) --> Load floating accumulator
    dec a               ;4476
    jp z,l3f45h         ;4477   if (i_Type).eq.2 (BYTE) --> ...
    jp l3f18h           ;447a   --> Load floating accumulator

l447dh:
    ld a,(i_Type)       ;447d
    or a                ;4480
    jp z,l448ah ;---;   ;4481   if(i_Type).eq.0 (INTEGER) --> ...
    call s_3682h    ;   ;4484   { 'LD L,A'->'RLA'->'SBC A,A'->'LD H,A' }
    ld (i_Type),a   ;   ;4487   (i_Type)=
l448ah:         ;<--+
    ld a,0ebh           ;448a   'EX DE,HL'
    call PutOpc         ;448c
    call s_4123h        ;448f   { 'LD HL,(word)'... }
l4492h:
    ld a,(i_Type)       ;4492
    or a                ;4495
    jp z,l449fh ;---;   ;4496   if (i_Type).eq.0 (INTEGER) --> ...
    call s_3682h    ;   ;4499   { 'LD L,A'->'RLA'->'SBC A,A'->'LD H,A' }
    ld (i_Type),a   ;   ;449c   (i_Type)=
l449fh:         ;<--+
    ld a,019h           ;449f   'ADD HL,DE'
    call PutOpc         ;44a1
l44a4h:
    ld a,1              ;44a4   a=1
    jp l44c5h   ;---;   ;44a6   --> ...
                    ;
l44a9h:             ;
    xor a           ;   ;44a9
    ld (i_Type),a   ;   ;44aa   (i_Type)=0 (INTEGER)
    ld a,(ScopeID)  ;   ;44ad
    cp 3            ;   ;44b0
    ld hl,l44a4h    ;   ;44b2   Point to l44a4h
    push hl         ;   ;44b5   Save to return
    jp z,s_4123h    ;   ;44b6   if(ScopeID).eq.3 --> 'LD HL,(word)'
    jp s_411eh      ;   ;44b9   --> 'LD HL,word'
                    ;
l44bch:             ;
    push af         ;   ;44bc \ f5
    call s_54c8h    ;   ;44bd   Extract Attributes from the symbol table, entry( l01cfh)
    pop af          ;   ;44c0 / f1
    call s_3a2ah    ;   ;44c1   cd 2a 3a
l44c4h:             ;
    xor a           ;   ;44c4   a=0
l44c5h:         ;<--+
    ld (l0276h),a       ;44c5   (l0276h)=
    pop de              ;44c8 / d1
    push de             ;44c9 \ d5
    inc de              ;44ca
    inc de              ;44cb
    inc de              ;44cc   de=de+3
    ld hl,(l0209h)      ;44cd
    add hl,de           ;44d0
    ld (l020ch),hl      ;44d1   (l020ch)=(l0209h)+de
    ex de,hl            ;44d4   eb
    call Neg_HL         ;44d5   Negate HL
    xor a               ;44d8   a=0
    push af             ;44d9 \ f5
    ex de,hl            ;44da   eb
    call s_6591h        ;44db   cd 91 65
    pop bc              ;44de / c1
    jp nz,l4202h        ;44df   if ne --> ...
    push bc             ;44e2 \ c5
    ld a,(hl)           ;44e3   7e
    and 00011111b       ;44e4
    cp 15h              ;44e6
    jp z,l65a3h         ;44e8   if a.eq.15h --> ...
    cp 17h              ;44eb
    jp z,l65a3h         ;44ed   if a.eq.17h --> ...
    cp 0ch              ;44f0
    jp c,l44fah  ;--;   ;44f2   if a < 0ch --> ...
    cp 13h          ;   ;44f5
    jp c,l65a3h     ;   ;44f7   if a < 13h --> ...
l44fah:         ;<--+
    pop bc              ;44fa / c1
    ld a,b              ;44fb   78
    or a                ;44fc   b7
    jp nz,l4543h  ;---; ;44fd   if ne 0 --> ...
    inc a             ; ;4500   3c
    push af           ; ;4501 \ f5
    ex de,hl          ; ;4502   eb
    ld hl,(l0209h)    ; ;4503
    call subHL.DE     ; ;4506   hl=(l0209h)-de
    push hl           ; ;4509 \ e5
    ld a,(i_Type)     ; ;450a
    ld b,a            ; ;450d   Save (i_Type)
    ld a,(l0276h)     ; ;450e
    or a              ; ;4511
    ld a,b            ; ;4512   Restore (i_Type)
    jp z,l451bh   ;-; ; ;4513   if (l0276h).eq.0 --> a=(i_Type)
    ld a,(TypeID)   ; ; ;4516   a=(TypeID)
    push af         ; ; ;4519 \ --------------------------------------------;
    xor a           ; ; ;451a   a=0                                         ;
l451bh:         ;<--+ ;                                                     ;
    call s_186ah      ; ;451b   Creation variable T:xxx in a symbol table   ;
    ld a,7            ; ;451e   a=7                                         ;
    call s_3a2ah      ; ;4520   cd 2a 3a                                    ;
    ld a,(l0276h)     ; ;4523                                               ;
    or a              ; ;4526                                               ;
    jp z,l4539h  ;--; ; ;4527   if (l0276h).eq.0 --> ...                    ;
    pop af          ; ; ;452a / <-------------------------------------------+
    ld (TypeID),a   ; ; ;452b   (TypeID)= (i_Type) or (TypeID)
    ld a,3          ; ; ;452e
    ld (ScopeID),a  ; ; ;4530   (ScopeID)=3
    call PutAttr    ; ; ;4533   Put Attributes in Symbol table
    call l375eh     ; ; ;4536   { (l0251h)=0; ret }
l4539h:         ;<--+ ;
    pop de            ; ;4539 / d1
    ld hl,(l0209h)    ; ;453a
    call subHL.DE     ; ;453d   hl=(l0209h)-de
    jp l4544h   ;---; ; ;4540   c3 44 45    . D E
                    ; ;
l4543h:      ;<-----)-+
    push af         ;   ;4543 \ f5  .
l4544h:         ;<--+
    ex de,hl            ;4544   eb 
    ld hl,(l01cfh)      ;4545   2a cf 01
    ex de,hl            ;4548   eb
    dec hl              ;4549   2b
    dec hl              ;454a   2b
    ld (hl),d           ;454b   72
    dec hl              ;454c   2b
    ld (hl),e           ;454d   73
    jp l65a3h           ;454e   --> ...
;*
;*
;*
s_4551h:
    ld hl,(l01cfh)      ;4551
    push hl             ;4554 \ Save (l01cfh)
    ld a,(l024ch)       ;4555
    or a                ;4558
    jp z,l4594h ;-----; ;4559   if (l024ch).eq.0  --> ...
    dec a             ; ;455c
    jp nz,l4566h ;-;  ; ;455d   if (l024ch).ne.1  --> ...
    call l4110h    ;  ; ;4560   cd 10 41
    jp l4594h   ;--)--; ;4563   --> ...
                   ;  ;
l4566h:      ;<----+  ;
    dec a             ; ;4566
    jp z,l4591h ;---; ; ;4567   if (l024ch).ne.2  --> ...
    dec a           ; ; ;456a
    jp nz,l438dh    ; ; ;456b   if (l024ch).ne.3  --> ...
    ld hl,(l024ah)  ; ; ;456e   hl=(l024ah)
    call ExtAttr    ; ; ;4571   Extract Attributes from the symbol table
    ld a,(ScopeID)  ; ; ;4574
    cp 3            ; ; ;4577
    jp z,l4584h ;-; ; ; ;4579   if (ScopeID).eq.3 --> ...
    ld a,001h     ; ; ; ;457c   'LD BC,word'
    call s_3fa9h  ; ; ; ;457e   cd a9 3f
    jp l4591h   ;-)-; ; ;4581   --> ...
                  ; ; ;
l4584h:      ;<---+ ; ;
    call s_4123h    ; ; ;4584   'LD HL,(word)'
    ld a,044h       ; ; ;4587   'LD B,H'
    call PutOpc     ; ; ;4589
    ld a,04dh       ; ; ;458c   'LD C,L'
    call PutOpc     ; ; ;458e
l4591h:       ;<----+ ;
    call s_40f2h      ; ;4591   cd f2 40
l4594h:       ;<------+
    pop hl              ;4594 / Restore (l01cfh)
    call ExtAttr        ;4595   Extract Attributes from the symbol table
    ld a,(TypeID)       ;4598
    ld (i_Type),a       ;459b   (i_Type)=(TypeID)
    ld a,(ScopeID)      ;459e
    cp 3                ;45a1
    jp z,l45c6h   ;---; ;45a3   if (ScopeID).eq.3 --> ...
    ld hl,(l01cfh)    ; ;45a6
    ex de,hl          ; ;45a9
    ld hl,(l01c6h)    ; ;45aa
    call cmpHL.DE     ; ;45ad
    jp nc,l45beh ;--; ; ;45b0   if (l01c6h) >= (l01cfh) --> ...
    ld a,03eh       ; ; ;45b3   'LD A,byte'
    call PutOpc     ; ; ;45b5
    ld a,(l024ch)   ; ; ;45b8   a=(l024ch)
    call p.byte     ; ; ;45bb   Put byte in reg A to REL file
l45beh:       ;<----+ ;
    ld a,0cdh         ; ;45be   'CALL word'
    call s_3fa9h      ; ;45c0   cd a9 3f
    jp l45d4h   ;---; ; ;45c3   --> ...
                    ; ;
l45c6h:       ;<----)-+
    ld a,0c9h       ;   ;45c6   'RET'
    call PutOpc     ;   ;45c8
    ld hl,(l0169h)  ;   ;45cb   hl=(l0169h)
    ld bc,0010ch    ;   ;45ce   Address modes CSEG, REL type - EXTERNAL-OFFSET (12)
    call s_589ah    ;   ;45d1   ex de<->hl -> RELITEM
l45d4h:       ;<----+
    xor a               ;45d4
    ld (l024ch),a       ;45d5   (l024ch)=0
    jp l375eh           ;45d8   --> (l0251h)=0; ret
;*
;*  Build standard fortran header
;*      LD BC,<return address>
;*      JP $INIT
;*
s_45dbh:
    ld a,(BlkDat)       ;45db
    or a                ;45de
    ret nz              ;45df   if(BlkDat).eq.0 (not Block data) Return
    ld hl,(l01cfh)      ;45e0
    push hl             ;45e3 \ Save (l01cfh)
    ld hl,l464dh        ;45e4   Point to l464dh
    push hl             ;45e7 \ Save to return
    ld hl,'$$'          ;45e8
    ld (l01d8h),hl      ;45eb   (l01d8h)='$$'
    ld a,2              ;45ee
    ld (SizeID),a       ;45f0   (SizeID)=2
    ld (KindID),a       ;45f3   (KindID)=2 (Label)
    xor a               ;45f6
    ld (TypeID),a       ;45f7   (TypeID)=0 (INTEGER)
    call s_055ah        ;45fa   cd 5a 05
    ld a,2              ;45fd
    ld (ScopeID),a      ;45ff   (ScopeID)=2
    ld hl,(PrgSiz)      ;4602   Load Program size
    ld de,00006h        ;4605   de=6 - Length code Header in bytes
    add hl,de           ;4608   19  . 
    ld (DataID),hl      ;4609   (DataID)=(PrgSiz)+6
    call PutAttr        ;460c   Put Attributes in Symbol table
    ld a,1              ;460f   'LD BC,word'
    call s_3fa9h        ;4611   cd a9 3f
    ld hl,l02ebh        ;4614   hl="$INIT" - Name routine (Sets the stack pointer at the top of available memory)
    ld de,l01d5h        ;4617   Destination address
    ld b,5              ;461a   b=5 (Length name)
    call l0863h         ;461c   Move B bytes from ^HL to ^DE
    ld a,5              ;461f
    ld (KindID),a       ;4621   (KindID)=5 (Routine)
    ld (SizeID),a       ;4624   (SizeID)=5 (Length name)
    call s_055ah        ;4627   cd 5a 05
    ld a,0c3h           ;462a   'JP word'
    call s_3fa9h        ;462c   cd a9 3f
    ld hl,(l0264h)      ;462f
    ld a,h              ;4632
    or l                ;4633
    ret z        ;----; ;4634   if (l0264h).eq.0 Return to l464dh
    call ExtAttr      ; ;4635   Extract Attributes from the symbol table
    ld a,(RomFlg)     ; ;4638
    or a              ; ;463b   Test /M
    jp nz,l4644h  ;-; ; ;463c   if (RomFlg).ne.0 --> ...
    ld a,(TypeID)   ; ; ;463f
    or a            ; ; ;4642
    ret nz      ;---)-; ;4643   if(TypeID).ne.0 (INTEGER) Return to l464dh
l4644h:       ;<----+ ;
    ld hl,(PrgSiz)    ; ;4644
    ld (DataID),hl    ; ;4647   (DataID)=(PrgSiz)
    jp PutAttr        ; ;464a   --> Put Attributes in Symbol table
                      ;
l464dh:     ;<--------+
    pop hl              ;464d / Restore (l01cfh)
    jp ExtAttr          ;464e   --> Extract Attributes from the symbol table
;
;   Processing RETURN
;
PrReturn:
    ld a,(MainFlg)      ;4651
    or a                ;4654
    jp nz,l465ch ;--;   ;4655   if (MainFlg).ne.0 (Subprogram) --> Skip error 
    call err.msg    ;   ;4658   Warning (25)
    db 25           ;   ;465b   RETURN in a Main Program
l465ch:     ;<------+
    call s_4665h        ;465c   cd 65 46    . e F 
    call g_n_chr        ;465f   Get next character
    jp l25bch           ;4662   --> Set 1 (l029ah) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_4665h:
    ld a,(SubrFlg)      ;4665
    or a                ;4668
    jp nz,l4675h ;--;   ;4669   if (SubrFlg).ne.0 (Subroutine) --> ...
    ld hl,(l0268h)  ;   ;466c
    ld (l01cfh),hl  ;   ;466f   (l01cfh)=(l0268h)
    call s_1479h    ;   ;4672   cd 79 14
l4675h:      ;<-----+
    call s_41f7h        ;4675   cd f7 41
    ld a,0c9h           ;4678   'RET'
    jp PutOpc           ;467a   --> ...
;
l467dh:
    ld hl,(l01cfh)      ;467d
    push hl             ;4680 \ Save (l01cfh)
    ld a,(ScopeID)      ;4681
    or a                ;4684
    jp z,l4691h  ;--;   ;4685   if (ScopeID).eq.0 --> ...
    cp 2            ;   ;4688
    jp z,l4691h  ;--;   ;468a   if (ScopeID).eq.2 --> skip error message
    call err.msg    ;   ;468d   Error (125)
    db 125          ;   ;4690   Illegal Statement Function Name
                    ;
l4691h:      ;<-----+
    ld a,5              ;4691
    ld (KindID),a       ;4693   (KindID)=5 (Routine)
    call PutAttr        ;4696   Put Attributes in Symbol table
    ld a,8              ;4699   a=8
    call s_5e97h        ;469b   cd 97 5e
    ld hl,(PrgSiz)      ;469e
    ld (DataID),hl      ;46a1   (DataID)=(PrgSiz)
    ld hl,ScopeID       ;46a4
    ld (hl),2           ;46a7   (ScopeID)=2
    call PutAttr        ;46a9   Put Attributes in Symbol table
    ld a,(PosStm)       ;46ac   3a 07 01
    push af             ;46af \ Save (PosStm)
    ld hl,PrCall        ;46b0
    ld (CurAdr),hl      ;46b3   (CurAdr)=point to Processing CALL
l46b6h:      ;<-----;
    call PrName     ;   ;46b6   Processing name
    ld hl,(l01cfh)  ;   ;46b9
    ld (l01b2h),hl  ;   ;46bc   (l01b2h)=(l01cfh)
    ld hl,(DataID)  ;   ;46bf
    ld (l01aeh),hl  ;   ;46c2   (l01aeh)=(DataID)
    ld hl,(ScopeID) ;   ;46c5
    ld (l01aah),hl  ;   ;46c8   (l01aah)=(ScopeID)
    ld a,(KindID)   ;   ;46cb
    ld (l01a8h),a   ;   ;46ce   (l01a8h)=(KindID)
    ld a,(TypeID)   ;   ;46d1
    ld (l01a9h),a   ;   ;46d4   (l01a9h)=(TypeID)
    ld hl,(EntryID) ;   ;46d7
    ld (l01a6h),hl  ;   ;46da   (l01a6h)=(EntryID)
    call l0e48h     ;   ;46dd   cd 48 0e
    ld a,(l0299h)   ;   ;46e0
    cp ','          ;   ;46e3
    jp z,l46b6h ;---+   ;46e5   if (l0299h).eq.',' --> ...
    ld hl,l467dh        ;46e8
    ld (CurAdr),hl      ;46eb   (CurAdr)=point to l467dh
    pop af              ;46ee / Restore (PosStm)
    ld (PosStm),a       ;46ef   (PosStm)=(PosStm)
    ld hl,l0299h        ;46f2
    ld (hl),'('         ;46f5   (l0298h)=028h "("
    call s_190fh        ;46f7   Processing of actual parameters subprogram
    call s_4165h        ;46fa   Generation instructions calling sequence for actual parameters
    ld a,'='            ;46fd
    call ch.chr         ;46ff   Check character (a character for check)
    ld hl,l0262h        ;4702
    ld (hl),009h        ;4705   (l0262h)=9
    xor a               ;4707   a=0
    call s_14e2h        ;4708   cd e2 14
    ld hl,l0262h        ;470b
    ld (hl),008h        ;470e   (l0262h)=8
    call s_1479h        ;4710   cd 79 14
    call s_41f7h        ;4713   cd f7 41
    pop hl              ;4716 / hl=(l01cfh)
    call ExtAttr        ;4717   Extract Attributes from the symbol table
    ld a,(i_Type)       ;471a
    ld hl,TypeID        ;471d
    cp (hl)             ;4720
    jp z,l4757h         ;4721   if (i_Type).eq.(TypeID) --> ...
    or a                ;4724
    jp nz,l4731h ;--;   ;4725   if (i_Type).ne.0 (INTEGER) --> ...
    or (hl)         ;   ;4728
    cp  2           ;   ;4729
    jp z,l4752h ;---)-; ;472b   if (i_Type) & (TypeID).eq.2 (BYTE) --> ...
    ld a,(i_Type)   ; ; ;472e
l4731h:      ;<-----+ ;
    sub 2             ; ;4731
    jp nz,l4740h ;--; ; ;4733   if (i_Type).ne.2 (BYTE) --> ...
    or (hl)         ; ; ;4736
    jp nz,l4740h ;--; ; ;4737   if (i_Type).ne.(TypeID) --> ...
    call s_3682h    ; ; ;473a   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
    jp l4757h ;---; ; ; ;473d   --> ...
                  ; ; ;
l4740h:      ;<---)-+ ;
    ld a,(i_Type) ;   ; ;4740
    rlca          ;   ; ;4743
    rlca          ;   ; ;4744
    rlca          ;   ; ;4745   (i_Type)*8
    add a,(hl)    ;   ; ;4746   (i_Type)*8+(TypeID) 
    add a,'@'     ;   ; ;4747   (i_Type)*8+(TypeID)+'@'
    ld c,a        ;   ; ;4749   c=(i_Type)*8+(TypeID)+'@'
    ld b,'C'      ;   ; ;474a   $Cc
    call CrBuilt  ;   ; ;474c   Creating built-in routine
    jp l4757h ;---;   ; ;474f   --> ...
                  ;   ;
l4752h:      ;<---)---+
    ld a,07dh     ;     ;4752   'LD A,L'
    call PutOpc   ;     ;4754
l4757h:  ;<-------+
    ld hl,l68f7h        ;4757
    ld (l01b0h),hl      ;475a   (l01b0h)=l68f7h
l475dh:         ;<--;
    call s_5609h    ;   ;475d   cd 09 56
    ld hl,(l01b2h)  ;   ;4760   2a b2 01
    call ExtAttr    ;   ;4763   Extract Attributes from the symbol table
    ld hl,(l01aeh)  ;   ;4766
    ld (DataID),hl  ;   ;4769   (DataID)=(l01aeh)
    ld a,(l01aah)   ;   ;476c
    ld (ScopeID),a  ;   ;476f   (ScopeID)=(l01aah)
    ld a,(l01a8h)   ;   ;4772
    ld (KindID),a   ;   ;4775   (KindID)=(l01a8h)
    ld a,(l01a9h)   ;   ;4778
    ld (TypeID),a   ;   ;477b   (TypeID)=(l01a9h)
    ld hl,(l01a6h)  ;   ;477e
    ld (EntryID),hl ;   ;4781   (EntryID)=(l01a6h) 
    call PutAttr    ;   ;4784   Put Attributes in Symbol table
    ld de,0000ah    ;   ;4787
    ld hl,(l01b0h)  ;   ;478a
    add hl,de       ;   ;478d
    ld (l01b0h),hl  ;   ;478e   (l01b0h)=(l01b0h)+10
    ex de,hl        ;   ;4791   
    ld hl,(l01a4h)  ;   ;4792   
    call cmpHL.DE   ;   ;4795   Compare HL with DE
    jp nz,l475dh ;--+   ;4798   if (l01a4h).ne.(l01b0h) --> ...
    ld hl,l68f7h        ;479b
    ld (l01a4h),hl      ;479e   (l01a4h)=l68f7h
    ld (HeapPtr),hl     ;47a1   (HeapPtr)=l68f7h
    ld hl,(l029bh)      ;47a4
    inc hl              ;47a7
    ld (l029bh),hl      ;47a8   (l029bh)=(l029bh)+1
    ld a,0c9h           ;47ab   'RET'
    call PutOpc         ;47ad
    jp l09ebh           ;47b0   Clear (l029ah) & (DO_Flg) -> Ending parsing
;*
;*
;*
s_47b3h:
    ld a,(i_Type)       ;47b3
    dec a               ;47b6
    ret z               ;47b7   if(i_Type).eq.1 (REAL)      Return
    cp 2                ;47b8
    ret z               ;47ba   if(i_Type).eq.3 (DOUBLE)    Return
    cp 3                ;47bb
    ret z               ;47bd   if(i_Type).eq.4 (INTEGER*4) Return
    dec a               ;47be
    jp nz,l47d1h  ;---; ;47bf   if(i_Type).ne.2 (BYTE) --> ...
    ld a,(l0243h)     ; ;47c2
    cp 015h           ; ;47c5
    jp z,l47cch  ;--; ; ;47c7   if(l0243h).eq.015h --> ...
    or a            ; ; ;47ca
    ret nz          ; ; ;47cb   if(l0243h).ne.0 Return
l47cch:         ;<--+ ;
    ld a,0b7h         ; ;47cc   'OR A'
    jp PutOpc         ; ;47ce   --> ...
                      ;
l47d1h:       ;<------+
    ld a,07dh           ;47d1   'LD A,L'
    call PutOpc         ;47d3
    ld a,007h           ;47d6   'RLCA'
    call PutOpc         ;47d8
    ld a,0b5h           ;47db   'OR L'
    call PutOpc         ;47dd
    ld a,0e6h           ;47e0   'AND byte'
    call PutOpc         ;47e2
    ld a,07fh           ;47e5   a=7fh
    call p.byte         ;47e7   Put byte in reg A to REL file
    ld a,0b4h           ;47ea   'OR H'
    jp PutOpc           ;47ec   --> ...
;*
;*  Put opcode to REL & PRN files
;*
PutOpc:
;   ld (MnCode),a           ;      (MnCode)=OpCode V3.4
    ld b,a                  ;47ef   Save OpCode
    ld a,(NoCode)           ;47f0
    or a                    ;47f3   Test /N
    jp nz,w.const           ;47f4   if (NoCode).ne.0 --> Put constant byte in reg B to REL file
    ld a,(enaLST)           ;47f7
    or a                    ;47fa   Test /L
    jp z,w.const            ;47fb   if(enaLST).eq.0 --> Put constant byte in reg B to REL file
    ld hl,OpcTab            ;47fe   hl=first OpCode from Table Mnemonic
l4801h:         ;<----;
      ld a,b          ;     ;4801   Restore OpCode
      cp (hl)         ;     ;4802   Compare opcode
      inc hl          ;     ;4803   hl=pointer 1 Mnemonic
      jp z,l4810h ;---)-;   ;4804   OpCode found
l4807h:       ;<----; ; ;
        ld a,(hl)   ; ; ;   ;4807   Get character
        or a        ; ; ;   ;4808   Test end Mnemonic
        inc hl      ; ; ;   ;4809
      jp p,l4807h ;-+ ; ;   ;480a   .. nope
    jp l4801h   ;-----+ ;   ;480d   Test next opcode
                        ;
l4810h:         ;<------+
    call s_5dcbh            ;4810   if (Column).ne.0 Put cr lf to console
    push hl                 ;4813
    call s_146ch            ;4814   Print '*****'
    pop hl                  ;4817
    call s_501bh            ;4818   Put addres DATA' to console
    call puttab             ;481b   Put tab to console
    call PrStrg             ;481e   Print string
    jp w.const              ;4821   --> Put constant byte in reg B to REL file
;*
;*  Put byte in reg A to REL file
;*
p.byte:
    ld b,a              ;4824   Save a
    ld a,(NoCode)       ;4825
    or a                ;4828   Test /N
    jp nz,w.const       ;4829   (NoCode).ne.0 --> Put constant byte in reg B to REL file
    ld a,b              ;482c   Restore a
    call puthex         ;482d   Put hex value A to console
    jp w.const          ;4830   --> Put constant byte in reg B to REL file
;*
;*  Put constant byte in reg A to REL file and bump pointer
;*
s_4833h:
    ld b,a              ;4833
;*
;*  Put constant byte in reg B to REL file and bump pointer
;*
w.const:
    ld hl,(PrgSiz)      ;4834   Load Program size
    inc hl              ;4837
    ld (PrgSiz),hl      ;4838   (PrgSiz)=(PrgSiz)+1 Add 1 to code pointer
    xor a               ;483b   a=0
    call w.bit          ;483c   Put zero bit
;*
;*  Put byte to REL file from Reg B
;*    ENTRY Reg B holds the byte for output
;*
w.byte:
    push bc             ;483f
    ld c,-8             ;4840   Set byte count
l4842h:         ;<--;
      ld a,b        ;   ;4842
      rla           ;   ;4843   .. get bit
      ld b,a        ;   ;4844
      call w.bit    ;   ;4845   .. put it
      inc c         ;   ;4848
    jp nz,l4842h ;--+   ;4849
    pop bc              ;484c
    ret                 ;484d
;
l484eh: db '*****',.tab ;484e

;*
;*  Put 'JP Z,word' & word=0000 to REL file
;*
s_4854h:
    ld a,0cah           ;4854   'JP Z,word'
    jp s_485bh  ;---;   ;4856   --> ...
                    ;
;*  Put 'JP word' & word=0000 to REL file
                    ;
s_4859h:            ;
    ld a,0c3h       ;   ;4859   'JP word'
s_485bh:        ;<--+
    push af             ;485b \ Save opcode
    ld hl,l0167h        ;485c               hl=l0167h
    ld a,(hl)           ;485f
    inc hl              ;4860               hl=l0167h+1
    or (hl)             ;4861
    pop bc              ;4862 / b=opcode
    ret nz              ;4863   if (l0167h+1).ne.(l0167h) Return
    ex de,hl            ;4864                           de=l0167h+1
    ld hl,(PrgSiz)      ;4865               hl=(PrgSiz)
    ex de,hl            ;4868               hl=l0167h+1 de=(PrgSiz)
    inc de              ;4869                           de=(PrgSiz)+1
    ld (hl),d           ;486a
    dec hl              ;486b
    ld (hl),e           ;486c   (l0167h+1)=(PrgSiz)+1
    ld a,b              ;486d   a=opcode
;*
;*  Put opcode & word=0000 to REL file
;*
s_486eh:
    call PutOpc         ;486e
    xor a               ;4871   a=0
    call p.byte         ;4872   Put byte in reg A to REL file
    xor a               ;4875   a=0
    jp p.byte           ;4876   --> Put byte in reg A to REL file

;#################
;# END MODULE    #
;#############$$##

;#################
;# START MODULE  #
;#################
;
;   Error msg table
;
ErrTab:
    db 080h                                         ;4879
    dc 'Illegal Statement Number'                   ;487a (100)
    dc 'Statement Unrecognizable or Misspelled'     ;4892 (101)
    dc 'Illegal Statement Completion'               ;48b8 (102)
    dc 'Illegal DO Nesting'                         ;48d4 (103)
    dc 'Illegal Data Constant'                      ;48e6 (104)
    dc 'Missing Name'                               ;48fb (105)
    dc 'Illegal Procedure Name'                     ;4907 (106)
    dc 'Invalid DATA Constant or Repeat Factor'     ;491d (107)
    dc 'Incorrect Number of DATA Constants'         ;4943 (108)
    dc 'Incorrect Integer Constant'                 ;4965 (109)
    dc 'Invalid Statement Number'                   ;497f (110)
    dc 'Not a Variable Name'                        ;4997 (111)
    dc 'Illegal Logical Form Operator'              ;49aa (112) ?
    dc 'Data Pool Overflow; Out of Memory'          ;49c7 (113)
    dc 'Literal String is too large'                ;49e8 (114)
    dc 'Invalid Data List Element in I/O'           ;4a03 (115)
    dc 'Unbalanced DO Nest'                         ;4a23 (116)
    dc 'Identifier Too Long'                        ;4a35 (117)
    dc 'Illegal Operator'                           ;4a48 (118)
    dc 'Mismatched Parenthesis'                     ;4a58 (119)
    dc 'Consecutive Operators'                      ;4a6e (120)
    dc 'Improper Subscript Syntax'                  ;4a83 (121) ?
    dc 'Illegal Integer Quantity'                   ;4a9c (122) ?
    dc 'Illegal Hollerith Constuction'              ;4ab4 (123)
    dc 'Backwards DO reference'                     ;4ad1 (124)
    dc 'Illegal Statement Function Name'            ;4ae7 (125)
    dc 'Illegal Character for Syntax'               ;4b06 (126)
    dc 'Statement is out of Sequence'               ;4b22 (127)
    dc 'Missing Integer Quantity'                   ;4b3e (128)
    dc 'Invalid Logical Operator'                   ;4b56 (129)
    dc 'Illegal Item in Type Declaration'           ;4b6e (130)
    dc 'Premature End Of File on input device'      ;4b8e (131)
    dc 'Illegal Mixed Mode Operation'               ;4bb3 (132).
    dc 'Function Call with No Parameters'           ;4bcf (133) ?
    dc 'Stack Overflow'                             ;4bef (134).
    dc 'Illegal Statement Following Logical IF'     ;4bfd (135).
    dc 'Wrong Number of Subscripts'                 ;4c23 (136).
    dc 'File Not Found'                             ;4c3d (137).
    dc 'Too Many Parentheses, 14 Allowed'           ;4c4b (138).
;
;   Warning msg table
;
WrnTab:
    db 080h                                         ;4c6b
    dc 'Duplicate Statement Label'                  ;4c6c (0)
    dc 'Illegal DO Termination'                     ;4c85 (1)
    dc 'Block Name = Procedure Name'                ;4c9b (2)
    dc 'Array Name Misuse'                          ;4cb6 (3)
    dc 'COMMON Name Usage'                          ;4cc7 (4)
    dc 'Wrong Number of Subscripts'                 ;4cd8 (5)
    dc 'Array Multiply EQUIVALENCEd Within a Group' ;4cf2 (6)
    dc 'Multiple EQUIVALENCE of COMMON'             ;4d1c (7)
    dc 'COMMON Base Lowered'                        ;4d3a (8)
    dc 'Non-COMMON Variable in BLOCK DATA'          ;4d4d (9)
    dc 'Empty List for Unformatted WRITE'           ;4d6e (10)
    dc 'Non-Integer Expression'                     ;4d8e (11) ?
    dc 'Operand Mode Not Compatible with Operator'  ;4da4 (12) ?
    dc 'Mixing of Operand Modes Not Allowed'        ;4dcd (13) ?
    dc 'Missing Integer Variable'                   ;4df0 (14)
    dc 'Missing Statement Number on FORMAT'         ;4e08 (15)
    dc 'Zero Repeat Factor'                         ;4e2a (16) ?
    dc 'Zero Format Value'                          ;4e3c (17)
    dc 'Format Nest Too Deep'                       ;4e4d (18)
    dc 'Statement Number not FORMAT Associated'     ;4e61 (19)
    dc 'Invalid Statement Number Usage'             ;4e87 (20)
    dc 'No Path to this Statement'                  ;4ea5 (21)
    dc 'Missing Do Termination'                     ;4ebe (22)
    dc 'Code Output in BLOCK DATA'                  ;4ed4 (23)
    dc 'Undefined Labels Have Occurred'             ;4eed (24)
    dc 'RETURN in a Main Program'                   ;4f0b (25)
    dc 'STATUS Error on READ'                       ;4f23 (26) ?
    dc 'Invalid Operand Usage'                      ;4f37 (27)
    dc 'Function with no Parameter'                 ;4f4c (28) ?
    dc 'Hex Constant Overflow'                      ;4f66 (29)
    dc 'Division by Zero'                           ;4f7b (30)
    dc 'X'                                          ;4f8b      d8
    dc 'Array Name Expected'                        ;4f8c (32)
    dc 'Illegal Argument to ENCODE/DECODE'          ;4f9f (33)
;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################
;?                           !! No execution path to here !!
    call puttab         ;4fc0   Put tab to console
;*
;*  Put addres HL to console
;*
putadr:
    push bc             ;4fc3   Save the contents of the registers
    push hl             ;4fc4
    ld a,(HexFlg)       ;4fc5
    or a                ;4fc8   Test /O
    jp nz,putoct        ;4fc9   if (HexFlg).ne.0 --> Put Octal to console
    ld a,h              ;4fcc
    call puthex         ;4fcd   Put hex value A to console
    ld a,l              ;4fd0
    call puthex         ;4fd1   Put hex value A to console
    pop hl              ;4fd4   Restore original register contents
    pop bc              ;4fd5
    ret                 ;4fd6   
;*
;*  Put hex value A to console
;*
puthex:
    push bc             ;4fd7   Save BC
    ld b,a              ;4fd8   Save original byte
    ld a,(HexFlg)       ;4fd9
    or a                ;4fdc   Test /O
    jp nz,l5013h  ;---; ;4fdd   if (HexFlg).ne.0 --> ...
    ld a,b            ; ;4fe0   Get original byte
    rrca              ; ;4fe1   Shift upper nybble into lower nybble
    rrca              ; ;4fe2
    rrca              ; ;4fe3
    rrca              ; ;4fe4
    call putdig       ; ;4fe5   Put digit to console
    ld a,b            ; ;4fe8   Get original byte
    call putdig       ; ;4fe9   Put digit to console
    pop bc            ; ;4fec   Restore BC
    ret               ; ;4fed   
                      ;
;*  Put digit to console
                      ;
putdig:               ;
    and 0fh           ; ;4fee   Mask out lower nybble (00001111b)
    add a,'0'         ; ;4ff0   Convert to ASCII digit, e.g. 0->'0'
    cp '9'+1          ; ;4ff2   Is it greater than '9'?
    jp c,putchr       ; ;4ff4   If not --> Put character to console
    add a,'A'-'0'-10  ; ;4ff7   Add offset to convert to hex letter A-F
    jp putchr         ; ;4ff9   --> Put character to console
                      ;
;*  Put Octal to console
                      ;
putoct:               ;
    ld c,6            ; ;4ffc   c=6
    xor a             ; ;4ffe   a=0
    jp l5007h ;-;     ; ;4fff   --> ...
                ;     ;
l5002h:    ;<---)---; ;
      xor a     ;   ; ; ;5002   af
      add hl,hl ;   ; ; ;5003   Get MSB
      adc a,a   ;   ; ; ;5004   8f
l5005h:     ;<--)-; ; ;
      add hl,hl ; ; ; ; ;5005   Shift word
      adc a,a   ; ; ; ; ;5006   Sample bits
l5007h:     ;<--+ ; ; ;
      add hl,hl   ; ; ; ;5007
      adc a,a     ; ; ; ;5008
      call putdig ; ; ; ;5009   Put digit to console
      dec c       ; ; ; ;500c   c=c-1
    jp nz,l5002h;-)-+ ; ;500d   if c.ne.0 --> ...
    pop hl        ;   ; ;5010
    pop bc        ;   ; ;5011
    ret           ;   ; ;5012   
                  ;   ;
l5013h:     ;<----)---+
    push hl       ;     ;5013   e5
    xor a         ;     ;5014   a=0
    ld h,b        ;     ;5015   60
    ld c,3        ;     ;5016   c=3
    jp l5005h ;---+     ;5018   --> ...
;*
;*  Put addres DATA' to console
;*
s_501bh:
    push hl             ;501b
    ld hl,(PrgSiz)      ;501c   Load Program size
    db 0feh             ;501f   cp 0e5h (in the original)   trap_ms
s_5020h:
    push hl             ;5020
    call putadr         ;5021   Put addres HL to console
    ld a,''''           ;5024   a="'"
l5026h:       ;<----;
    call putchr     ;   ;5026   Put character to console
    pop hl          ;   ;5029
    ret             ;   ;502a
                    ;
;*  Put addres DATA" to console
                    ;
;?                  ;        !! No execution path to here !!
    push hl         ;   ;502b
    ld hl,(DatSiz)  ;   ;502c   Load Data size
    db 0feh         ;   ;502f   cp 0e5h (in the original)   trap_ms
s_5030h:            ;
    push hl         ;   ;5030
    call putadr     ;   ;5031   Put addres to console
    ld a,'"'        ;   ;5034   a="
    jp l5026h   ;---+   ;5036   --> Put character to console
;*
;*  Print number in HL as decimal number
;*    ENTRY Reg HL
;*
PrNumb:
    push hl                 ;5039   Save the contents of the registers
    push bc                 ;503a
    push de                 ;503b
    ld de,l5074h            ;503c   Pointer to Decimal division table
    ld a,5                  ;503f   Set digit count
    or a                    ;5041   Reset Carry
l5042h:      ;<-----------;
    push af               ; ;5042 \ Save Carry status
l5043h:        ;<-------; ;
    ex de,hl            ; ; ;5043           hl=adrtbl de=num
    ld c,(hl)           ; ; ;5044
    inc hl              ; ; ;5045
    ld b,(hl)           ; ; ;5046   bc=(hl)
    inc hl              ; ; ;5047   hl=hl+2
    ex de,hl            ; ; ;5048           hl=num de=adrtbl+2
    xor a               ; ; ;5049   a=0
l504ah:       ;<----;   ; ;
      push hl       ;   ; ; ;504a \ e5
      add hl,bc     ;   ; ; ;504b   09
      jp nc,l5055h;-)-; ; ; ;504c   if a >= --> ...
      inc a         ; ; ; ; ;504f   a=a+1
      inc sp        ; ; ; ; ;5050   33
      inc sp        ; ; ; ; ;5051   33
    jp l504ah ;-----+ ; ; ; ;5052   --> ...
                      ; ; ;
l5055h:         ;<----+ ; ;
    pop hl              ; ; ;5055 / e1
    ld c,a              ; ; ;5056   save a
    pop af              ; ; ;5057 / Restore Carry status
    dec a               ; ; ;5058   a=a-1
    push af             ; ; ;5059 \ Save Carry status
    jp c,l5068h ;---;   ; ; ;505a
    jp z,l5068h ;---;   ; ; ;505d   if a.le.0 --> ...
    ld a,c          ;   ; ; ;5060   Restore a
    or a            ;   ; ; ;5061
    jp z,l5043h   ;-)---+ ; ;5062   if a.eq.0 --> ...
    pop af          ;     ; ;5065 / Restore Carry status
    scf             ;     ; ;5066   Set carry
    push af         ;     ; ;5067 \ Save Carry status
l5068h:         ;<--+     ;
    ld a,c                ; ;5068   Restore a
    call putdig           ; ;5069   Put digit to console
    pop af                ; ;506c / Restore Carry status
    jp nz,l5042h  ;-------+ ;506d   if a.ne.0 --> ...
    pop de                  ;5070   Restore original register contents
    pop bc                  ;5071
    pop hl                  ;5072
    ret                     ;5073
;*
;*  Decimal division table
;*
l5074h:
    dw  -10000          ;3ac9
    dw  -1000           ;3acb
    dw  -100            ;3acd
    dw  -10             ;3acf
    dw  -1              ;3ad1
;*
;*  Print HL hh (dd)
;*
pHexDec:
    call putadr         ;507e   Put addres HL to console
    ld a,' '            ;5081
    call putchr         ;5083   Put ' ' to console
    ld a,'('            ;5086
    call putchr         ;5088   Put '(' to console
    call PrNumb         ;508b   Print number in HL as decimal number
    ld a,')'            ;508e
    jp putchr           ;5090   --> Put ')' to console
;*
;*
;*
s_5093h:
    call puttab         ;5093   Put tab to console
s_5096h:
    ld a,(l01d9h)       ;5096
    cp 2ah              ;5099   '*'
    jp nz,l50cfh  ;--;  ;509b   if (l01d9h).ne.02ah --> ...
    ld hl,(l01cfh)   ;  ;509e
    push hl          ;  ;50a1 \ Save (l01cfh)
    ld hl,(DataID)   ;  ;50a2
    push hl          ;  ;50a5 \ Save (DataID) ----------------------------------------------------;
    ld hl,(l01d7h)   ;  ;50a6   hl=(l01d7h)                                                       ;
    call ExtAttr     ;  ;50a9   Extract Attributes from the symbol table                          ;
    call PutName     ;  ;50ac   Put string to console length (SizeID) starting at address l01d9h  ;
    ld hl,(DataID)   ;  ;50af   hl=(DataID)                                                       ;
    ex de,hl         ;  ;50b2               de=(DataID)                                           ;
    pop hl           ;  ;50b3 / hl=(DataID)   <---------------------------------------------------+
    call subHL.DE    ;  ;50b4   hl=hl-de
    ld a,h           ;  ;50b7   7c
    or a             ;  ;50b8   b7
    ld a,'+'         ;  ;50b9
    jp p,l50c0h ;--; ;  ;50bb   if positive --> ...
    ld a,'-'       ; ;  ;50be
l50c0h:         ;<-+ ;
    push af          ;  ;50c0 \ Save flags
    call putchr      ;  ;50c1   Put character to console
    pop af           ;  ;50c4 / Restore flags
    call m,Neg_HL    ;  ;50c5   if a < 0 Negate HL
    call putadr      ;  ;50c8   Put the contents HL to console
    pop hl           ;  ;50cb / hl=(l01cch)
    jp ExtAttr       ;  ;50cc   --> Extract Attributes from the symbol table
                     ;
l50cfh:           ;<-+
    ld a,(KindID)       ;50cf
    cp 6                ;50d2
    push af             ;50d4 \
    ld a,'/'            ;50d5
    call z,putchr       ;50d7   if (KindID).eq.6 (Common) Put '/' to console
    pop af              ;50da /
    push af             ;50db \ Save (KindID)
    dec a               ;50dc
    jp nz,l5112h  ;---; ;50dd   if (KindID).eq.1 (Constant)--> ...
    ld a,'['          ; ;50e0
    call putchr       ; ;50e2   Put '[' to console
    ld a,(SizeID)     ; ;50e5
    ld c,a            ; ;50e8   c=(SizeID)
    cpl               ; ;50e9
    ld e,a            ; ;50ea
    ld d,0ffh         ; ;50eb
    ld hl,l01dbh      ; ;50ed
    add hl,de         ; ;50f0   hl=DataID-(SizeID)
    jp l5102h   ;---+ ; ;50f1   --> ...
                    ; ;
l50f4h:        ;<-+ ; ;
      push bc     ; ; ; ;50f4 \
      push hl     ; ; ; ;50f5 \
      ld a,(hl)   ; ; ; ;50f6   a=(hl)
      call puthex ; ; ; ;50f7   Put hex value A to console
      ld a,' '    ; ; ; ;50fa
      call putchr ; ; ; ;50fc   Put ' ' to console
      pop hl      ; ; ; ;50ff /
      inc hl      ; ; ; ;5100   hl=hl+1
      pop bc      ; ; ; ;5101 /
l5102h:       ;<--)-+ ;
      dec c       ;   ; ;5102   c=c-1
    jp nz,l50f4h;-+   ; ;5103   if c.ne.0 next step
    ld a,(hl)         ; ;5106   a=(hl)
    call puthex       ; ;5107   Put hex value A to console
    ld a,']'          ; ;510a
    call putchr       ; ;510c   Put ']' to console
    jp l5139h    ;--; ; ;510f   --> ...
                    ; ;
l5112h:         ;<--)-+
    ld hl,l01d8h    ;   ;5112
    ld a,(hl)       ;   ;5115
    cp ':'          ;   ;5116
    jp nz,l5136h;-; ;   ;5118   if (l01d8h).ne.':' --> ...
    inc hl        ; ;   ;511b   hl=hl+1
    ld a,(hl)     ; ;   ;511c   a=(hl)
    call putchr   ; ;   ;511d   Put character to console
    dec hl        ; ;   ;5120   hl=hl-1
    ld a,(hl)     ; ;   ;5121   a=(hl)
    call putchr   ; ;   ;5122   Put character to console
    ld a,(SizeID) ; ;   ;5125
    sub 2         ; ;   ;5128
    ld b,a        ; ;   ;512a   b=(SizeID)-2
l512bh:           ; ;
      dec hl      ; ;   ;512b   hl=hl-1
      ld a,(hl)   ; ;   ;512c   a=(hl)
      call puthex ; ;   ;512d   Put hex value A to console 
      dec b       ; ;   ;5130   b=b-1
    jp nz,l512bh  ; ;   ;5131   if b.ne.0 next step
    pop af        ; ;   ;5134 / Restore balance stack (KindID)
    ret           ; ;   ;5135
                  ; ;
l5136h:       ;<--+ ;
    call PutName    ;   ;5136   Put string to console length (SizeID) starting at address l01d9h
l5139h:         ;<--+
    pop af              ;5139 / Restore (KindID)
    push af             ;513a \
    ld a,'/'            ;513b
    call z,putchr       ;513d   if (KindID).eq.0 Put character '/' to console
    pop af              ;5140 /
    cp 2                ;5141
    ld a,'L'            ;5143
    call z,putchr       ;5145   if (KindID).eq.2 (Label) Put character 'L' to console
    ret                 ;5148
;*
;*  Put string to console length (SizeID) starting at address l01d9h
;*
PutName:
    ld a,(SizeID)       ;5149
    ld c,a              ;514c   c=(SizeID)
    ld hl,l01d9h        ;514d   hl=l01d9h initial address the string
l5150h:        ;<---;
      ld a,(hl)     ;   ;5150   a=(hl)
      call putchr   ;   ;5151   Put character to console
      dec hl        ;   ;5154   hl=hl-1
      dec c         ;   ;5155   c=c-1
    jp nz,l5150h ;--+   ;5156   if c.ne.0 next step
    ret                 ;5159
;*
;*  Put TAB and CRLF
;*
TabCRLF:
l515ah:          ;<---;
    ld a,(Column)     ; ;515a 
    cp 72             ; ;515d
    jp nc,p.crlf      ; ;515f   if (Column) >= 72 --> Put cr lf to console
    or a              ; ;5162
    ret z             ; ;5163   if (Column).eq.0 Return
    cp 24             ; ;5164
    ret z             ; ;5166   if (Column).eq.24  Return
    jp nc,l5170h ;--; ; ;5167   if (Column) >= 24 --> ...
l516ah:        ;<-+ ; ;
    call puttab   ; ; ; ;516a   Put tab to console
    jp l515ah  ;--)-)-+ ;516d   --> ...
l5170h:      ;<---)-+
    cp 48         ;     ;5170
    ret z         ;     ;5172   if (Column).eq.48  Return
    jp l516ah ;---+     ;5173   --> ...
;*
;*  Completion compile the module
;*
l5176h:
    ld bc,0ah               ;5176   REL type - define DATA SIZE (1010b)
    ld hl,(DatSiz)          ;5179   Load data size
    ex de,hl                ;517c
    call RELITEM            ;517d   Give ABS data size
    ld hl,(l01a4h)          ;5180
    ex de,hl                ;5183
    ld hl,l68f7h            ;5184
    call cmpHL.DE           ;5187   Compare HL with DE
    jp z,l5191h ;---;       ;518a   if l68f7h.eq.(l01a4h) --> skip error message
    call err.msg    ;       ;518d   Warning (22)
    db 22           ;       ;5190   Missing Do Termination
l5191h:         ;<--+
    ld a,(BlkDat)           ;5191   Load Flag Block data
    or a                    ;5194
    jp z,l51a7h ;---;       ;5195   if (BlkDat).eq.0 (not Block data) --> ...
    ld hl,(PrgSiz)  ;       ;5198   Load Program size
    ld a,h          ;       ;519b
    or l            ;       ;519c
    jp z,Summary    ;       ;519d   if (PrgSiz).eq.0 --> Outputs the summary information about Program size, Data area length
    call err.msg    ;       ;51a0   Warning (23)
    db 23           ;       ;51a3   Code Output in BLOCK DATA
    jp Summary      ;       ;51a4   --> Outputs the summary information about Program size, Data area length
                    ;
l51a7h:         ;<--+
    ld hl,(l0264h)          ;51a7
    ld a,h                  ;51aa
    or l                    ;51ab
    jp nz,l51b6h ;---;      ;51ac   if (l0264h).ne.0 --> ...
    ld a,(l029ah)    ;      ;51af
    or a             ;      ;51b2
    jp nz,l51c9h ;---)--;   ;51b3   if (l029ah).ne.0 --> ...
l51b6h:        ;<----+  ;
    ld a,(MainFlg)      ;   ;51b6
    or a                ;   ;51b9
    jp z,l51c3h  ;-;    ;   ;51ba   if (MainFlg).eq.0 (Main program) --> ...
                   ;    ;           .. subprogram
    call s_4665h   ;    ;   ;51bd   
    jp l51c9h  ;---)-;  ;   ;51c0   --> ...
                   ; ;  ;
l51c3h:      ;<----+ ;  ;
    ld bc,'EX'       ;  ;   ;51c3   $EX - returns control to the OS
    call CrBuilt     ;  ;   ;51c6   Creating built-in routine
l51c9h:         ;<---+<-+
    xor a                   ;51c9
    ld (l0290h),a           ;51ca   (l0290h)=0
    call s_6885h            ;51cd   Extract Attributes from the symbol table, entry (l031fh)
l51d0h:         ;<-----+
    jp c,Summary       ;    ;51d0   if a < 0 --> Outputs the summary information about Program size, Data area length
    ld bc,l5220h       ;    ;51d3   Point to l5220h
    push bc            ;    ;51d6 \ Save the return
    dec a              ;    ;51d7
    jp nz,l5226h  ;----)-;  ;51d8   if a.ne.1 --> ...
    ld a,(TypeID)      ; ;  ;51db   Load value type variable
    cp 7               ; ;  ;51de
    ret z         ;--; ; ;  ;51e0   if (TypeID).eq.7 Return to l5220h
    ld hl,(DataID)   ; ; ;  ;51e1
    ld a,h           ; ; ;  ;51e4
    or l             ; ; ;  ;51e5
    ret z         ;--; ; ;  ;51e6   if (DataID).eq.0 --> Return to l5220h
    ex de,hl         ; ; ;  ;51e7
    ld bc,0010ch     ; ; ;  ;51e8   Address modes CSEG,rel type - EXTERNAL-OFFSET (12)
    ld a,(SegmID)    ; ; ;  ;51eb   Load Flag Address mode
    or a             ; ; ;  ;51ee
    jp z,l51f4h ;--; ; ; ;  ;51ef   if (SegmID).eq.0 (CSEG) --> ...
    ld b,2         ; ; ; ;  ;51f2   Address modes DSEG, rel type - EXTERNAL-OFFSET (12)
l51f4h:         ;<-+ ; ; ;
    call RELITEM     ; ; ;  ;51f4
    ld a,(NoCode)    ; ; ;  ;51f7
    or a             ; ; ;  ;51fa   test /N
    jp nz,l520ah ;-; ; ; ;  ;51fb   if (NoCode).ne.0  --> skip output
    call s_5dcbh   ; ; ; ;  ;51fe   if (Column).ne.0 Put cr lf to console
    call s_146ch   ; ; ; ;  ;5201   Print *****
    call s_501bh   ; ; ; ;  ;5204   Put addres DATA' to console
    call puttab    ; ; ; ;  ;5207   Put tab to console
l520ah:        ;<--+ ; ; ;
    ld hl,(l01cfh)   ; ; ;  ;520a   2a cf 01
    ld a,(SizeID)    ; ; ;  ;520d   3a b8 01
    call w.name      ; ; ;  ;5210   cd 11 58
;*                   ; ; ;
;*  (SegmID)=0 (DataID)=0 PutAttr
;*                   ; ; ;
s_5213h:             ; ; ;
    ld a,0           ; ; ;  ;5213   a=0 (CSEG)
    ld (SegmID),a    ; ; ;  ;5215   (SegmID)=0 Save Flag Address mode
    ld h,a           ; ; ;  ;5218
    ld l,a           ; ; ;  ;5219   hl=0
    ld (DataID),hl   ; ; ;  ;521a   (DataID)=0
    jp PutAttr       ; ; ;  ;521d   --> Put Attributes in Symbol table
                     ; ; ;
l5220h:           ;<-+ ; ;
    call s_688bh       ; ;  ;5220   Calculate address next symbol in the Symbols table; if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp l51d0h   ;------+ ;  ;5223   --> ...
                         ;
l5226h:     ;<-----------+
    dec a                   ;5226   3d
    jp nz,l524dh ;----;     ;5227   c2 4d 52
    inc a             ;     ;522a   3c
    ld (l0290h),a     ;     ;522b   (l0290h)=
    ld a,(ScopeID)    ;     ;522e
    or a              ;     ;5231
    ret nz            ;     ;5232   if (ScopeID).eq.0 Return to l5220h
    call ClrBuf20     ;     ;5233   Clear buffer ^l02b5h length 20
    ld hl,l02b5h      ;     ;5236   Destination address
    ld de,l01d9h      ;     ;5239   Source address
    ld a,(SizeID)     ;     ;523c
    ld b,a            ;     ;523f   b=(SizeID)
l5240h:        ;<---; ;
      ld a,(de)     ; ;     ;5240
      ld (hl),a     ; ;     ;5241   (hl)=(de)
      dec de        ; ;     ;5242   de=de-1
      inc hl        ; ;     ;5243   hl=hl+1
      dec b         ; ;     ;5244   b=b-1
    jp nz,l5240h ;--+ ;     ;5245   if b.ne.0 --> ...
    call err.msg      ;     ;5248   Warning (24)
    db 24             ;     ;524b   Undefined Labels Have Occurred
    ret               ;     ;524c   Return to l5220h
                      ;
l524dh:         ;<----+
    cp 3                    ;524d
    ret nz                  ;524f   if ne.3 Return to l5220h
    ld a,(ScopeID)          ;5250
    cp 2                    ;5253
    ret nc                  ;5255   if (ScopeID) >= 2 Return to l5220h
    ld bc,0106h             ;5256   Address modes CSEG, rel type - CHAIN EXTERNAL
    ld hl,(DataID)          ;5259
    ld a,h                  ;525c
    or l                    ;525d
    ret z                   ;525e   if (DataID).eq.0 Return to l5220h
    ld a,(SegmID)           ;525f   Load Flag Address mode
    or a                    ;5262
    jp z,l5268h ;---;       ;5263   if (SegmID).eq.0 (CSEG) --> ...
    ld b,2          ;       ;5266   Address modes DSEG, rel type - CHAIN EXTERNAL
l5268h:         ;<--+
    ex de,hl                ;5268   de=(DataID)
    jp RELITEM              ;5269
;*
;*  Outputs the summary information about Program size, Data area length
;*
Summary:
    call s_5dcbh            ;526c   if (Column).ne.0 Put cr lf to console
    ld hl,l53eah            ;526f   hl="Program Unit Length="
    call PrStrg             ;5272   Print string
    ld hl,(PrgSiz)          ;5275   Load Program size
    call pHexDec            ;5278   Print HL hh (dd)
;
    ld hl,l5400h            ;527b   hl="Bytes, Data Area Length="
    call PrStrg             ;527e   Print string
    ld hl,(DatSiz)          ;5281   Load Data size
    call pHexDec            ;5284   Print HL hh (dd)
;*
;*  Displays a list Subroutines
;*
    ld hl,l5419h            ;5287   hl="Bytes,Subroutines Referensed:"
    call PrStrg             ;528a   Print string
    call s_6885h            ;528d   Extract Attributes from the symbol table, entry (l031fh)
    jp c,l52b7h  ;------;   ;5290   if carry set (Found end of Symbol table) --> Displays list Variables
l5293h:       ;<------; ;
    cp 5              ; ;   ;5293
    jp nz,l52b1h ;--; ; ;   ;5295   if (KindID).ne.5 (Routine) --> ...
    ld a,(ScopeID)  ; ; ;   ;5298
    cp 2            ; ; ;   ;529b
    jp z,l52b1h  ;--; ; ;   ;529d   if (ScopeID).eq.2 --> ...
    ld hl,(DataID)  ; ; ;   ;52a0
    ld a,h          ; ; ;   ;52a3
    or l            ; ; ;   ;52a4
    jp z,l52b1h  ;--; ; ;   ;52a5   if (DataID).eq.0 --> ...
    call TabCRLF    ; ; ;   ;52a8   Put TAB and CRLF
    call s_5096h    ; ; ;   ;52ab   cd 96 50
    call s_5213h    ; ; ;   ;52ae   (SegmID)=0 (DataID)=0 PutAttr
l52b1h:          ;<-+ ; ;
    call s_688bh      ; ;   ;52b1   Calculate address next symbol in the Symbols table; if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp nc,l5293h   ;--+ ;   ;52b4   if (l0209h) < (l01cfh) --> ...
                        ;
l52b7h:        ;<-------+
;*
;*  Displays list Variables
;*
    call s_5dcbh            ;52b7   if (Column).ne.0 Put cr lf to console
    ld hl,l543eh            ;52ba   hl="Variables:"
    call PrStrg             ;52bd   Print string
    xor a                   ;52c0   a=0
    ld (l028ah),a           ;52c1   (l028ah)=0
    call s_6885h            ;52c4   Extract Attributes from the symbol table, entry (l031fh)
l52c7h:     ;<----------;
    jp c,l52eeh  ;------)-; ;52c7   if carry set (Found end of Symbol table) --> Displays COMMON Length
    cp 3                ; ; ;52ca
    jp z,l52d4h  ;-;    ; ; ;52cc   if (KindID).eq.3 (Variable)--> ...
    cp 4           ;    ; ; ;52cf
    jp nz,l52e8h ;-)-;  ; ; ;52d1   if (KindID).ne.4 (Array)--> ...
l52d4h:        ;<--+ ;  ; ;
    ld a,(l01d9h)    ;  ; ; ;52d4
    cp 02ah          ;  ; ; ;52d7   '*'
    jp z,l52e8h  ;---;  ; ; ;52d9   if (l01d9h).eq.02ah --> ...
    call TabCRLF     ;  ; ; ;52dc   Put TAB and CRLF
    call s_5096h     ;  ; ; ;52df   cd 96 50
    call puttab      ;  ; ; ;52e2   Put tab to console
    call s_549ch     ;  ; ; ;52e5   cd 9c 54
l52e8h:         ;<---+  ; ;
    call s_688bh        ; ; ;52e8   Calculate address next symbol in the Symbols table; if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp nc,l52c7h   ;----+ ; ;52eb   if (l0209h) < (l01cfh) --> ...
                          ;
l52eeh:          ;<-------+
;*
;*  Displays COMMON Length
;*
    call s_5dcbh            ;52ee   if (Column).ne.0 Put cr lf to console
    ld a,(l028ah)           ;52f1
    or a                    ;52f4
    jp z,l531eh  ;------;   ;52f5   if (l028ah).eq.0 skip output
    ld hl,l544eh        ;   ;52f8   hl="COMMON Length"
    call PrStrg         ;   ;52fb   Print string
    call s_6885h        ;   ;52fe   Extract Attributes from the symbol table, entry (l031fh)
l5301h:      ;<-------; ;
    jp c,l531eh  ;----)-;   ;5301   if carry set (Found end of Symbol table) --> Displays list Labels
    cp 6              ; ;   ;5304
    jp nz,l5318h ;--; ; ;   ;5306   if (KindID).ne.6 (Common) --> ...
    call TabCRLF    ; ; ;   ;5309   Put TAB and CRLF
    call s_5096h    ; ; ;   ;530c   cd 96 50
    ld hl,(DataID)  ; ; ;   ;530f   Load value COMMON Length
    call pHexDec    ; ; ;   ;5312   Print HL hh (dd)
    call p.crlf     ; ; ;   ;5315   Put cr lf to console
l5318h:         ;<--+ ; ;
    call s_688bh      ; ;   ;5318   Calculate address next symbol in the Symbols table; if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp nc,l5301h ;----+ ;   ;531b   if (l0209h) < (l01cfh) --> ...
                        ;
l531eh:        ;<-------+
;*
;*  Displays list Labels
;*
    call s_5dcbh            ;531e   if (Column).ne.0 Put cr lf to console
    ld a,(l0290h)           ;5321
    or a                    ;5324
    jp z,l536bh ;-------;   ;5325   if (l0290h).eq.0 skip output
    ld hl,l5461h        ;   ;5328   hl="Labels"
    call PrStrg         ;   ;532b   Print string
    call s_6885h        ;   ;532e   Extract Attributes from the symbol table, entry (l031fh)
l5331h:       ;<------+ ;
    jp c,l536bh ;-----)-;   ;5331   if carry set (Found end of Symbol table) --> Print number of Warning(s) detected
    cp 2              ; ;   ;5334
    jp nz,l5365h ;--; ; ;   ;5336   if (KindID).ne.2 (Label) --> ...
    call TabCRLF    ; ; ;   ;5339   Put TAB and CRLF
    call s_5096h    ; ; ;   ;533c   cd 96 50
    ld a,(ScopeID)  ; ; ;   ;533f
    or a            ; ; ;   ;5342
    jp z,l5365h  ;--; ; ;   ;5343   if (ScopeID).eq.0 --> ...
    call puttab     ; ; ;   ;5346   Put tab to console
    ld hl,(DataID)  ; ; ;   ;5349   2a 5d 01
    ld a,(RomFlg)   ; ; ;   ;534c
    or a            ; ; ;   ;534f   Test /M
    jp z,l5359h ;-; ; ; ;   ;5350   if (RomFlg).eq.0 --> skip output
    call s_5020h  ; ; ; ;   ;5353   Put addres DATA' to console     trap_ms
    jp l5365h   ;-)-; ; ;   ;5356   --> ...
                  ; ; ; ;
l5359h:        ;<-+ ; ; ;
    ld a,(TypeID)   ; ; ;   ;5359
    or a            ; ; ;   ;535c
    push af         ; ; ;   ;535d
    call z,s_5020h  ; ; ;   ;535e   if (TypeID).eq.0 (INTEGER?) Put addres DATA' to console trap_ms
    pop af          ; ; ;   ;5361
    call nz,s_5030h ; ; ;   ;5362   if (TypeID).ne.0 (INTEGER?) Put addres DATA" to console trap_ms
l5365h:        ;<---+ ; ;
    call s_688bh      ; ;   ;5365   Calculate address next symbol in the Symbols table; if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp nc,l5331h ;----+ ;   ;5368   if (l0209h) < (l01cfh) --> ...
                        ;
l536bh:           ;<----+
;*
;*  Print number of Warning(s) detected
;*
    ld a,1                  ;536b
    ld (conflg),a           ;536d   (conflg)=1 Force console
    ld hl,(WrnCnt)          ;5370   hl=Warning counter
    ld a,h                  ;5373
    or l                    ;5374
    jp z,l5389h  ;--;       ;5375   if (WrnCnt).eq.0 --> skip displaying message about the number of warnings
    call p.crlf     ;       ;5378   Put cr lf to console
    ld a,'%'        ;       ;537b
    call putchr     ;       ;537d   Put '%' to console
    call PrNumb     ;       ;5380   Print number in HL as decimal number
    ld hl,l546eh    ;       ;5383   hl=" Warning(s) Issued"
    call PrStrg     ;       ;5386   Print string
                    ;
l5389h:          ;<-+
;*
;*  Print a number of Fatal Error(s) detected
;*
    ld hl,(ErrCnt)          ;5389   hl=Error counter
    ld a,h                  ;538c
    or l                    ;538d
    jp z,l53a2h  ;--;       ;538e   if (ErrCnt).eq.0 --> Skip displaying message about the number of errors
    call p.crlf     ;       ;5391   Put cr lf to console
    ld a,'?'        ;       ;5394
    call putchr     ;       ;5396   Put '?' to console
    call PrNumb     ;       ;5399   Print number in HL as decimal number
    ld hl,l5482h    ;       ;539c   hl="Fatal Error(s) Detected"
    call PrStrg     ;       ;539f   Print string
l53a2h:      ;<-----+
    xor a                   ;53a2   a=0
    ld (conflg),a           ;53a3   (conflg)=0 Clear console
;
    ld hl,(PrgSiz)          ;53a6   Load Program size
    ld bc,010dh             ;53a9   Address modes CSEG, rel type - define PROGRAM SIZE
    ex de,hl                ;53ac
    call RELITEM            ;53ad   for CSEG program size ???
;
    ld a,(BlkDat)           ;53b0   Load Flag Block data
    or a                    ;53b3
    jp nz,l53cdh  ;--;      ;53b4   if (BlkDat).ne.0 (Block data) --> ...
    ld a,(MainFlg)   ;      ;53b7
    or a             ;      ;53ba
    jp z,l53d0h   ;--)--;   ;53bb   if (MainFlg).eq.0 (Main program) --> ...    trap_ms
                     ;  ;           ..Subprogram
    ld hl,(l0268h)   ;  ;   ;53be
    call ExtAttr     ;  ;   ;53c1   Extract Attributes from the symbol table
    ld bc,0107h      ;  ;   ;53c4   Address modes CSEG, Rel type - define ENTRY POINT
    ld de,00000h     ;  ;   ;53c7   de=0
    call RELITEM     ;  ;   ;53ca   Give code entry point
l53cdh:      ;<------+  ;
    ld b,0              ;   ;53cd   b=0 Address_modes ASEG
    db 011h    ;---;    ;   ;53cf   ld de,00106h (in the original)  trap_ms
l53d0h:      ;<----)----+
    ld b,1         ;        ;53d0   Address_modes CSEG
    ld c,0eh   ;<--+        ;53d2   Rel type - END PROGRAM (1110b)
    ld de,00000h            ;53d4   de=0
    call RELITEM            ;53d7   Give code end Program
;*
;*  Forces to byte boundary
;*
l53dah:           ;<---;
      ld hl,(l0159h)   ;    ;53da   hl=REL byte
      ld a,h           ;    ;53dd
      cp -8            ;    ;53de
      jp z,l0706h      ;    ;53e0   if a.eq.-8 --> Compile next module
      xor a            ;    ;53e3   a=0
      call w.bit       ;    ;53e4   Put zero bit
    jp l53dah     ;----+    ;53e7
;
l53eah:
    db cr,lf                                ;53ea
    dc 'Program Unit Length='               ;53ec
l5400h:
    db ' Bytes',cr,lf                       ;5400
    dc 'Data Area Length='                  ;5408
l5419h:
    db ' Bytes',cr,lf,cr,lf                 ;5419
    db 'Subroutines Referenced:'            ;5423
    db cr,lf,cr,.lf                         ;543a
l543eh:
    db cr,lf,'Variables:'                   ;543e
    db cr,lf,cr,.lf                         ;544a
l544eh:
    db cr,lf,'COMMON',tab,'Length'          ;544e
    db cr,lf,cr,.lf                         ;545d
l5461h:
    db cr,lf,'Labels:'                      ;5461
    db cr,lf,cr,.lf                         ;546a
l546eh:
    db ' Warning(s) Issued',cr,.lf          ;546e
l5482h:
    db ' Fatal Error(s) Detected',cr,.lf    ;5482
;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################
;*
;*
;*
s_549ch:
    ld a,(ScopeID)      ;549c
    dec a               ;549f
    ld hl,(DataID)      ;54a0   hl=(DataID)
    jp nz,s_5030h       ;54a3   if (ScopeID).ne.1 Put addres DATA" to console trap_ms
    inc a               ;54a6
    ld (l028ah),a       ;54a7   (l028ah)=(ScopeID)
    push hl             ;54aa \
    ld hl,(l01cfh)      ;54ab
    push hl             ;54ae \
    ld hl,(EntryID)     ;54af   hl=(EntryID)
    call ExtAttr        ;54b2   Extract Attributes from the symbol table
    call s_5096h        ;54b5   cd 96 50
    pop hl              ;54b8 / hl=(l01cfh)
    call ExtAttr        ;54b9   Extract Attributes from the symbol table
    ld a,'+'            ;54bc   a='+'
    call putchr         ;54be   Put character to console
    pop hl              ;54c1 / hl=(DataID)
    jp putadr           ;54c2   --> Put addres HL to console
;*
;*  Extract Attributes from the symbol table
;*    ENTRY Reg HL - ADDR
;*
ExtAttr:
    ld (l01cfh),hl      ;54c5   (l01cfh)=ADDR
;*
;*  Extract Attributes from the symbol table, entry (l01cfh)
;*
s_54c8h:
    ld hl,(l01cfh)      ;54c8
    inc hl              ;54cb   hl=hl+1
    ld a,h              ;54cc
    or l                ;54cd   Test hl
    dec hl              ;54ce   hl=hl-1
    ret z               ;54cf   if (l01cfh).eq.0ffffh Return
    ex de,hl            ;54d0
    ld hl,(l0209h)      ;54d1
    call cmpHL.DE       ;54d4   Compare HL with DE
    ex de,hl            ;54d7                               de=(l0209h) hl=(l01cfh)
    ret nc              ;54d8   if (l0209h) >= (l01cfh) Return
    ld a,(hl)           ;54d9                               Load byte from (l01cfh)
    and 01111111b       ;54da                               Clear high bit
    ld (SizeID),a       ;54dc   (SizeID)=(l01cfh).and.7fh
    ld b,a              ;54df                               b=(SizeID)
    ld a,(hl)           ;54e0                               Load byte from (l01cfh)
    and 10000000b       ;54e1                               Select the high bit from (l01cfh)
    rlca                ;54e3                               Place it in a zero bit
    ld (SegmID),a       ;54e4   (SegmID)=byte composed of high bit from (l01cfh)
    dec hl              ;54e7                               hl=(l01cfh)-1
    ld a,(hl)           ;54e8                               Load byte from (l01cfh)-1
    and 00000111b       ;54e9                               Select 3 low bits
    ld c,a              ;54eb                               c=(KindID)
    ld (KindID),a       ;54ec   (KindID)=byte composed of 3 low bits from (l01cfh)-1
    ld a,(hl)           ;54ef                               Load byte from (l01cfh)-1
    and 00111000b       ;54f0                               Select select with 3 on 5 bits
    rra                 ;54f2
    rra                 ;54f3
    rra                 ;54f4                               Place them in low bits
    ld (TypeID),a       ;54f5   (TypeID)= byte composed of with 3 on 5 bits
    ld a,(hl)           ;54f8                               Load byte from (l01cfh)-1
    and 11000000b       ;54f9                               Select two high bit
    rlca                ;54fb
    rlca                ;54fc                               Place them in two low bits
    ld (ScopeID),a      ;54fd   (ScopeID)=byte composed of with 6 on 7 bits
    dec hl              ;5500                               hl=(l01cfh)-2
    ld d,(hl)           ;5501
    dec hl              ;5502                               hl=(l01cfh)-3
    ld e,(hl)           ;5503                               de=word from (l01cfh)-2
    ex de,hl            ;5504                               de=(l01cfh)-3 hl=word from (l01cfh)-2
    ld (DataID),hl      ;5505   (DataID)=Word from (l01cfh)-2
    ex de,hl            ;5508                               de=(DataID) hl=(l01cfh)-3
    dec hl              ;5509                               hl=(l01cfh)-4
    ld d,(hl)           ;550a
    dec hl              ;550b                               hl=(l01cfh)-5
    ld e,(hl)           ;550c                               de=word from (l01cfh)-4
    dec hl              ;550d                               hl=(l01cfh)-6
    ex de,hl            ;550e                               de=(l01cfh)-6 hl=word from (l01cfh)-4
    ld (EntryID),hl     ;550f   (EntryID)=Word from (l01cfh)-4
    call s_0941h        ;5512   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)=0
;
    ld hl,l01d9h        ;5515   hl=l01d9h 
;                               de=(l01cfh)-6
;                               b=(SizeID)
l5518h:         ;<--;
      ld a,(de)     ;   ;5518
      ld (hl),a     ;   ;5519   (hl)=(de) 
      dec hl        ;   ;551a   hl=hl-1
      dec de        ;   ;551b   de=de-1
      dec b         ;   ;551c   b=b-1
    jp nz,l5518h ;--+   ;551d   if b.ne.0 copy next letter  de=(l01cfh)-6-(SizeID)

    ld a,c              ;5520                               a=(KindID)
    cp 4                ;5521
    jp nz,l553dh   ;--; ;5523   if (KindID).ne.4 (Array) --> ...
    ld hl,(DataID)    ; ;5526
    ld (l0220h),hl    ; ;5529   (l0220h)=(DataID)
    dec hl            ; ;552c                               hl=(DataID)-1
    ld a,(hl)         ; ;552d                               Load byte from (DataID)-1
    and 11000000b     ; ;552e                               Select two high bit
    rlca              ; ;5530
    rlca              ; ;5531                               Place them in two low bits
    ld (l0230h),a     ; ;5532   (l0230h)=byte composed of with 6 on 7 bits
    dec hl            ; ;5535                               hl=(DataID)-2
    ld d,(hl)         ; ;5536
    dec hl            ; ;5537                               hl=(DataID)-3
    ld e,(hl)         ; ;5538                               de=word from (DataID)-2
    ex de,hl          ; ;5539                               hl=word from (DataID)-2 de=(DataID)-3 
    ld (DataID),hl    ; ;553a   (DataID)=word from (DataID)-2
l553dh:           ;<--+
    ld a,(TypeID)       ;553d 
    cp 4                ;5540
    jp z,l5562h ;-----; ;5542   if (TypeID).eq.4 (INTEGER*4) --> ...
    cp 2              ; ;5545
    jp nz,l555ah  ;-; ; ;5547   if (TypeID).ne.2 (BYTE)      --> ...
    ld a,(KindID)   ; ; ;554a
    dec a           ; ; ;554d
    ld a,(TypeID)   ; ; ;554e
    jp nz,l555ah  ;-; ; ;5551   if (KindID).eq.1 (Constant)  --> ...
    ld hl,(l01d8h)  ; ; ;5554   
    ld (l01d6h),hl  ; ; ;5557   (l01d6h)=(l01d8h)
l555ah:        ;<---+ ;
                      ;
;   Calculation storage size variable according to the type
                      ;
    inc a             ; ;555a   a=(TypeID)+1
    rlca              ; ;555b   Multiply by 2
    or a              ; ;555c   for compatibility with z80
    jp po,l5562h ;-;  ; ;555d   if (TypeID).ne.3 (Byte) --> ...
    ld a,1         ;  ; ;5560   a=1
l5562h:        ;<--+<-+
    ld (l02abh),a       ;5562   (l02abh)=a
    ld a,(KindID)       ;5565
    or a                ;5568   Test (KindID)
    ret                 ;5569
;*
;*
;*
s_556ah:
    ld hl,(DataID)      ;556a
    push hl             ;556d \ Save (DataID)
    ld hl,(EntryID)     ;556e
    push hl             ;5571 \ Save (EntryID)
    ld hl,(l01cfh)      ;5572
    push hl             ;5575 \ Save (l01cfh)
    xor a               ;5576
    ld (l0276h),a       ;5577   (l0276h)=0
    ld a,(l0230h)       ;557a   3a 30 02
    ld hl,(l0220h)      ;557d   2a 20 02
    ld bc,0fffah        ;5580   01 fa ff
    add hl,bc           ;5583   09
    ld de,l026ah        ;5584   11 6a 02
l5587h:         ;<----;
    push af           ; ;5587 \ f5
    push de           ; ;5588 \ d5
    ld d,(hl)         ; ;5589   56
    dec hl            ; ;558a   2b
    ld e,(hl)         ; ;558b   5e
    dec hl            ; ;558c   2b
    ex (sp),hl        ; ;558d   e3
    push hl           ; ;558e \ e5
    ex de,hl          ; ;558f   eb
    call ExtAttr      ; ;5590   Extract Attributes from the symbol table
    ld a,(ScopeID)    ; ;5593
    cp 3              ; ;5596
    ld hl,(l01cfh)    ; ;5598   2a cf 01
    jp z,l55a3h ;---; ; ;559b   if (ScopeID).eq.3 --> ...
    or a            ; ; ;559e   b7
    ld hl,(l01d6h)  ; ; ;559f   2a d6 01
    db 6            ; ; ;55a2   ld b,037h (in the original) trap_ms
l55a3h:         ;<--+ ;
    scf               ; ;55a3
    ld bc,l0276h      ; ;55a4   01 76 02
    ld a,(bc)         ; ;55a7   0a
    rla               ; ;55a8   17
    ld (bc),a         ; ;55a9   02
    ex de,hl          ; ;55aa   eb
    pop hl            ; ;55ab   e1
    ld (hl),e         ; ;55ac   73
    inc hl            ; ;55ad   23
    ld (hl),d         ; ;55ae   72
    inc hl            ; ;55af   23
    ex de,hl          ; ;55b0   eb
    pop hl            ; ;55b1 / e1
    pop af            ; ;55b2 / f1
    dec a             ; ;55b3   a=a-1
    jp nz,l5587h  ;---+ ;55b4   if a.ne.0 -->
    ld a,(l0230h)       ;55b7
    ld hl,l0276h        ;55ba
    or a                ;55bd
    dec a               ;55be
    jp z,l55ech  ;----; ;55bf   if (l0230h).eq.0 -->
    dec a             ; ;55c2
    ld a,(hl)         ; ;55c3
    jp z,l55cdh ;-;   ; ;55c4   if (l0230h).eq.2 -->
    ld b,a        ;   ; ;55c7   Save (l0276h)-+
    and 6         ;   ; ;55c8   00000110b     |
    jp l55d1h ;-; ;   ; ;55ca   --> ...       |
                ; ;   ;                       |
l55cdh:     ;<--)-+   ;                       |
    rla         ;     ; ;55cd   17            |
    ld b,a      ;     ; ;55ce   Save a  ----+ |
    and 4       ;     ; ;55cf   00000100b   | |
l55d1h:     ;<--+     ;                     | |
    jp z,l55ech  ;--; ; ;55d1   ca ec 55    | |
    ld hl,l026dh    ; ; ;55d4   21 6d 02    | |
    ld a,b          ; ; ;55d7   Restore a <-+-+
    rra             ; ; ;55d8   1f
    rra             ; ; ;55d9   1f
    jp c,l55e2h ;-; ; ; ;55da   if carry --> ...
    push af       ; ; ; ;55dd \ ---------;
    call s_55fbh  ; ; ; ;55de   cd fb 55 ;
    pop af        ; ; ; ;55e1 / ---------+
l55e2h:      ;<---+ ; ;
    rra             ; ; ;55e2   1f
    jp c,l55ebh ;-; ; ; ;55e3   if carry --> ...
    dec hl        ; ; ; ;55e6
    dec hl        ; ; ; ;55e7   hl=hl-2
    call s_55fbh  ; ; ; ;55e8   cd fb 55
l55ebh:      ;<---+ ; ;
    scf             ; ; ;55eb   Set carry
l55ech:      ;<-----+-+
    pop hl              ;55ec / e1
    push af             ;55ed \ f5
    call ExtAttr        ;55ee   Extract Attributes from the symbol table
    pop af              ;55f1 / f1
    pop hl              ;55f2 / e1
    ld (EntryID),hl     ;55f3   (EntryID)=
    pop hl              ;55f6 / e1
    ld (DataID),hl      ;55f7   (DataID)=
    ret                 ;55fa
;*
;*    ENTRY Reg HL - ADDR
;*
s_55fbh:                ;                        de      hl      SP
    ld d,(hl)           ;55fb
    dec hl              ;55fc                           ADDR-1
    ld e,(hl)           ;55fd                  (ADDR)
    push hl             ;55fe \                                 ADDR-1
    ex de,hl            ;55ff \                 ADDR-1  (ADDR)
    call s_0523h        ;5600   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ex de,hl            ;5603   de=(l01cfh) 
    pop hl              ;5604 / hl=ADDR-1
    ld (hl),e           ;5605
    inc hl              ;5606
    ld (hl),d           ;5607   (ADDR-1)=(l01cfh)
    ret                 ;5608
;*
;*
;*
s_5609h:
    ld hl,(l01b0h)      ;5609   hl=(l01b0h)
    call s_562ch        ;560c   cd 2c 56
    ld (l01b2h),hl      ;560f   22 b2 01
    call s_562bh        ;5612   cd 2b 56
    ld (l01aeh),hl      ;5615   22 ae 01
    call s_562bh        ;5618   cd 2b 56
    ld (l01aah),hl      ;561b   22 aa 01
    call s_562bh        ;561e   cd 2b 56
    ld (l01a6h),hl      ;5621   22 a6 01
    call s_562bh        ;5624   cd 2b 56
    ld (l01a8h),hl      ;5627   22 a8 01
    ret                 ;562a
;*
;*
;*                              de          hl
s_562bh:                ;       Addr1       Addr2
    ex de,hl            ;562b   Addr2       Addr1 
s_562ch:
    ld e,(hl)           ;562c
    inc hl              ;562d               Addr2+1
    ld d,(hl)           ;562e   (Addr2)
    inc hl              ;562f               Addr2+2
    ex de,hl            ;5630   Addr2+2     (Addr2)
    ret                 ;5631
;*
;*  Processing BYTE, LOGICAL
;*                              Equivalent  Original
PrByte:
    ld a,2              ;5632      ld a,2      ld a,2
    db 021h             ;5634 ;-jp l563ch   ld hl,0033eh    trap_ms1 ***
                              ;
; Processing DOUBleprecision  ;
PrDouble:                     ;
    ld a,3              ;5635 ; ld a,3
    db 021h             ;5637 ;-jp l563ch   ld hl,0013eh    trap_ms1 ***
                              ;
; Processing REAL             ;
PrReal:                       ;
    ld a,1h             ;5638 ; ld a,1
    db 026h             ;563a ;-jp l563ch   ld h,0afh       trap_ms1 ***
                              ;
; Processing INTEGER          ;
PrIneger:                     ;
    xor a               ;563b ;
l563ch:             ;<--------+
    ld (tmpvar),a       ;563c   (tmpvar)=a
    call g_n_chr        ;563f   Get next character
    cp '*'              ;5642
    jp nz,l567dh  ;---; ;5644   if chr.ne.'*' --> Size specifier not found
    call g_n_chr      ; ;5647   Get next character
    jp p,l56ddh       ; ;564a   if chr Special character or Letter --> Error (130) Illegal Item in Type Declaration
    sub '0'           ; ;564d   Make binary from ASCII Size_storage in bytes
    ld b,a            ; ;564f   Save Size_storage
    ld a,(tmpvar)     ; ;5650
    dec a             ; ;5653
    jp z,l566fh  ;--; ; ;5654   if (tmpvar).eq.1 (REAL) --> ...
    cp 2            ; ; ;5657
    jp z,l566fh  ;--; ; ;5659   if (tmpvar).eq.3 (DOUBLE) --> ...
    ld a,b          ; ; ;565c   Restore Size_storage
    dec a           ; ; ;565d
    jp z,PrByte     ; ; ;565e   if Size_storage.eq.1 --> Processing BYTE
    dec a           ; ; ;5661
    jp z,PrIneger   ; ; ;5662   if Size_storage.eq.2 --> Processing INTEGER         trap_ms
    cp 2            ; ; ;5665
    jp nz,l56ddh    ; ; ;5667   if Size_storage.ne.4 --> Error (130) Illegal Item in Type Declaration
    ld a,004h       ; ; ;566a   a=4 (INTEGER*4)
    jp l563ch       ; ; ;566c   --> ...
                    ; ;
l566fh:         ;<--+ ;
    ld a,b            ; ;566f   Restore Size_storage
    cp 4              ; ;5670
    jp z,PrReal       ; ;5672   if Size_storage.eq.4 --> Processing REAL            trap_ms
    cp 8              ; ;5675
    jp z,PrDouble     ; ;5677   if Size_storage.eq.8 --> Processing DOUBleprecision trap_ms
    jp l56ddh         ; ;567a   Error (130) Illegal Item in Type Declaration
                      ;
l567dh:         ;<----+         Size specifier not found
    ld (l0173h),a       ;567d   (l0173h)=chr
    push af             ;5680   Save chr
    ld a,(PosStm)       ;5681
    ld (l01d1h),a       ;5684   (l01d1h)=(PosStm)
    ld a,6              ;5687
    call GetStr         ;5689   Reading string length 6 characters
    ld b,6              ;568c   b=6
    ld de,l01dch        ;568e   11 dc 01
    ld hl,l02d4h        ;5691   hl="FUNCTI"
    call cmpstr         ;5694   Compare strings ^HL:^DE with length in B
    jp nz,l56b6h ;--;   ;5697   if strings not "FUNCTI" --> no found "FUNCTION"
                    ;
;   Found FUNCTI    ;
                    ;
    ld a,2          ;   ;569a
    call GetStr     ;   ;569c   Reading string length 2 characters
    ld de,04f4eh    ;   ;569f   de="ON"
    ld hl,(l01e0h)  ;   ;56a2
    call cmpHL.DE   ;   ;56a5   Compare HL with DE
    jp nz,l56b6h ;--;   ;56a8   if (l01e0h).ne."ON" --> no found "FUNCTION"
    pop af          ;   ;56ab   Restore chr
    xor a           ;   ;56ac
    ld (l01d1h),a   ;   ;56ad   (l01d1h)=0
    ld a,(tmpvar)   ;   ;56b0   3a 8e 02
    jp l6833h       ;   ;56b3   --> Processing FUNCTION
                    ;
l56b6h:         ;<--+
;
; No found FUNCTION
;
    call s_5cceh        ;56b6   Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
    pop af              ;56b9   Restore chr
    ld (l0299h),a       ;56ba   (l0299h)=chr
    ld (l0173h),a       ;56bd   (l0173h)=chr
    ld hl,l56c6h        ;56c0
    ld (CurAdr),hl      ;56c3   (CurAdr)=point to l56c6h
l56c6h:
    call PrName         ;56c6   Processing name
    ld a,(tmpvar)       ;56c9
    ld (TypeID),a       ;56cc   (TypeID)=(tmpvar) Save value type variable
    call PutAttr        ;56cf   Put Attributes in Symbol table
    ld a,(l0299h)       ;56d2
    cp '('              ;56d5
    call z,s_19eeh      ;56d7   if (l0299h).eq.'(' --> Processing subscript an array
    jp l092fh           ;56da   --> Test continue processing statement
;
l56ddh:
    call err.msg        ;56dd   Error (130)
    db 130              ;56e0   82
;*
;*  Move 8 bytes from ^l01d2h to ^l01dah
;*
s_56e1h:
    ld hl,l01d2h        ;56e1   Source address
s_56e4h:
    ld de,l01dah        ;56e4   Destination address
s_56e7h:
    ld b,8              ;56e7   b=8
    jp l0863h           ;56e9   --> Move B bytes from ^HL to ^DE
;*
;*  Processing BACKSPACE u, ENDFILE u, REWIND u
;*
PrBackspace:
    call s_259eh        ;56ec   Processing integer constant
    xor a               ;56ef   a=0
    call s_3a2ah        ;56f0   cd 2a 3a
    ld a,(i_Type)       ;56f3
    or a                ;56f6
    jp z,l56fdh ;---;   ;56f7   if (i_Type).eq.0 (INTEGER) --> skip
    call s_3682h    ;   ;56fa   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
l56fdh:         ;<--+
    ld hl,l022eh        ;56fd   Load Pointer to location 1 and 2 bytes statement
    ld c,(hl)           ;5700   Loading second character statement
    inc hl              ;5701   hl=hl+1
    ld b,(hl)           ;5702   Loading first character statement
    call CrBuilt        ;5703   Creating built-in routine ($BA, $EN, or $RE)
    jp l09ebh           ;5706   --> Clear (l029ah) & (DO_Flg) -> Ending parsing
;*
;*
;*
s_5709h:
    ld a,(l0299h)           ;5709
    cp '.'                  ;570c
    jp z,s_573ch            ;570e   if (l0299h).eq.'.' --> Parsing Logical operation
    cp '*'                  ;5711
    jp z,l5785h  ;--------; ;5713   if (l0299h).eq.'*' --> ...
    ld de,00006h          ; ;5716   de=6
    ld hl,l0487h          ; ;5719   hl=pointer to Table Arithmetic Operators
l571ch:       ;<---;      ;
      cp (hl)      ;      ; ;571c
      jp z,l572ch;-)-;    ; ;571d   if (l0299h).eq.(hl) --> exit from loop
      dec hl       ; ;    ; ;5720   hl=hl-1
      dec e        ; ;    ; ;5721   e=e-1
    jp p,l571ch ;--+ ;    ; ;5722   if e >= 0
    xor a            ;    ; ;5725
    ld (l0243h),a    ;    ; ;5726   (l0243h)=0
    jp l5738h    ;-; ;    ; ;5729   c3 38 57
                   ; ;    ;
l572ch:       ;<---)-+<-; ;
    ex de,hl       ;    ; ; ;572c   eb
    add hl,hl      ;    ; ; ;572d   hl=hl+hl
    ld de,l04a6h   ;    ; ; ;572e   DE= Pointer Table
    add hl,de      ;    ; ; ;5731   hl=hl+de offset calculation
    ld a,(hl)      ;    ; ; ;5732
    ld (l0243h),a  ;    ; ; ;5733   (l0243h)= first byte in the table
    inc hl         ;    ; ; ;5736
    ld a,(hl)      ;    ; ; ;5737   7e
l5738h:    ;<------+    ; ;
    ld (l01b4h),a       ; ; ;5738   (l01b4h)= second byte in the table
    ret                 ; ; ;573b
                        ; ;
;   Parsing Logical operation
                        ; ;
s_573ch:                ; ;
    ld a,3              ; ; ;573c   a=3
    call GetStr         ; ; ;573e   Reading string length 3 characters
    ld de,0000ah        ; ; ;5741   de=10 - counrer
    ld hl,l04a3h        ; ; ;5744   hl=point to table Logical operations
l5747h:         ;<----; ; ;
      push de         ; ; ; ;5747
      push hl         ; ; ; ;5748
      ld b,3          ; ; ; ;5749   b=3 length Logical operations
      ld de,l01dfh    ; ; ; ;574b   11 df 01
      call cmpstr     ; ; ; ;574e   Compare strings ^HL:^DE with length in B
      pop hl          ; ; ; ;5751
      pop de          ; ; ; ;5752
      jp z,l576ch ;-; ; ; ; ;5753   if strings eq --> Found Logical operation
      dec hl        ; ; ; ; ;5756
      dec hl        ; ; ; ; ;5757
      dec hl        ; ; ; ; ;5758   hl=hl-3 update pointer to next Logical operation
      dec e         ; ; ; ; ;5759   e=e-1
    jp nz,l5747h ;--)-+ ; ; ;575a   if e.ne.0 --> ...
                    ;   ; ;
l575dh:      ;<-----)-; ; ;
    ld hl,(TopMem)  ; ; ; ; ;575d   Load value Top of memory
    ld sp,hl        ; ; ; ; ;5760   Set for stack
    ld a,(l01d1h)   ; ; ; ; ;5761
    or a            ; ; ; ; ;5764
    jp nz,l64fdh    ; ; ; ; ;5765   if (l01d1h).ne.0 --> Search statement
    call err.msg    ; ; ; ; ;5768   Error (129)
    db 129          ; ; ; ; ;576b   Invalid Logical Operator
                    ; ; ; ;
;   Found Logical operation
                    ; ; ; ;
l576ch:         ;<--+ ; ; ;
    ld a,6            ; ; ; ;576c
    add a,e           ; ; ; ;576e
    ld e,a            ; ; ; ;576f   e=e+6
    ld a,(l0299h)     ; ; ; ;5770
    cp '.'            ; ; ; ;5773
    jp z,l572ch    ;--)-; ; ;5775   if (l0299h).eq.'.' --> ...
    push de           ; ; ; ;5778 \
    call g_n_chr      ; ; ; ;5779   Get next character
    cp '.'            ; ; ; ;577c
    pop de            ; ; ; ;577e /
    jp z,l572ch    ;--)-; ; ;577f   if chr.eq.'.' --> ...
    jp l575dh  ;------+ ; ; ;5782   --> ...
                        ; ;
l5785h:     ;<----------)-+
    call g_n_chr        ;   ;5785   Get next character
    cp '*'              ;   ;5788
    ld de,00011h        ;   ;578a   de=17
    jp z,l572ch    ;----;   ;578d   if str.eq.'*' --> ...
    ld (l0173h),a       ;   ;5790   (l0173h)=str
    ld e,2              ;   ;5793   e=2
    jp l572ch      ;----+   ;5795   --> ...
;*
;*  ENTRY
;*    Reg DE - PAR1
;*    Reg BC - PAR2
;*
s_5798h:
    ld hl,00000h            ;5798   hl=0
    ld a,16                 ;579b   a=16
l579dh:          ;<----;
      add hl,hl        ;    ;579d   hl=hl*2
      ex de,hl         ;    ;579e   hl=PAR1     de=hl*2
      add hl,hl        ;    ;579f   hl=PAR1*2
      ex de,hl         ;    ;57a0   hl=hl*2     de=PAR1*2
      jp nc,l57a5h ;-; ;    ;57a1   if >= --> ...
      add hl,bc      ; ;    ;57a4   hl=hl*2+PAR2
l57a5h:         ;<---+ ;
      dec a            ;    ;57a5   a=a-1
    jp nz,l579dh   ;---+    ;57a6   if a.ne.0 --> ...
    ret                     ;57a9
;*
;*  Negate HL
;*
Neg_HL:
    xor a               ;57aa   a=0
    sub l               ;57ab   a=a-l
    ld l,a              ;57ac   l=-l
    sbc a,h             ;57ad   a=a-h-Carry
    sub l               ;57ae
    ld h,a              ;57af   h=a-l
    ret                 ;57b0
;*
;*  Give Special LINK items:
;*
;     Control_field Adr_mode Address Length
;1 00     xxxx       yy      nn      zzz     + characters of Symbol_name
;          C         B       DE     (SizeID)         l01d9h
;
;     ENTRY Reg  C holds xxxx Control_field (REL type)
;           Reg  B holds Address_mode (0-ASEG, 1-CSEG, 2-DSEG, 3-COMMON)
;           Reg DE holds Address
RELITEM:
    push bc             ;57b1 \
    ld b,00b            ;57b2
    call w.code         ;57b4   Write special item
    ld b,c              ;57b7   Get bits
    ld a,4              ;57b8   Set count
    call w.bits         ;57ba   Put control
    pop bc              ;57bd /
    ld a,c              ;57be   Get code back
    cp 0100b+1          ;57bf   Test name field only
    jp c,l57d8h  ;--;   ;57c1   .. yeap
    cp 15           ;   ;57c4   Test end of file
    ret z           ;   ;57c6   .. Yeap, no more follows
    ld a,2          ;   ;57c7
    call w.bits     ;   ;57c9   Give address bits
    ld b,e          ;   ;57cc
    call w.byte     ;   ;57cd   Put low
    ld b,d          ;   ;57d0
    call w.byte     ;   ;57d1   .. and high
    ld a,c          ;   ;57d4
    cp 8            ;   ;57d5   Test name field follows
    ret nc          ;   ;57d7   .. nope
l57d8h:         ;<--+
    ld a,(SizeID)       ;57d8   3a b8 01
    ld b,a              ;57db
    ld d,a              ;57dc   Set counter
    ld a,3              ;57dd
    call w.bits         ;57df   Give length
    push hl             ;57e2 \
;*
;*  Put name
;*
    ld hl,l01d9h        ;57e3   21 d9 01
l57e6h:         ;<--;
      ld b,(hl)     ;   ;57e6
      ld a,b        ;   ;57e7
      and 07fh      ;   ;57e8   Reset bit 7
      ld b,a        ;   ;57ea
      call w.byte   ;   ;57eb   .. Put chr
      dec hl        ;   ;57ee   hl=hl-1
      dec d         ;   ;57ef   d=d-1
    jp nz,l57e6h ;--+   ;57f0   if d.ne.0 --> put next chr
    pop hl              ;57f3 /
    ret                 ;57f4
;*
;*  Output n bits
;*    ENTRY Reg A holds bit count
;*          Reg B holds bits to be outputted
;*
w.bits:
    push de             ;57f5
    ld d,a              ;57f6   Get count
    ld a,8              ;57f7
    sub d               ;57f9   Calculate remaining bits
    jp z,l5805h ;-----; ;57fa   .. boundary
    ld e,a            ; ;57fd
    ld a,b            ; ;57fe
l57ffh:       ;<----; ;
      add a,a       ; ; ;57ff   Left justify bits
      dec e         ; ; ;5800
    jp nz,l57ffh ;--+ ; ;5801
    ld b,a            ; ;5804
l5805h:       ;<------+
t5805h:       ;<------;
      ld a,b          ; ;5805   Get value
      add a,a         ; ;5806   .. get carry
      ld b,a          ; ;5807
      call w.bit      ; ;5808   Write it
      dec d           ; ;580b
    jp nz,t5805h  ;---+ ;580c
    pop de              ;580f
    ret                 ;5810
;*
;*  Put Name from Symbol table to REL file
;*    ENTRY
;*      Reg A  - SizeID
;*      Reg HL - ADDR
;*
w.name:
    push af             ;5811 \ Save SizeID
    cpl                 ;5812
    sub 4               ;5813
    ld c,a              ;5815
    ld b,0ffh           ;5816   bc = SizeID-5
    add hl,bc           ;5818   hl=ADDR-SizeID-5
    db 0feh             ;5819   cp 0f5h (in the original)   trap_ms
l5581ah:        ;<----;
      push af         ; ;581a \
      push hl         ; ;581b \
      ld a,(hl)       ; ;581c
      call p.byte     ; ;581d   Put byte in reg A to REL file
      ld a,' '        ; ;5820
      call putchr     ; ;5822   Put ' ' to console
      pop hl          ; ;5825 /
      pop af          ; ;5826 /
      dec a           ; ;5827   a=a-1
      inc hl          ; ;5828   hl=hl+1
    jp nz,l5581ah ;---+ ;5829   Put next byte
    ret                 ;582c
;*
;*  Output control prefix 1.b2.b1
;*    ENTRY Reg B holds two bit control
;*
w.code:
    scf                 ;582d   Set bit
    call w.bit          ;582e   Write it (Put 1)
    ld a,b              ;5831
    rra                 ;5832   Get b2
    rra                 ;5833
    call w.bit          ;5834   Write it (Put b2)
    ld a,b              ;5837
    rra                 ;5838   Get b1 and write it
;*
;*  Put bit (CY) to REL file
;*    ENTRY Carry indicates bit set
;*
w.bit:
    push hl             ;5839
    ld hl,l0159h        ;583a   Point to REL byte
    ld a,(hl)           ;583d   Get current value
    rla                 ;583e   .. shift carry in
    ld (hl),a           ;583f
    inc hl              ;5840
    inc (hl)            ;5841   Test bits remaining
    jp nz,l5851h ;--;   ;5842   .. yeap
    ld a,(l0159h)   ;   ;5845
    call oput       ;   ;5848   Put byte to REL file
    ld hl,0f800h    ;   ;584b   h=-8
    ld (l0159h),hl  ;   ;584e   Reset bit count
l5851h:         ;<--+
    pop hl              ;5851
    ret                 ;5852
;*
;*
;*
s_5853h:
    ld hl,(DataID)      ;5853
    ld a,h              ;5856
    or l                ;5857
    ret z               ;5858   if (DataID).eq.0 Return
    ld bc,0010ch        ;5859   Address modes CSEG, rel type - PRGSIZ
    ld a,(TypeID)       ;585c   Load value type variable
    or a                ;585f
    jp z,l5892h ;-----; ;5860   if (TypeID).eq.0 (INTEGER) --> ...
    push bc           ; ;5863 \
    push hl           ; ;5864 \
    ld a,(RomFlg)     ; ;5865
    or a              ; ;5868   Test /M
    jp z,l587fh ;---; ; ;5869   if (RomFlg).eq.0 --> ...
    ld hl,(PrgSiz)  ; ; ;586c   Load Program size
    ld a,(l020eh)   ; ; ;586f
    or a            ; ; ;5872
    jp nz,l5879h;-; ; ; ;5873   if (l020eh).ne.0 --> ...
    inc hl        ; ; ; ;5876
    inc hl        ; ; ; ;5877
    inc hl        ; ; ; ;5878   hl=(PrgSiz)+3
l5879h:       ;<--+ ; ;
    call l6572h     ; ; ;5879   cd 72 65
    jp l5887h  ;--; ; ; ;587c   --> ...
                  ; ; ;
l587fh:       ;<--)-+ ;
    inc b         ;   ; ;587f   b=b+1
    dec c         ;   ; ;5880   c=c-1
    ld hl,(DatSiz);   ; ;5881   Load Data size
    call s_6575h  ;   ; ;5884   cd 75 65
l5887h:        ;<-+   ;
    pop de            ; ;5887 / de=(DataID)
    pop bc            ; ;5888 / Address modes CSEG, rel type - PRGSIZ
    call RELITEM      ; ;5889   cd b1 57
    ld hl,(l021eh)    ; ;588c   2a 1e 02
    jp l6572h         ; ;588f   --> ...
                      ;
l5892h:           ;<--+
    ld a,(SegmID)       ;5892   Load Flag Address mode
    or a                ;5895
    jp z,s_589ah  ;---; ;5896   if (SegmID).eq.0 (CSEG) --> ...
    inc b             ; ;5899   Address modes DSEG, rel type - PRGSIZ
s_589ah:          ;<--+
    ex de,hl            ;589a   de=(DataID)
    jp RELITEM          ;589b   --> ...
;*
;*  Assign name "$MAIN" and put name main program to REL file
;*
s_589eh:
    ld hl,l02e6h        ;589e   hl="$MAIN"
    ld de,l01d5h        ;58a1   Destination address
    ld b,5              ;58a4   b=5
    ld a,b              ;58a6
    ld (SizeID),a       ;58a7   (SizeID)=5
    call l0863h         ;58aa   Move B bytes from ^HL to ^DE
;*
;*  Put name program to REL file
;*
s_58adh:
    ld a,(F$LST)        ;58ad   a=Drive     *n*
    inc a               ;58b0
    jp z,l58ceh  ;---;  ;58b1   if (Drive).eq.1 --> Skip output name to console
    ld a,(SizeID)    ;  ;58b4
    ld c,a           ;  ;58b7   c=(SizeID)
    ld hl,l01d9h     ;  ;58b8   21 d9 01
l58bbh:      ;<----; ;
      ld a,(hl)    ; ;  ;58bb
      call conout  ; ;  ;58bc   Put character in Accu to console
      dec hl       ; ;  ;58bf   hl=hl-1
      dec c        ; ;  ;58c0   c=c-1
    jp nz,l58bbh ;-+ ;  ;58c1   if c.ne.0 next
    ld a,cr          ;  ;58c4   a=cr
    call conout      ;  ;58c6   Put character in Accu to console
    ld a,lf          ;  ;58c9   a=lf
    call conout      ;  ;58cb   Put character in Accu to console
l58ceh:         ;<---+
    ld c,2              ;58ce   REL types - Program name
    ld a,c              ;58d0
    ld (l024eh),a       ;58d1   (l024eh)=2
    call RELITEM        ;58d4
    ld a,(MainFlg)      ;58d7
    or a                ;58da
    ret nz              ;58db   if (MainFlg).ne.0 (Subprogram) Return
    ld bc,0107h         ;58dc   Address modes CSEG, rel type - define ENTRY POINT
    ld de,00000h        ;58df   de=0
    call RELITEM        ;58e2   Give code entry point
    jp s_58eeh  ;---;   ;58e5   --> ...
                    ;
l58e8h: db 'BILROF' ;   ;58e8   "FORLIB"
                    ;
s_58eeh:        ;<--+
    ld hl,(l01cfh)      ;58ee
    push hl             ;58f1 \ Save (l01cfh)
    ld hl,l58e8h        ;58f2   hl="FORLIB"
    ld de,l01d4h        ;58f5   Destination address
    ld b,6              ;58f8   b=6
    ld a,b              ;58fa
    ld (SizeID),a       ;58fb   (SizeID)=6
    call l0863h         ;58fe   Move B bytes from ^HL to ^DE
    ld bc,00003h        ;5901   REL type - request LIBRARY SEARCH
    call RELITEM        ;5904   Give lib request
    pop hl              ;5907 / Restore (l01cfh)
    jp ExtAttr           ;5908  --> Extract Attributes from the symbol table
;*
;*  Test Allocate A bytes of memory
;*
ChkMem:
    ld c,a              ;590b
    ld b,0              ;590c
    ld hl,(HeapPtr)     ;590e
    add hl,bc           ;5911
    ex de,hl            ;5912
    ld hl,(HeapEnd)     ;5913
    call cmpHL.DE       ;5916   Compare HL with DE
    ret nc              ;5919   if (HeapEnd) > (HeapPtr) + a Return
    ld hl,(l0209h)      ;591a
    ld (HeapEnd),hl     ;591d   (HeapEnd)=(l0209h)
    ld (l020ch),hl      ;5920   (l020ch)=(l0209h)
    call err.msg        ;5923   Error (113)
    db 113              ;5926   Data Pool Overflow
;*
;*  Move 19 bytes from l02b6h to l02b5h
;*     ENTRY Reg A - Len
s_5927h:
    ld c,a              ;5927   4f
    ld hl,l02b6h        ;5928   21 b6 02
    ld de,l02b5h        ;592b   11 b5 02
    ld b,19             ;592e   b=19
    call l0863h         ;5930   Move 19 bytes from ^HL to ^DE
    ld a,c              ;5933   79
    ld (de),a           ;5934   Store Len
    ret                 ;5935
;*
;*
;*
s_5936h:
    ld a,(l01d6h)       ;5936
    ld d,a              ;5939   d=(l01d6h)
    ld e,8              ;593a   e=8
    ld hl,2020h         ;593c 
    call s_0944h        ;593f   (l01d2h)=(l01d4h)=(l01d6h)=(l01d8h)='  '
    ld hl,l01d2h        ;5942   21 d2 01
l5945h:         ;<--;
      push hl       ;   ;5945 \
      call s_1a9eh  ;   ;5946   cd 9e 1a
      pop hl        ;   ;5949 /
      ret z         ;   ;594a   if a.eq.0 Return
      dec e         ;   ;594b   e=e-1
      ld (hl),a     ;   ;594c   (hl)=a
      inc hl        ;   ;594d   hl=hl+1
    jp p,l5945h ;---+   ;594e   if e >= 0 --> ...
    call err.msg        ;5951   Error (114)
    db 114              ;5954   "Literal String Too Large"
;
;   Processing PROGRAM (PROGRAM name)
;
PrProgram:
    ld a,6                  ;5955   a=6 Expected length of the name
    call GetStr             ;5957   Reading string length 6 characters
    cp cr                   ;595a
    ld de,l01e1h            ;595c   Address first character in read buffer
    jp nz,l5969h ;-;        ;595f   if Last character.ne.cr --> process name
    call cmpHL.DE  ;        ;5962   if Pointer to last character.eq.Address first character (missing name)
    jp z,l5983h  ;-)----;   ;5965      --> Assign default name
    db 0feh        ;    ;   ;5968   cp 02bh (in the original)   trap_ms ***
l5969h:     ;<-----+    ;
    dec hl              ;   ;5969   hl=hl-1
    ld bc,l01d9h        ;   ;596a   Destination adress
    xor a               ;   ;596d   a=0 Clear counter characters
    push af             ;   ;596e \ f5
                        ;
;   Copy the name       ;
                        ;
l596fh:    ;<-------;   ;
      call cmpHL.DE ;   ;   ;596f   Compare HL with DE
      jp z,l597fh ;-)-; ;   ;5972   if HL(current address).eq.Address first character in read buffer --> Exit from loop
      ld a,(de)     ; ; ;   ;5975
      ld (bc),a     ; ; ;   ;5976   (bc)=(de)
      dec bc        ; ; ;   ;5977   bc=bc-1
      dec de        ; ; ;   ;5978   de=de-1
      pop af        ; ; ;   ;5979 /
      inc a         ; ; ;   ;597a   a=a+1
      push af       ; ; ;   ;597b \ 
    jp l596fh    ;--+ ; ;   ;597c   --> Copy next character of name
                      ; ;
l597fh:        ;<-----+ ;
    pop af              ;   ;597f / Number of characters in the name
    jp nz,l5989h  ;-;   ;   ;5980   if copied at least one character
                    ;   ;
l5983h:     ;<------)---+
                    ;
;   Assign  default ; name
                    ;
    call s_589eh    ;       ;5983   Assign name "$MAIN" and put it to REL file
    jp l5994h   ;---)-;     ;5986   --> ...
                    ; ;
l5989h:    ;<-------+ ;
    ld (SizeID),a     ;     ;5989   (SizeID)=number of characters in the name
    call s_58adh      ;     ;598c   Put name program to REL file
    ld a,1            ;     ;598f
    ld (l0262h),a     ;     ;5991   (l0262h)=1
l5994h:           ;<--+
    call s_45dbh            ;5994   Build standard fortran header
    ld a,(l0299h)           ;5997   3a 99 02
l599ah:           ;<--;
    cp cr             ;     ;599a
    jp z,l09ebh       ;     ;599c   if a.eq.cr --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    call g_n_chr      ;     ;599f   Get next character
    jp l599ah     ;---+     ;59a2   --> ...
;
;
;
s_59a5h:
    ld hl,(l01cfh)          ;59a5
    push hl                 ;59a8 \ Save (l01cch)           hl=(l01cch)
    ld a,(l0230h)           ;59a9
    rlca                    ;59ac
    ld (l0296h),a           ;59ad   (l0295h)=(l0230h)*2
    ld a,1                  ;59b0
    ld (l025ah),a           ;59b2   (l025ah)=1
    ld hl,00000h            ;59b5
    ld (l01edh),hl          ;59b8   (l01edh)=0
    ld (l01eah),hl          ;59bb   (l01eah)=0
    push hl                 ;59be \
    dec hl                  ;59bf
    ld (l0235h),hl          ;59c0   (l0235h)=(l01cfh)-1
l59c3h:         ;<------;
    pop bc              ;   ;59c3 / Restore bc
    push bc             ;   ;59c4 \ Save bc
    ld hl,(l02b1h)      ;   ;59c5   hl=(l02b1h)
    ex de,hl            ;   ;59c8               de=(l02b1h)
    ld hl,l02a5h        ;   ;59c9   21 a5 02
    add hl,bc           ;   ;59cc   09
    ld (hl),e           ;   ;59cd   73
    inc hl              ;   ;59ce   23
    ld (hl),d           ;   ;59cf   ()
    ld hl,l0270h        ;   ;59d0   21 70 02
    add hl,bc           ;   ;59d3   09
    ld de,00001h        ;   ;59d4   de=1
    ld (hl),e           ;   ;59d7   73
    inc hl              ;   ;59d8   23
    ld (hl),d           ;   ;59d9   72
    ld hl,l016bh        ;   ;59da   21 6b 01
    add hl,bc           ;   ;59dd   09
    dec de              ;   ;59de   1b
    dec de              ;   ;59df   1b
    ld (hl),e           ;   ;59e0   73
    inc hl              ;   ;59e1   23
    ld (hl),d           ;   ;59e2   72
    call s_259eh        ;   ;59e3   Processing integer constant
    ld a,(KindID)       ;   ;59e6
    dec a               ;   ;59e9
    jp nz,l5a05h  ;---; ;   ;59ea   if (KindID).ne.1 (Constant) --> ...
    ld a,(l0243h)     ; ;   ;59ed
    cp 2              ; ;   ;59f0
    jp nz,l5a25h ;--; ; ;   ;59f2   if (l0243h).ne.2 --> ...
    ld hl,(l01d6h)  ; ; ;   ;59f5   2a d6 01
    ex de,hl        ; ; ;   ;59f8   eb
    ld hl,l0270h    ; ; ;   ;59f9   21 70 02
    pop bc          ; ; ;   ;59fc / Restore bc
    push bc         ; ; ;   ;59fd \ Save bc
    add hl,bc       ; ; ;   ;59fe   09
    ld (hl),e       ; ; ;   ;59ff   73
    inc hl          ; ; ;   ;5a00   23
    ld (hl),d       ; ; ;   ;5a01   72
    call s_258bh    ; ; ;   ;5a02   Processing integer constant & Test (KindID).ne.1
l5a05h:        ;<---)-+ ;
    ld hl,(l01cfh)  ;   ;   ;5a05   2a cf 01
    ex de,hl        ;   ;   ;5a08   eb
    ld hl,l02a5h    ;   ;   ;5a09   21 a5 02
    pop bc          ;   ;   ;5a0c / Restore bc
    push bc         ;   ;   ;5a0d \ Save bc
    add hl,bc       ;   ;   ;5a0e   09
    ld (hl),e       ;   ;   ;5a0f   73
    inc hl          ;   ;   ;5a10   23
    ld (hl),d       ;   ;   ;5a11   72
    ld a,(l0299h)   ;   ;   ;5a12
    cp '+'          ;   ;   ;5a15
    jp z,l5a1fh ;-; ;   ;   ;5a17   if (l0299h).eq.'+' --> ...
    cp '-'        ; ;   ;   ;5a1a
    jp nz,l5a33h;-)-)-; ;   ;5a1c   if (l0299h).ne.'-' --> ...
l5a1fh:       ;<--+ ; ; ;
    ld (l0173h),a   ; ; ;   ;5a1f   (l0173h)='+' or' -'
    call s_1b2ch    ; ; ;   ;5a22   Processing integer constant with test (KindID)=Constant
l5a25h:         ;<--+ ; ;
    ld hl,(l01d6h)    ; ;   ;5a25   2a d6 01
    dec hl            ; ;   ;5a28   2b
    ex de,hl          ; ;   ;5a29   eb
    ld hl,l016bh      ; ;   ;5a2a   21 6b 01
    pop bc            ; ;   ;5a2d / Restore bc
    push bc           ; ;   ;5a2e \ Save bc
    add hl,bc         ; ;   ;5a2f   09
    ld (hl),e         ; ;   ;5a30   73
    inc hl            ; ;   ;5a31   23
    ld (hl),d         ; ;   ;5a32   72
l5a33h:         ;<----+ ;
    pop bc              ;   ;5a33 / Restore bc
    inc bc              ;   ;5a34
    inc bc              ;   ;5a35   bc=bc+2
    ld a,c              ;   ;5a36   79
    ld hl,l0296h        ;   ;5a37
    cp (hl)             ;   ;5a3a
    jp z,l5a45h ;---;   ;   ;5a3b   if (l0296h).eq.0 --> ...
    push bc         ;   ;   ;5a3e \ Save bc  -------;
    call ChComma    ;   ;   ;5a3f   Check ','       ;
    jp l59c3h ;-----)---+   ;5a42   --> ...         ;
                    ;                               ;
l5a45h:         ;<--+                               ;
    call s_5cdeh            ;5a45   cd de 5c        ;
    pop hl                  ;5a48 / hl=bc    <------+
    ld a,(l0243h)           ;5a49
    push af                 ;5a4c \ Save (l0243h)
    push hl                 ;5a4d \ Save hl=bc
    call ExtAttr            ;5a4e   Extract Attributes from the symbol table
    call s_556ah            ;5a51   cd 6a 55
    jp c,l5babh             ;5a54   if ? --> ...
    ld hl,(l02abh)          ;5a57
    ld (l0292h),hl          ;5a5a   (l0292h)=(l02abh)
    ld hl,00000h            ;5a5d   hl=0
    ld (NumArg),hl          ;5a60   (NumArg)=0
    push hl                 ;5a63 \ Save hl=0 --+
l5a64h:         ;<----;                         ;
    ld hl,(l0292h)    ;     ;5a64               ;
    ex de,hl          ;     ;5a67               ;
    ld hl,l016bh      ;     ;5a68               ;
    pop bc            ;     ;5a6b / bc=       <-+
    push bc           ;     ;5a6c \ c5
    add hl,bc         ;     ;5a6d   09
    ld c,(hl)         ;     ;5a6e   4e
    inc hl            ;     ;5a6f   23
    ld b,(hl)         ;     ;5a70   46
    push de           ;     ;5a71 \ d5
    call s_5798h      ;     ;5a72   cd 98 57
    ex de,hl          ;     ;5a75   eb
    ld hl,(NumArg)    ;     ;5a76   2a 94 02
    add hl,de         ;     ;5a79   19
    ld (NumArg),hl    ;     ;5a7a   (NumArg)=
    pop de            ;     ;5a7d / d1
    ld hl,l0270h      ;     ;5a7e   21 70 02
    pop bc            ;     ;5a81 / c1
    push bc           ;     ;5a82 \ c5
    add hl,bc         ;     ;5a83   09 
    push hl           ;     ;5a84 \ e5
    ld c,(hl)         ;     ;5a85   4e
    inc hl            ;     ;5a86   23
    ld b,(hl)         ;     ;5a87   46
    call s_5798h      ;     ;5a88   cd 98 57
    ex de,hl          ;     ;5a8b   eb 
    pop hl            ;     ;5a8c / e1
    ld (hl),e         ;     ;5a8d   73
    inc hl            ;     ;5a8e   23
    ld (hl),d         ;     ;5a8f   72
    pop bc            ;     ;5a90 / c1
    push bc           ;     ;5a91 \ c5
    push de           ;     ;5a92 \ d5
    ld hl,l02a5h      ;     ;5a93   21 a5 02
    add hl,bc         ;     ;5a96   09 
    ld e,(hl)         ;     ;5a97   5e
    inc hl            ;     ;5a98   23
    ld d,(hl)         ;     ;5a99   56 
    ld hl,(l02b1h)    ;     ;5a9a   2a b1 02
    call cmpHL.DE     ;     ;5a9d   Compare HL with DE
    pop hl            ;     ;5aa0 / e1
    jp z,l5ad6h  ;--; ;     ;5aa1   if HL eq DE
    call s_0523h    ; ;     ;5aa4   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl  ; ;     ;5aa7   (l0237h)=
    pop bc          ; ;     ;5aaa / c1
    push bc         ; ;     ;5aab \ c5
    ld hl,(l0235h)  ; ;     ;5aac   2a 35 02
    push hl         ; ;     ;5aaf \ e5
    ld hl,l02a5h    ; ;     ;5ab0   21 a5 02
    add hl,bc       ; ;     ;5ab3   09
    ld e,(hl)       ; ;     ;5ab4   5e
    inc hl          ; ;     ;5ab5   23
    ld d,(hl)       ; ;     ;5ab6   56
    ex de,hl        ; ;     ;5ab7   eb
    ld (l0235h),hl  ; ;     ;5ab8   22 35 02
    ld a,2          ; ;     ;5abb
    ld (l0243h),a   ; ;     ;5abd   (l0243h)=2
    call s_5c91h    ; ;     ;5ac0   cd 91 5c
    pop hl          ; ;     ;5ac3 / e1
    inc hl          ; ;     ;5ac4   23
    ld a,h          ; ;     ;5ac5   7c
    or l            ; ;     ;5ac6   b5
    jp z,l5ad6h  ;--; ;     ;5ac7   ca d6 5a
    dec hl          ; ;     ;5aca   2b
    ld (l0237h),hl  ; ;     ;5acb   22 37 02 
    ld a,1          ; ;     ;5ace
    ld (l0243h),a   ; ;     ;5ad0   (l0243h)=1
    call s_5c91h    ; ;     ;5ad3   cd 91 5c
l5ad6h:         ;<--+ ;
    pop bc            ;     ;5ad6 / c1
    inc bc            ;     ;5ad7   03
    inc bc            ;     ;5ad8   03
    ld a,c            ;     ;5ad9   79
    ld hl,l0296h      ;     ;5ada   21 96 02
    cp (hl)           ;     ;5add   be
    jp z,l5af6h  ;--; ;     ;5ade   ca f6 5a
    push bc         ; ;     ;5ae1 \ c5
    ld hl,l0268h    ; ;     ;5ae2   21 68 02
    add hl,bc       ; ;     ;5ae5   09
    ld c,(hl)       ; ;     ;5ae6   4e
    inc hl          ; ;     ;5ae7   23
    ld b,(hl)       ; ;     ;5ae8   46
    ld hl,(l0292h)  ; ;     ;5ae9   2a 92 02
    ex de,hl        ; ;     ;5aec   eb
    call s_5798h    ; ;     ;5aed   cd 98 57
    ld (l0292h),hl  ; ;     ;5af0   22 92 02
    jp l5a64h   ;---)-+     ;5af3   --> ...
                    ;
l5af6h:         ;<--+
    pop hl                  ;5af6 / e1
    call ExtAttr            ;5af7   Extract Attributes from the symbol table
    ld hl,(NumArg)          ;5afa
    ld a,h                  ;5afd
    or l                    ;5afe
    jp z,l5b7fh   ;-------; ;5aff   if (NumArg).eq.0 --> ...
    ld a,(ScopeID)        ; ;5b02
    cp 3                  ; ;5b05
    jp nz,l5b3ah  ;---;   ; ;5b07   if (ScopeID).ne.3 --> ...
    push hl           ;   ; ;5b0a \ SP=(NumArg)
    ld hl,(l01cfh)    ;   ; ;5b0b
    ex (sp),hl        ;   ; ;5b0e   hl=(NumArg) SP=(l01cfh)
    call s_0523h      ;   ; ;5b0f   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl    ;   ; ;5b12   (l0237h)=
    ld hl,(l0235h)    ;   ; ;5b15
    inc hl            ;   ; ;5b18
    ld a,h            ;   ; ;5b19
    or l              ;   ; ;5b1a
    jp nz,l5b27h  ;-; ;   ; ;5b1b   if (l0235h).ne.1 --> ...
    ld hl,(l01cfh)  ; ;   ; ;5b1e
    ld (l0235h),hl  ; ;   ; ;5b21   (l0235h)=(l01cfh)
    jp l5b2fh ;---; ; ;   ; ;5b24   --> ...
                  ; ; ;   ;
l5b27h:        ;<-)-+ ;   ;
    ld a,1        ;   ;   ; ;5b27
    ld (l0243h),a ;   ;   ; ;5b29   (l0243h)=1
    call s_5c91h  ;   ;   ; ;5b2c   cd 91 5c
l5b2fh:      ;<---+   ;   ;
    pop hl            ;   ; ;5b2f / hl=(l01cfh)
    call ExtAttr      ;   ; ;5b30   Extract Attributes from the symbol table
    xor a             ;   ; ;5b33
    ld (l025ah),a     ;   ; ;5b34   (l025ah)=0
    jp l5b8ch   ;-----)-; ; ;5b37   --> ...
                      ; ; ;
l5b3ah:       ;<------+ ; ;
    ld hl,(l01cfh)      ; ; ;5b3a
    ld (l01d7h),hl      ; ; ;5b3d   (l01d7h)=(l01cfh)
    ld hl,(NumArg)      ; ; ;5b40
    ex de,hl            ; ; ;5b43
    ld hl,(DataID)      ; ; ;5b44
    add hl,de           ; ; ;5b47
    ld (l01d5h),hl      ; ; ;5b48   (l01d5h)=(DataID)+(NumArg)
    push hl             ; ; ;5b4b \ Save (l01d5h) ----------;
    ld a,02ah           ; ; ;5b4c   '*'                     ;
    ld (l01d9h),a       ; ; ;5b4e   (l01d9h)=02ah           ;
    ld a,5              ; ; ;5b51                           ;
    ld (SizeID),a       ; ; ;5b53   (SizeID)=5              ;
    ld a,3              ; ; ;5b56                           ;
    ld (KindID),a       ; ; ;5b58   (KindID)=3 (Variable)   ;
    ld a,(ScopeID)      ; ; ;5b5b                           ;
    push af             ; ; ;5b5e \ Save (ScopeID) -------; ;
    ld hl,(EntryID)     ; ; ;5b5f                         ; ;
    push hl             ; ; ;5b62 \ Save (EntryID)    --; ; ;
    call s_055ah        ; ; ;5b63   cd 5a 05            ; ; ;
    pop hl              ; ; ;5b66 / Restore (EntryID) <-+ ; ;
    pop af              ; ; ;5b67 / Restore        <------+ ;
    ld (ScopeID),a      ; ; ;5b68       (ScopeID)           ;
    dec a               ; ; ;5b6b                           ;
    jp z,l5b72h  ;--;   ; ; ;5b6c   if(ScopeID).eq.1 --> ...;
    ld hl,(l01cfh)  ;   ; ; ;5b6f   hl=(l01cfh)             ;
l5b72h:         ;<--+   ; ;                                 ;
    ld (EntryID),hl     ; ; ;5b72   (EntryID)=              ;
    pop hl              ; ; ;5b75 / Resore (l01d5h) <-------+
    ld (DataID),hl      ; ; ;5b76   (DataID)=(DataID)+(NumArg)
    call PutAttr        ; ; ;5b79   Put Attributes in Symbol table
    call s_055ah        ; ; ;5b7c   cd 5a 05
l5b7fh:       ;<--------;-+
    xor a               ;   ;5b7f   a=0
    ld (l025ah),a       ;   ;5b80   (l025ah)=0
    ld hl,(l0235h)      ;   ;5b83
    inc hl              ;   ;5b86
    ld a,h              ;   ;5b87
    or l                ;   ;5b88
    jp z,l5ba6h ;-----; ;   ;5b89   if (l0235h).eq.1 --> ...
l5b8ch:       ;<------)-+
    ld a,013h         ;     ;5b8c
    ld (l0243h),a     ;     ;5b8e   (l0243h)=013h 
    ld hl,(l01cfh)    ;     ;5b91
    ld (l0237h),hl    ;     ;5b94   (l0237h)=(l01cfh)
    ld a,(TypeID)     ;     ;5b97
    ld (l01eeh),a     ;     ;5b9a   (l01eeh)=(TypeID)
    call s_5c91h      ;     ;5b9d   cd 91 5c
    ld hl,(l0235h)    ;     ;5ba0
    ld (l01cfh),hl    ;     ;5ba3   (l01cfh)=(l0235h)
l5ba6h:         ;<----+
    pop af                  ;5ba6 / f1
    ld (l0243h),a           ;5ba7   (l0243h)=
    ret                     ;5baa
;
l5babh:
    ld a,(l0230h)       ;5bab
    cp 2                ;5bae
    jp z,l5be9h ;---;   ;5bb0   if (l0230h).eq.2 --> ...
    ld hl,(l02a9h)  ;   ;5bb3
    ld (l0235h),hl  ;   ;5bb6   (l0235h)=(l02a9h)
    ld hl,(l0274h)  ;   ;5bb9   hl=(l0274h)
    call s_0523h    ;   ;5bbc   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl  ;   ;5bbf   (l0237h)=
    ld a,2          ;   ;5bc2
    ld (l0243h),a   ;   ;5bc4   (l0243h)=2
    call s_5c91h    ;   ;5bc7   cd 91 5c
    ld hl,(l016fh)  ;   ;5bca   hl=(l016fh)
    call s_0523h    ;   ;5bcd   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl  ;   ;5bd0   (l0237h)=
    ld a,1          ;   ;5bd3
    ld (l0243h),a   ;   ;5bd5   (l0243h)=1
    call s_5c91h    ;   ;5bd8   cd 91 5c
    ld hl,(l026ch)  ;   ;5bdb
    ld (l0237h),hl  ;   ;5bde   (l0237h)=(l026ch)
    ld a,2          ;   ;5be1
    ld (l0243h),a   ;   ;5be3   (l0243h)=2
    call s_5c91h    ;   ;5be6   cd 91 5c
l5be9h:         ;<--+
    ld hl,(l0235h)      ;5be9
    push hl             ;5bec \ Save (l0235h)
    ld hl,(l02a7h)      ;5bed   
    ld (l0235h),hl      ;5bf0   (l0235h)=(l02a7h)
    ld hl,(l0272h)      ;5bf3   hl=(l0272h)
    call s_0523h        ;5bf6   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl      ;5bf9   (l0237h)=
    ld a,2              ;5bfc
    ld (l0243h),a       ;5bfe   (l0243h)=2
    call s_5c91h        ;5c01   cd 91 5c
    pop hl              ;5c04 / Restore (l0235h)
    inc hl              ;5c05
    ld a,h              ;5c06
    or l                ;5c07
    jp z,l5c17h ;---;   ;5c08   if (l0235h).eq.-1 --> ...
    dec hl          ;   ;5c0b
    ld (l0237h),hl  ;   ;5c0c   (l0237h)=(l0235h)
    ld a,1          ;   ;5c0f
    ld (l0243h),a   ;   ;5c11   (l0243h)=1
    call s_5c91h    ;   ;5c14   cd 91 5c
l5c17h:         ;<--+
    ld hl,(l016dh)      ;5c17   hl=(l016dh)
    call s_0523h        ;5c1a   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl      ;5c1d   (l0237h)=
    ld a,1              ;5c20
    ld (l0243h),a       ;5c22   (l0243h)=1
    call s_5c91h        ;5c25   cd 91 5c
    ld hl,(l026ah)      ;5c28
    ld (l0237h),hl      ;5c2b   (l0237h)=(l026ah)
    ld a,2              ;5c2e
    ld (l0243h),a       ;5c30   (l0243h)=2
    call s_5c91h        ;5c33   cd 91 5c
    ld hl,(l0235h)      ;5c36
    push hl             ;5c39 \ Save (l0235h)
    ld hl,(l02a5h)      ;5c3a
    ld (l0235h),hl      ;5c3d   (l0235h)=(l02a5h)
    ld hl,(l0270h)      ;5c40   hl=(l0270h)
    call s_0523h        ;5c43   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl      ;5c46   (l0237h)=
    ld a,2              ;5c49
    ld (l0243h),a       ;5c4b   (l0243h)=2
    call s_5c91h        ;5c4e   cd 91 5c
    pop hl              ;5c51 / Restore (l0235h)
    ld (l0237h),hl      ;5c52   (l0237h)=(l0235h)
    ld a,1              ;5c55
    ld (l0243h),a       ;5c57   (l0243h)=1
    call s_5c91h        ;5c5a   cd 91 5c
    pop hl              ;5c5d / e1
    push hl             ;5c5e \ e5
    call ExtAttr        ;5c5f   Extract Attributes from the symbol table
    ld hl,(l02abh)      ;5c62
    push hl             ;5c65 \ Save (l02abh)
    call s_0523h        ;5c66   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl      ;5c69   (l0237h)=
    ld a,2              ;5c6c
    ld (l0243h),a       ;5c6e   (l0243h)=2
    call s_5c91h        ;5c71   cd 91 5c
    pop bc              ;5c74 / c1
    ld hl,(l016bh)      ;5c75   2a 6b 01
    ex de,hl            ;5c78   eb
    call s_5798h        ;5c79   cd 98 57
    call s_0523h        ;5c7c   (l01d6h)=hl; (l01d8h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0237h),hl      ;5c7f   (l0237h)=
    ld a,1              ;5c82
    ld (l0243h),a       ;5c84   (l0243h)=1
    call s_5c91h        ;5c87   cd 91 5c
    pop hl              ;5c8a / e1
    call ExtAttr        ;5c8b   Extract Attributes from the symbol table
    jp l5b7fh           ;5c8e   --> ...
;*
;*
;*
s_5c91h:
    ld hl,00000h        ;5c91
    ld (l01eah),hl      ;5c94   (l01eah)=0
    ld hl,(l0209h)      ;5c97                   hl=(l0209h)
    ex de,hl            ;5c9a                               de=(l0209h)
    ld hl,(l0235h)      ;5c9b                   hl=(l0235h)
    call cmpHL.DE       ;5c9e
    jp c,l5caah  ;--;   ;5ca1   if (l0235h) < (l0209h) --> ...
    call s_5cbch    ;   ;5ca4   cd bc 5c 
    ld (l01eah),a   ;   ;5ca7   (l01eah)=
l5caah:         ;<--+
    ld hl,(l0237h)      ;5caa                   hl=(l0237h) de=(l0209h)
    call cmpHL.DE       ;5cad
    jp c,s_0ecdh        ;5cb0   if (l0237h) < (l0209h) --> ...
    call s_5cbch        ;5cb3   cd bc 5c
    ld (l01ebh),a       ;5cb6   (l01ebh)=
    jp s_0ecdh          ;5cb9   --> ...
;*
;*
;*
s_5cbch:
    push de             ;5cbc \
    call ExtAttr        ;5cbd   Extract Attributes from the symbol table
    pop de              ;5cc0 /
    dec a               ;5cc1
    jp nz,l5ccch ;--;   ;5cc2   if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)   ;   ;5cc5
    or a            ;   ;5cc8
    ld a,1          ;   ;5cc9   a=1
    ret z           ;   ;5ccb   if (TypeID).eq.0 (INTEGER) Return
l5ccch:         ;<--+
    xor a               ;5ccc   a=0
    ret                 ;5ccd
;*
;*  Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
;*
s_5cceh:
    ld a,(l01d1h)       ;5cce
    ld (PosStm),a       ;5cd1   (PosStm)=(l01d1h)
    xor a               ;5cd4
    ld (l01d1h),a       ;5cd5   (l01d1h)=0
    ld (l0173h),a       ;5cd8   (l0173h)=0
    jp ClrBuf20         ;5cdb   --> Clear buffer ^l02b5h length 20
;*
;*
;*
s_5cdeh:
    ld a,')'            ;5cde
    call ch.chr         ;5ce0   Check character (a character for check)
    call g_n_chr        ;5ce3   Get next character
    jp s_5709h          ;5ce6   --> ...
;*
;*  Print source line
;*
s_5ce9h:
l5ce9h:         ;<--------;
    ld hl,l0223h          ; ;5ce9
    ld (hl),0             ; ;5cec   (l0223h)=0
    ld hl,(NumSrc)        ; ;5cee   Get line number source file
    inc hl                ; ;5cf1
    ld (NumSrc),hl        ; ;5cf2   (NumSrc)=(NumSrc)+1
    ld hl,l0108h          ; ;5cf5                       ==???==
    ld a,' '              ; ;5cf8
    ld (l010dh),a         ; ;5cfa   (l010dh)=' '
    ld a,(l01b9h)         ; ;5cfd
    or a                  ; ;5d00
    jp z,l5d08h ;---;     ; ;5d01   if (l01b9h).eq.0 --> skip error message
    call err.msg    ;     ; ;5d04   Error (131)
    db 131          ;     ; ;5d07   Premature End Of File on Input Device
l5d08h:       ;<----+     ;
    ld b,0                ; ;5d08   b=0
    call s_5dcbh          ; ;5d0a   if (Column).ne.0 Put cr lf to console
l5d0dh:       ;<----;     ;
    call fget       ;     ; ;5d0d   Get character from source file
    jp c,l5d3ch  ;--)-;   ; ;5d10   if found eof --> ...
    cp lf           ; ;   ; ;5d13
    jp z,l5d0dh  ;--; ;   ; ;5d15   skip Line feed
    cp ff           ; ;   ; ;5d18
    jp z,l5d0dh  ;--; ;   ; ;5d1a   skip Form feed
    cp 08ch         ; ;   ; ;5d1d
    jp z,l5d0dh  ;--+ ;   ; ;5d1f   skip 08ch
    or a              ;   ; ;5d22
    jp m,l5d43h ;-;   ;   ; ;5d23   if < 0 --> ...
    push af       ;   ;   ; ;5d26 \ Save chr
    push hl       ;   ;   ; ;5d27 \
    ld hl,(NumSrc);   ;   ; ;5d28   Get line number source file
    call PrNumb   ;   ;   ; ;5d2b   Print number in HL as decimal number
    pop hl        ;   ;   ; ;5d2e / hl=l0108h
    call puttab   ;   ;   ; ;5d2f   Put tab to console
    pop af        ;   ;   ; ;5d32 / Restore chr
    jp l5d43h  ;--;   ;   ; ;5d33   --> ...
                  ;   ;   ;
l5d36h:  ;<-------)---)-; ;
    call fget     ;   ; ; ; ;5d36   Get character from source file
    jp nc,l5d43h;-;   ; ; ; ;5d39   if not found eof --> ...
            ;<----)---+ ; ;
l5d3ch:     ;<----)-;   ; ;
    ld a,cr       ; ;   ; ; ;5d3c
    ld (l01b9h),a ; ;   ; ; ;5d3e   (l01b9h)=cr
    ld (hl),a     ; ;   ; ; ;5d41   77
    ret           ; ;   ; ; ;5d42
                  ; ;   ; ;
l5d43h:     ;<----+ ;   ; ;
    cp lf           ;   ; ; ;5d43
    jp z,l5d4dh ;-; ;   ; ; ;5d45   if chr.eq.lf --> ...
    cp cr         ; ;   ; ; ;5d48
    call nz,putchr; ;   ; ; ;5d4a   if chr.ne.cr --> Put character to console
l5d4dh:      ;<---+ ;   ; ;
    or a            ;   ; ; ;5d4d
    jp p,l5d7ah  ;--)-; ; ; ;5d4e   if > 0 --> ...
    ld de,l0223h    ; ; ; ; ;5d51   11 23 02
l5d54h:     ;<----; ; ; ; ;
    and 07fh      ; ; ; ; ; ;5d54   Strip bit 7
    ld (de),a     ; ; ; ; ; ;5d56   (de)=
    inc de        ; ; ; ; ; ;5d57   de=de+1
    call fget     ; ; ; ; ; ;5d58   Get character from source file
    jp c,l5d3ch ;-)-+ ; ; ; ;5d5b   if found eof --> ...
    cp lf         ;   ; ; ; ;5d5e
    call nz,putchr;   ; ; ; ;5d60   if chr.ne.lf Put character to console
    cp .tab       ;   ; ; ; ;5d63
    jp z,l5d6ch ;-)-; ; ; ; ;5d65   if chr.eq.".tab" --> ...
    or a          ; ; ; ; ; ;5d68
    jp m,l5d54h ;-+ ; ; ; ; ;5d69   if chr Digit? --> ...
l5d6ch:    ;<-------+ ; ; ;
    push af           ; ; ; ;5d6c \ f5
    dec de            ; ; ; ;5d6d   de=de-1
    ld a,(de)         ; ; ; ;5d6e   1a
    or 080h           ; ; ; ;5d6f   Set high bit (10000000b)
    ld (de),a         ; ; ; ;5d71   12
    pop af            ; ; ; ;5d72 / f1
    and 07fh          ; ; ; ;5d73   Strip bit 7
    cp tab            ; ; ; ;5d75
    jp z,l5d36h   ;---)-; ; ;5d77   if eq tab --> ...
l5d7ah:       ;<------+ ; ;
    cp lf               ; ; ;5d7a
    jp z,l5d36h   ;-----; ; ;5d7c   if eq lf --> ...
    cp tab              ; ; ;5d7f
    jp nz,l5d95h ;----; ; ; ;5d81   if ne tab --> ...
l5d84h:      ;<-----; ; ; ;
      ld a,' '      ; ; ; ; ;5d84   3e 20
      ld (hl),a     ; ; ; ; ;5d86   77
      inc hl        ; ; ; ; ;5d87   hl=hl+1
      inc b         ; ; ; ; ;5d88   b=b+1
      ld a,b        ; ; ; ; ;5d89
      cp 80         ; ; ; ; ;5d8a
      ret nc        ; ; ; ; ;5d8c   if b >= 80 Return
      and 007h      ; ; ; ; ;5d8d   Test tab stop (00000111b)
    jp nz,l5d84h ;--+ ; ; ; ;5d8f   Nope
    jp l5d36h  ;------)-; ; ;5d92   --> ...
                      ; ; ;
l5d95h:       ;<------+ ; ;
    ld (hl),a           ; ; ;5d95   77
    cp cr               ; ; ;5d96
    jp nz,l5ddah ;----; ; ; ;5d98   if ne cr --> ...
    dec b             ; ; ; ;5d9b   b=b-1
    inc b             ; ; ; ;5d9c   b=b+1
    jp z,l5ce9h ;-----)-)-+ ;5d9d   if b.eq.0 --> Print source line
l5da0h:    ;<---------)-)-+
    ld (l0150h),a     ; ; ; ;5da0   (l0150h)=a
    ret               ; ; ; ;5da3	ok
		      ; ; ;
;*		      ; ; ;
;*  Put tab to console or printer
;*		      ; ; ;
puttab:		      ; ; ;
    ld a,tab	      ; ; ; ;5da4   a=tab
;*		      ; ; ;
;*  Put character in Accu to console or printer
;*		      ; ; ;
putchr:		      ; ; ;
    push af	      ; ; ; ;5da6 \ Save character
    ld a,(conflg)     ; ; ; ;5da7   Test flag
    or a              ; ; ; ;5daa
    jp nz,l5db2h ;--; ; ; ; ;5dab   .. console
    pop af          ; ; ; ; ;5dae / Restore character
    jp l5de7h       ; ; ; ; ;5daf   --> Put character in Accu to list considering tabs
                    ; ; ; ;
l5db2h:          ;<-+ ; ; ;
    ld a,(enaLST)     ; ; ; ;5db2   Test list enabled
    or a              ; ; ; ;5db5
    jp z,l5dc7h  ;--; ; ; ; ;5db6   if(enaLST).eq.0 --> Put character to console
    pop af          ; ; ; ; ;5db9 / Restore character
    push af         ; ; ; ; ;5dba \
    call l5de7h     ; ; ; ; ;5dbb   Put character in Accu to list considering tabs
    ld a,(F$LST)    ; ; ; ; ;5dbe   a=Drive *n*
    inc a           ; ; ; ; ;5dc1
    jp nz,l5dc7h ;--; ; ; ; ;5dc2   if (Drive).ne.1 --> Put character to console
    pop af          ; ; ; ; ;5dc5 /
    ret             ; ; ; ; ;5dc6
                    ; ; ; ;
l5dc7h:     ;<------+ ; ; ;
;*		      ; ; ;
;*  Put character to console
;*		      ; ; ;
    pop af            ; ; ; ;5dc7   Get character back
    jp conout         ; ; ; ;5dc8   Put character in Accu to console
;*		      ; ; ;
;*  if (Column).ne.0 Put cr lf to console
;*		      ; ; ;
s_5dcbh:	      ; ; ;
    ld a,(Column)     ; ; ; ;5dcb
    or a              ; ; ; ;5dce
    ret z             ; ; ; ;5dcf   if (Column).eq.0 Return
;*		      ; ; ;
;*  Put crlf to console ; ;
;*		      ; ; ;
p.crlf:		      ; ; ;
    ld a,cr           ; ; ; ;5dd0
    call putchr       ; ; ; ;5dd2   Put character to console
    ld a,lf           ; ; ; ;5dd5
    jp putchr	      ; ; ; ;5dd7   Put character to console
                      ; ; ;
l5ddah:      ;<-------+ ; ;
    inc hl              ; ; ;5dda   hl=hl+1
    inc b               ; ; ;5ddb   04
    ld a,79             ; ; ;5ddc
    cp b                ; ; ;5dde   b8
    jp nc,l5d36h ;------+ ; ;5ddf   if a >= b --> ...
    ld a,cr               ; ;5de2   a=cr
    jp l5da0h  ;----------+ ;5de4   --> ...
;*
;*  Put character in Accu to list considering tabs
;*    ENTRY Reg a - chr
;*
l5de7h:
    push af                 ;5de7 \ Save chr
    and 07fh                ;5de8   Reset bit 7
    push hl                 ;5dea \ Save hl
    ld hl,Column            ;5deb
    cp tab                  ;5dee
    jp nz,l5e03h  ;-----;   ;5df0   if chr.ne.tab --> ...
l5df3h:         ;<--;   ;
      inc (hl)      ;   ;   ;5df3   (Column)=(Column)+1
      ld a,(hl)     ;   ;   ;5df4   Load chr
      and 007h      ;   ;   ;5df5   Test tab stop
    jp nz,l5df3h ;--+   ;   ;5df7   Nope
    dec (hl)            ;   ;5dfa   (Column)=(Column)-1
    ld a,tab            ;   ;5dfb   chr=tab
l5dfdh:      ;<-------; ;
    inc (hl)          ; ;   ;5dfd   (Column)=(Column)+1
l5dfeh:        ;<---; ; ;
    pop hl          ; ; ;   ;5dfe / Restore hl
    pop af          ; ; ;   ;5dff / Restore chr
    jp lput         ; ; ;   ;5e00   --> Put character to list device
                    ; ; ;
l5e03h:       ;<----)-)-+
    cp lf           ; ;     ;5e03   Test lf
    jp nz,l5e0dh;-; ; ;     ;5e05   if chr.ne.lf --> ...
    ld (hl),0     ; ; ;     ;5e08   (Column)=0
    jp l5dfeh ;---)-; ;     ;5e0a   --> ...
                  ; ; ;
l5e0dh:       ;<--+ ; ;
    cp ' '          ; ;     ;5e0d   Test blank
    jp c,l5dfeh ;---+ ;     ;5e0f   if chr < ' ' --> ...
    jp l5dfdh ;-------+     ;5e12   --> ...
;*
;*  Get character from selected source file
;*    Carry set indicates end of file
;*
fget:
    ld a,(incflg)       ;5e15   Test source state
    or a                ;5e18
    jp z,l5e27h ;---;   ;5e19   if (incflg).eq.0 Get character
    call iget       ;   ;5e1c   Read character from include file
    ret nc          ;   ;5e1f   ok
    call iclose     ;   ;5e20   Close include file
    xor a           ;   ;5e23   a=0
    ld (incflg),a   ;   ;5e24   (incflg)=0 Disable include file
l5e27h:         ;<--+
    call sget           ;5e27   Read character from source file
    ret                 ;5e2a
;*
;*  Put Attributes in Symbol table
;*
PutAttr:
    ld hl,SizeID        ;5e2b   
    ld c,(hl)           ;5e2e   c=(SizeID)
    ld a,(SegmID)       ;5e2f   Load Flag Address mode
    rrca                ;5e32   Put 0 bit from (SegmID) in 7 bits
    or (hl)             ;5e33   Add to reg A bits from (SizeID)
    ld hl,(l01cfh)      ;5e34   
    ld (hl),a           ;5e37   Put reg A into memory to address stored in (l01cfh)
    ld a,(ScopeID)      ;5e38
    rrca                ;5e3b
    rrca                ;5e3c   Put 0 & 1 bits from (ScopeID) in 7 & 6 bits
    ld b,a              ;5e3d   Save it to reg B
    ld a,(TypeID)       ;5e3e
    rlca                ;5e41
    rlca                ;5e42
    rlca                ;5e43   Move 3 lower bits from (TypeID) to bits 7-5
    or b                ;5e44   Add to reg A bits from reg B generated from (SegmID)
    ex de,hl            ;5e45                   de=(l01cfh)
    ld hl,KindID        ;5e46
    or (hl)             ;5e49   Add to reg A bits from (KindID)
    ex de,hl            ;5e4a   hl=(l01cfh)
    dec hl              ;5e4b   hl=(l01cfh)-1
    ld (hl),a           ;5e4c   Put reg A into memory to address stored in (l01cfh)-1
    dec hl              ;5e4d   hl=(l01cfh)-2
    ex de,hl            ;5e4e                   de=(l01cfh)-2
    push de             ;5e4f \ Save (l01cfh)-2
    ld hl,(DataID)      ;5e50   hl=(DataID)
    ex de,hl            ;5e53   hl=(l01cfh)-2   de=(DataID)
    ld (hl),d           ;5e54
    dec hl              ;5e55   hl=(l01cfh)-3
    ld (hl),e           ;5e56   Put word (DataID) into memory to address stored in (l01cfh)-2
    dec hl              ;5e57   hl=(l01cfh)-4
    ex de,hl            ;5e58                   de=(l01cfh)-4
    ld hl,(EntryID)     ;5e59   hl=(EntryID)
    ex de,hl            ;5e5c   hl=(l01cfh)-4   de=(EntryID)
    ld (hl),d           ;5e5d
    dec hl              ;5e5e   hl=(l01cfh)-5
    ld (hl),e           ;5e5f   Put word (EntryID) into memory to address stored in (l01cfh)-4

;*  Put Name to memory

    dec hl              ;5e60   hl=(l01cfh)-6 Destination address
    ld de,l01d9h        ;5e61   de=Pointer to start the name
;                               c=(SizeID) Length of name
l5e64h:         ;<--;
      ld a,(de)     ;   ;5e64
      ld (hl),a     ;   ;5e65   (hl)=(de)
      dec hl        ;   ;5e66   hl=hl-1
      dec de        ;   ;5e67   de=de-1
      dec c         ;   ;5e68   c=c-1
    jp nz,l5e64h ;--+   ;5e69   if c.ne.0 Copy next character
;*
;*  Calculation storage size variable according to the type
;*
    ld a,(TypeID)       ;5e6c
    cp 4                ;5e6f
    jp z,l5e7ch  ;----; ;5e71   if (TypeID).eq.4 (INTEGER*4) --> ...
    inc a             ; ;5e74   a=(TypeID)+1
    rlca              ; ;5e75   Multiply by 2
    or a              ; ;5e76   for compatibility with z80
    jp po,l5e7ch ;-;  ; ;5e77   if (TypeID).ne.3 (Byte) --> ...
    ld a,1         ;  ; ;5e7a   a=1
l5e7ch:       ;<---+<-+
    ld (l02abh),a       ;5e7c   (l02abh)=Storage size
    ld a,(KindID)       ;5e7f
    cp 4                ;5e82
    pop de              ;5e84 / de=(l01cfh)-2
    ret nz              ;5e85   if (KindID).ne.4 (Array) Return
    ld hl,(l0220h)      ;5e86   hl=(l0220h)
    ex de,hl            ;5e89   hl=(l01cfh)-2   de=(l0220h)
    ld (hl),d           ;5e8a
    dec hl              ;5e8b   hl=(l01cfh)-3
    ld (hl),e           ;5e8c   Put word (l0220h) into memory to address stored in (l01cfh)-2
    ld hl,(DataID)      ;5e8d   hl=(DataID)
    ex de,hl            ;5e90   hl=(l0220h)     de=(DataID)
    dec hl              ;5e91
    dec hl              ;5e92   hl=(l0220h)-2
    ld (hl),d           ;5e93
    dec hl              ;5e94   hl=(l0220h)-3
    ld (hl),e           ;5e95   Put word (DataID) into memory to address stored in (l0220h)-2
    ret                 ;5e96
;*
;*  ENTRY Reg a - Type_statement
;*    0-BLOCkdata       4-COMMon      0ah-BACKspace
;*      FUNCtion        5-EQUIvalence     ENCOde(
;*      PROGram         6-DATA            ENDFile
;*      SUBRoutine      8-?               DECOde
;*    1-DIMEnsion       9-ASSIgn          do
;*      DOUBleprecision   CALL            PAUSe
;*      EXTErnal          CONTinue        READ(
;*      IMPLicit          FORMat          REWInd
;*      INTEger           GOTO            STOP
;*      LOGIcal           IF(             WRITe(
;*      BYTE              INCLude     0bh-END
;*      REAL              RETUrn
;*
s_5e97h:
    ld b,a              ;5e97   Save Type_statement
    ld de,PrInclude     ;5e98   Address program Processing INCLUDE
    ld hl,(CurAdr)      ;5e9b   Address current program Processing statement
    call cmpHL.DE       ;5e9e
    ld a,b              ;5ea1   Restore Type_statement
    ret z               ;5ea2   if (CurAdr).eq.PrInclude Return
;
    push af             ;5ea3 \ Save Type_statement
    sub 2               ;5ea4
    jp m,l5eb8h  ;--;   ;5ea6   if Type_statement < 2 --> ...
    ld hl,l024eh    ;   ;5ea9
    ld a,(hl)       ;   ;5eac
    or a            ;   ;5ead
    jp nz,l5eb8h ;--;   ;5eae   if (l024eh).ne.0 --> ...
    inc (hl)        ;   ;5eb1   (l024eh)=(l024eh)+1
    call s_45dbh    ;   ;5eb2   Build standard fortran header
    call s_589eh    ;   ;5eb5   Assign name "$MAIN" and put it to REL file
l5eb8h:         ;<--+
    pop af              ;5eb8 / Restore Type_statement
    ld hl,(l01cfh)      ;5eb9
    ld (l027ah),hl      ;5ebc   (l027ah)=(l01cfh)
    ld hl,l0278h        ;5ebf
    push hl             ;5ec2 \
    ld (hl),a           ;5ec3   (l0278h)=Type_statement
    cp 0ah              ;5ec4
    jp c,l5ecdh ;---;   ;5ec6   if Type_statement < 0ah --> ...
    dec (hl)        ;   ;5ec9   (l0278h)=(l0278h)-1
    call s_41f7h    ;   ;5eca   cd f7 41
l5ecdh:         ;<--+
    ld hl,(CurAdr)      ;5ecd   Address current program Processing statement
    ld de,PrFormat      ;5ed0   Address program Processing FORMAT
    call cmpHL.DE       ;5ed3   Compare HL with DE
    pop hl              ;5ed6 / hl=l0278h
    ret z               ;5ed7   if (CurAdr).eq.PrFormat Return
    ld a,(hl)           ;5ed8
    ld hl,l0262h        ;5ed9
    cp (hl)             ;5edc
    jp c,err127         ;5edd   if (l0278) < (l0262h) --> Error (127) Statement Out of Sequence
    ld hl,(l0264h)      ;5ee0
    ld a,h              ;5ee3
    or l                ;5ee4
    jp nz,l5f02h ;--;   ;5ee5   if (l0264h).ne.0 --> ...
    ld a,(l0278h)   ;   ;5ee8
    cp 00ah         ;   ;5eeb
    jp z,l5f02h  ;--;   ;5eed   if (l0278h).eq.0ah --> ...
    ld a,(l0222h)   ;   ;5ef0
    or a            ;   ;5ef3
    jp nz,l5f02h ;--;   ;5ef4   if (l0222h).ne.0 --> ...
    ld a,(l029ah)   ;   ;5ef7
    or a            ;   ;5efa
    jp z,l5f02h ;---;   ;5efb   if (l029ah).eq.0 --> skip error message
    call err.msg    ;   ;5efe   Warning (21)
    db 21           ;   ;5f01   No Path to this Statement
l5f02h:       ;<----+
    ld de,PrGoto        ;5f02   Address program Processing GOTO
    ld hl,(CurAdr)      ;5f05   Address current program Processing statement
    call cmpHL.DE       ;5f08
    jp z,l5f2ch  ;--;   ;5f0b   if (CurAdr).eq.PrGoto --> ...
    ld a,(l0222h)   ;   ;5f0e
    or a            ;   ;5f11
    jp z,l5f2ch  ;--;   ;5f12   if (l0222h).eq.0 --> ...
    ld hl,(CurAdr)  ;   ;5f15   Address current program Processing statement
    push hl         ;   ;5f18 \ Save value
    ld hl,00000h    ;   ;5f19   hl=0
    ld (CurAdr),hl  ;   ;5f1c   (CurAdr)=0 Clear variable
    call s_41f7h    ;   ;5f1f   cd f7 41
    pop hl          ;   ;5f22 / Restore value
    ld (CurAdr),hl  ;   ;5f23   (CurAdr)=(CurAdr)
    call s_47b3h    ;   ;5f26   cd b3 47
    call s_4854h    ;   ;5f29   Put 'JP Z,word' & word=0000 to REL file
l5f2ch:         ;<--+
    ld a,(l0278h)               ;5f2c
    cp 6                        ;5f2f
    jp c,l5fa5h     ;-------;   ;5f31   if (l0278h) < 6  --> ...
    ld a,(l0262h)           ;   ;5f34
    cp 6                    ;   ;5f37
    jp nc,l5f9ah      ;---; ;   ;5f39   if (l0262h) >= 6 --> ...
    call s_6885h          ; ;   ;5f3c   Extract Attributes from the symbol table, entry (l031fh)
l5f3fh:             ;<--; ; ;
    jp c,l5f57h  ;----; ; ; ;   ;5f3f   if carry set (Found end of Symbol table) --> ...
    cp 6              ; ; ; ;   ;5f42
    jp nz,l5f51h ;--; ; ; ; ;   ;5f44   if (KindID).ne.6 (Common) --> ...
    ld bc,5         ; ; ; ; ;   ;5f47   REL type - Define COMMON size
    ld hl,(DataID)  ; ; ; ; ;   ;5f4a
    ex de,hl        ; ; ; ; ;   ;5f4d
    call RELITEM    ; ; ; ; ;   ;5f4e   Give common size
l5f51h:         ;<--+ ; ; ; ;           Calculate address next symbol in the Symbols table;
    call s_688bh      ; ; ; ;   ;5f51   if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp l5f3fh      ;--)-+ ; ;   ;5f54   --> ...
                      ;   ; ;
l5f57h:         ;<----+   ; ;
    call s_6885h          ; ;   ;5f57   Extract Attributes from the symbol table, entry (l031fh)
l5f5ah:       ;<--------; ; ;
    jp c,l5f7dh  ;----; ; ; ;   ;5f5a   if carry set (Found end of Symbol table) --> ...
    cp 3              ; ; ; ;   ;5f5d
    jp c,l5f77h  ;--; ; ; ; ;   ;5f5f   if (KindID).<. 3 (Variable) --> ...
    cp 5            ; ; ; ; ;   ;5f62
    jp nc,l5f77h ;--; ; ; ; ;   ;5f64   if (KindID).>=. 5 (Routine) --> ...
    ld hl,(l01cfh)  ; ; ; ; ;   ;5f67
    ex de,hl        ; ; ; ; ;   ;5f6a
    ld hl,(EntryID) ; ; ; ; ;   ;5f6b
    call cmpHL.DE   ; ; ; ; ;   ;5f6e   Compare HL with DE
    jp nz,l5fd9h  ;-)-)-)-)-)-; ;5f71   if (EntryID).ne.(l01cfh) --> ...
    call s_0cffh    ; ; ; ; ; ; ;5f74   cd ff 0c
l5f77h:         ;<--+ ; ; ; ; ;         Calculate address next symbol in the Symbols table;
    call s_688bh      ; ; ; ; ; ;5f77   if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
    jp l5f5ah  ;------)-+ ; ; ; ;5f7a   --> ...
                      ;   ; ; ;
l5f7dh:         ;<----+   ; ; ;
    call s_414eh          ; ; ; ;5f7d   cd 4e 41
    ld hl,(l0268h)        ; ; ; ;5f80
    ld a,h                ; ; ; ;5f83
    or l                  ; ; ; ;5f84
    jp z,l5f9ah     ;-----; ; ; ;5f85   if (l0268h).eq.0 --> ...
    ld a,(SubrFlg)        ; ; ; ;5f88
    or a                  ; ; ; ;5f8b
    jp nz,l5f9ah    ;-----; ; ; ;5f8c   if (SubrFlg).ne.0 (Subroutine) --> ...
    call ExtAttr          ; ; ; ;5f8f   Extract Attributes from the symbol table
    ld a,3                ; ; ; ;5f92
    ld (KindID),a         ; ; ; ;5f94   (KindID)=3 (Variable)
    call PutAttr          ; ; ; ;5f97   Put Attributes in Symbol table
l5f9ah:          ;<-------+ ; ;
    ld a,(l0278h)           ; ; ;5f9a
    cp 8                    ; ; ;5f9d
    jp nz,l5fb2h ;--;       ; ; ;5f9f   if (l0278h).ne.8 --> ...
    call s_4859h    ;       ; ; ;5fa2   Put 'JP word' & word=0000 to REL file
l5fa5h:       ;<----)-; <---+ ;
    ld hl,(l027ah)  ; ;       ; ;5fa5   hl=(l027ah)
    call ExtAttr    ; ;       ; ;5fa8   Extract Attributes from the symbol table
    ld a,(l0278h)   ; ;       ; ;5fab
    ld (l0262h),a   ; ;       ; ;5fae   (l0262h)=(l0278h)
    ret             ; ;       ; ;5fb1
                    ; ;       ;
l5fb2h:         ;<--+ ;       ;
    ld hl,(l0167h)    ;       ; ;5fb2 
    ld a,h            ;       ; ;5fb5
    or l              ;       ; ;5fb6
    jp z,l5fa5h   ;---;       ; ;5fb7   if (l0167h).eq.0 --> ...
    ld a,(l0222h)     ;       ; ;5fba
    or a              ;       ; ;5fbd
    jp nz,l5fa5h  ;---;       ; ;5fbe   if (l0222h).ne.0 --> ...
    call s_41f7h      ;       ; ;5fc1   cd f7 41
    ld hl,(l0167h)    ;       ; ;5fc4
    ld (DataID),hl    ;       ; ;5fc7   (DataID)=(l0167h)
    xor a             ;       ; ;5fca
    ld (TypeID),a     ;       ; ;5fcb   (TypeID)=0 (INTEGER)
    ld h,a            ;       ; ;5fce
    ld l,a            ;       ; ;5fcf   hl=0
    ld (l0167h),hl    ;       ; ;5fd0   (l0167h)=0
    call s_5853h      ;       ; ;5fd3   cd 53 58
    jp l5fa5h     ;---+       ; ;5fd6   --> ...
                              ;
l5fd9h:             ;<--------+
    ld a,(ScopeID)      ;5fd9
    or a                ;5fdc   if (ScopeID).ne.0
    jp nz,l5f77h        ;5fdd     --> Calculate address next symbol in the Symbols table...
    ld hl,(l01cfh)      ;5fe0
    ld (l01c4h),hl      ;5fe3   (l01c4h)=(l01cfh)
    ld hl,00000h        ;5fe6
    ld (l028eh),hl      ;5fe9   (l028eh)=0
    xor a               ;5fec
    ld (l0298h),a       ;5fed   (l0298h)=0
l5ff0h:           ;<--;
    ld hl,(l028eh)    ; ;5ff0
    ex de,hl          ; ;5ff3
    ld hl,(DataID)    ; ;5ff4
    push hl           ; ;5ff7 \ Save (DataID)
    call subHL.DE     ; ;5ff8
    ld a,h            ; ;5ffb
    or a              ; ;5ffc
    jp m,l6009h ;---; ; ;5ffd   if (DataID) < (l028eh)  --> ...
    or l            ; ; ;6000
    jp z,l6009h ;---; ; ;6001   if (DataID).eq.(l028eh) --> ...
    pop hl          ; ; ;6004 / Restore (DataID)
    push hl         ; ; ;6005 \             --------;
    ld (l028eh),hl  ; ; ;6006   (l028eh)=(DataID)   ;
l6009h:         ;<--+ ;                             ;
    call l68bbh       ; ;6009   cd bb 68            ;
    pop de            ; ;600c / de=(DataID) <-------+
    call subHL.DE     ; ;600d   hl=hl-de
    ld a,(l0298h)     ; ;6010
    or a              ; ;6013
    jp z,l602bh ;---; ; ;6014   if (l0298h).eq.0 --> ...
    ex de,hl        ; ; ;6017   eb
    ld hl,(l028ch)  ; ; ;6018   2a 8c 02
    ex de,hl        ; ; ;601b   eb
    push hl         ; ; ;601c \ ------------;
    call subHL.DE   ; ; ;601d   hl=hl-de    ;
    pop de          ; ; ;6020 / <-----------+
    ld a,h          ; ; ;6021   7c
    or a            ; ; ;6022   b7
    jp m,l6033h ;-; ; ; ;6023   fa 33 60
    or l          ; ; ; ;6026   b5
    jp z,l6033h ;-; ; ; ;6027   ca 33 60
    ex de,hl      ; ; ; ;602a   eb
l602bh:     ;<----)-+ ;
    ld a,1        ;   ; ;602b
    ld (l0298h),a ;   ; ;602d   (l0298h)=1
    ld (l028ch),hl;   ; ;6030   (l028ch)=
l6033h:       ;<--+   ;
    call s_16bfh      ; ;6033   {call ExtAttr(EntryID); test hl=(l01c4h)-(EntryID)}
    jp nz,l5ff0h  ;---+ ;6036   if (l01c4h).ne.(EntryID) --> ...
    ld hl,(l028eh)      ;6039
    ex de,hl            ;603c
    ld hl,(DatSiz)      ;603d   Load Data size
    add hl,de           ;6040
    ld (l028eh),hl      ;6041   (l028eh)=(l028eh)+(DatSiz)
    ex de,hl            ;6044
    ld hl,(l028ch)      ;6045
    add hl,de           ;6048
    ld (DatSiz),hl      ;6049   (DatSiz)=(l028ch)+(l028eh)
l604ch:     ;<------;
    ld a,2          ;   ;604c
    ld (ScopeID),a  ;   ;604e   (ScopeID)=2
    ld hl,(DataID)  ;   ;6051 
    ex de,hl        ;   ;6054
    ld hl,(l028eh)  ;   ;6055   
    call subHL.DE   ;   ;6058   hl=hl-de
    ld (DataID),hl  ;   ;605b   (DataID)=(l028eh)-(DataID)
    call PutAttr    ;   ;605e   Put Attributes in Symbol table
    call s_16bfh    ;   ;6061   {call ExtAttr(EntryID); test hl=(l01c4h)-(EntryID)}
    jp nz,l604ch ;--+   ;6064   if (l01c4h).ne.(EntryID) --> ...
    jp l5f77h           ;6067   --> Calculate address next symbol in the Symbols table ...
;
err127:
    call err.msg        ;606a   Error (127)
    db 127              ;606d   Statement Out of Sequence
;
;
;
s_606eh:
    ld a,0ch                ;606e   a=0ch
    call s_6478h            ;6070   cd 78 64
    xor a                   ;6073
    ld (l01cah),a           ;6074   (l01cah)=0
    ld (l01cbh),a           ;6077   (l01cah)=0
l607ah:     ;<---------;
    ld hl,(l01cah)     ;    ;607a
    ld de,00010h       ;    ;607d
    add hl,de          ;    ;6080
    ld (l01cah),hl     ;    ;6081   (l01cah)=(l01cah)+16
l6084h:     ;<-----;   ;
    ld hl,(l0217h) ;   ;    ;6084   2a 17 02
    dec hl         ;   ;    ;6087   2b  +
    dec hl         ;   ;    ;6088   2b  +
    dec hl         ;   ;    ;6089   2b  +
    dec hl         ;   ;    ;608a   2b  +
    ld a,(hl)      ;   ;    ;608b   7e  ~ 
    and 01fh       ;   ;    ;608c   00011111b
    ld e,a         ;   ;    ;608e
    ld d,0         ;   ;    ;608f   de=a
    ld hl,l04cah   ;   ;    ;6091   21 ca 04    ! . . 
    add hl,de      ;   ;    ;6094   19  . 
    ld c,(hl)      ;   ;    ;6095   4e  N 
    ld b,0         ;   ;    ;6096   06 00   . .
    ld hl,(l01cah) ;   ;    ;6098   2a ca 01    * . . 
    add hl,bc      ;   ;    ;609b   09  . 
    ld (l01b6h),hl ;   ;    ;609c   (l01b6h)=
    ex de,hl       ;   ;    ;609f
    ld hl,(l01b4h) ;   ;    ;60a0
    call cmpHL.DE  ;   ;    ;60a3
    jp nc,l60e7h ;-)-; ;    ;60a6   if (l01b4h) >= (l01b6h)--> ...
l60a9h:     ;<-----)-)-)-;
    ld hl,(l0217h) ; ; ; ;  ;60a9
    dec hl         ; ; ; ;  ;60ac
    dec hl         ; ; ; ;  ;60ad
    dec hl         ; ; ; ;  ;60ae
    dec hl         ; ; ; ;  ;60af
    ld (l0217h),hl ; ; ; ;  ;60b0   (l0217h)=(l0217h)-4
l60b3h:            ; ; ; ;
    call s_6482h   ; ; ; ;  ;60b3   cd 82 64
    ld e,a         ; ; ; ;  ;60b6
    ld d,0         ; ; ; ;  ;60b7   de=a
    ld hl,(l01cah) ; ; ; ;  ;60b9
    add hl,de      ; ; ; ;  ;60bc
    ld (l01b4h),hl ; ; ; ;  ;60bd   (l01b4h)=(l01cah)+a
    ld a,b         ; ; ; ;  ;60c0
    cp 0ch         ; ; ; ;  ;60c1
    jp z,l607ah ;--)-)-+ ;  ;60c3   if b.eq.0ch --> ...
    or a           ; ;   ;  ;60c6
    jp nz,l6084h ;-; ;   ;  ;60c7   if b.ne.0 --> ...
    ld hl,(l01cah) ; ;   ;  ;60ca
    ld de,0fff0h   ; ;   ;  ;60cd
    add hl,de      ; ;   ;  ;60d0
    ld (l01cah),hl ; ;   ;  ;60d1   (l01cah)=(l01cah)-16
    ld hl,(l01a4h) ; ;   ;  ;60d4
    ex de,hl       ; ;   ;  ;60d7
    ld hl,(l0217h) ; ;   ;  ;60d8
    call cmpHL.DE  ; ;   ;  ;60db   Compare HL with DE
    jp nz,l6084h ;-+ ;   ;  ;60de   if (l0217h).ne.(l01a4h) --> ...
    ld hl,(l01cah)   ;   ;  ;60e1
    ld (l01b6h),hl   ;   ;  ;60e4   (l01b6h)=(l01cah)
l60e7h:         ;<---+   ;
    call s_63ceh         ;  ;60e7   cd ce 63
    ld a,(l0243h)        ;  ;60ea
    cp 5                 ;  ;60ed
    jp c,l6121h  ;---;   ;  ;60ef   if (l0243h) < 5 --> ...
    cp 0bh           ;   ;  ;60f2
    jp nc,l6143h ;-; ;   ;  ;60f4   if (l0243h) >= 11 --> ...
    ld a,(l0232h)  ; ;   ;  ;60f7
    or a           ; ;   ;  ;60fa
    jp z,l610bh;-; ; ;   ;  ;60fb   if (l0232h).eq.0 --> ...
    call s_6453h ; ; ;   ;  ;60fe   {(l0235h)<->(l0237h); (l01edh)<->l01eeh); (l01eah)<->(l01ebh)}
    call s_63fbh ; ; ;   ;  ;6101   cd fb 63
    xor a        ; ; ;   ;  ;6104   a=0
    call s_6428h ; ; ;   ;  ;6105   cd 28 64
    call s_63ceh ; ; ;   ;  ;6108   cd ce 63
l610bh:   ;<-----+ ; ;   ; 
    ld a,(l0243h)  ; ;   ;  ;610b
    cp 6           ; ;   ;  ;610e
    jp z,l6143h ;--; ;   ;  ;6110   if (l0243h).eq.6 --> ...
    ld a,(l0231h)  ; ;   ;  ;6113
    or a           ; ;   ;  ;6116
    jp z,l6143h ;--; ;   ;  ;6117   if (l0231h).eq.0 --> ...
    call s_6409h   ; ;   ;  ;611a   cd 09 64
    xor a          ; ;   ;  ;611d
    ld (l0231h),a  ; ;   ;  ;611e   (l0231h)=0
l6121h:    ;<------)-+   ;
    ld a,(l0243h)  ;     ;  ;6121
    cp 3           ;     ;  ;6124
    jp nz,l6143h ;-;     ;  ;6126   if (l0243h).ne.3 --> ...
    ld hl,(l0217h) ;     ;  ;6129
    push hl        ;     ;  ;612c \ Save (l0217h)
    inc hl         ;     ;  ;612d
    inc hl         ;     ;  ;612e
    inc hl         ;     ;  ;612f
    inc hl         ;     ;  ;6130
    ld a,80h       ;     ;  ;6131
    xor (hl)       ;     ;  ;6133
    ld (hl),a      ;     ;  ;6134   ((l0217h)+4)=(l0243h).xor.10000000b
    ld hl,(l0235h) ;     ;  ;6135
    ld a,h         ;     ;  ;6138
    or l           ;     ;  ;6139
    pop hl         ;     ;  ;613a / Restore (l0217h)
    jp z,l61c9h ;--)--;  ;  ;613b   if (l0235h).eq.0 --> ...
    dec (hl)       ;  ;  ;  ;613e
    dec (hl)       ;  ;  ;  ;613f   (l0217h)=(l0217h)-2 
    call s_63ceh   ;  ;  ;  ;6140   cd ce 63
l6143h:     ;<-----+  ;  ; 
    ld hl,(l01b6h)    ;  ;          ;6143
    ex de,hl          ;  ;          ;6146
    ld hl,(l01b4h)    ;  ;          ;6147
    call cmpHL.DE     ;  ;          ;614a
    jp z,l60a9h ;-----)--+          ;614d   if (l01b4h).eq.(l01b6h) --> ...
    ld a,(l0243h)     ;             ;6150
    or a              ;             ;6153
    jp z,l6201h     ;-)-----------; ;6154   if (l0243h).eq.0  --> ...
    cp 3              ;           ; ;6157
    jp c,l6308h   ;---)---------; ; ;6159   if (l0243h) < 3   --> ...
    cp 8              ;         ; ; ;615c
    jp c,l6166h ;-;   ;         ; ; ;615e   if (l0243h) < 8   --> ...
    cp 0bh        ;   ;         ; ; ;6161
    jp c,l6308h ;-)---)---------; ; ;6163   if (l0243h) < 0bh --> ...
l6166h:     ;<----+   ;         ; ;
    ld a,(l0243h)     ;         ; ; ;6166
    dec a             ;         ; ; ;6169
    jp z,l6269h ;-----)-------; ; ; ;616a   if (l0243h).eq.1  --> ...
    sub 4             ;       ; ; ; ;616d
    jp c,l629bh ;-----)-----; ; ; ; ;616f   if (l0243h) < 5   --> {(l0231h)=(l0231h).xor.(l0232h); jp l61c0h}
    sub 2             ;     ; ; ; ; ;6172
    jp c,l61c0h  ;--; ;     ; ; ; ; ;6174   if (l0243h) < 7   --> ...
    jp z,l62a6h ;---)-)---; ; ; ; ; ;6177   if (l0243h).eq.7  --> ...
    dec a           ; ;   ; ; ; ; ; ;617a
    jp z,l61c0h  ;--; ;   ; ; ; ; ; ;617b   if (l0243h).eq.8  --> ...
    sub 3           ; ;   ; ; ; ; ; ;617e
    jp c,l61c0h  ;--; ;   ; ; ; ; ; ;6180   if (l0243h) < 11  --> ...
    jp z,l62ach ;---)-)-; ; ; ; ; ; ;6183   if (l0243h).eq.11 --> ...
    ld a,(l0231h)   ; ; ; ; ; ; ; ; ;6186
    or a            ; ; ; ; ; ; ; ; ;6189
    jp z,l619bh ;-; ; ; ; ; ; ; ; ; ;618a   if (l0231h).eq.0  --> ...
    ld a,(l0243h) ; ; ; ; ; ; ; ; ; ;618d   a=(l0243h)
    ld e,a        ; ; ; ; ; ; ; ; ; ;6190
    ld d,0        ; ; ; ; ; ; ; ; ; ;6191   de=a
    ld hl,l04d0h  ; ; ; ; ; ; ; ; ; ;6193   hl= point to table
    add hl,de     ; ; ; ; ; ; ; ; ; ;6196   19  . 
    ld a,(hl)     ; ; ; ; ; ; ; ; ; ;6197   7e  ~ 
    ld (l0243h),a ; ; ; ; ; ; ; ; ; ;6198   (l0243h)=
l619bh:    ;<-----+ ; ; ; ; ; ; ; ;
    ld a,(l0231h)   ; ; ; ; ; ; ; ; ;619b   3a 31 02 
    ld hl,l0232h    ; ; ; ; ; ; ; ; ;619e   21 32 02
    xor (hl)        ; ; ; ; ; ; ; ; ;61a1   ae
    xor 1           ; ; ; ; ; ; ; ; ;61a2   ee 01
    add a,a         ; ; ; ; ; ; ; ; ;61a4   87
    inc a           ; ; ; ; ; ; ; ; ;61a5   3c
    ld b,a          ; ; ; ; ; ; ; ; ;61a6   47
    xor a           ; ; ; ; ; ; ; ; ;61a7
    ld (l0231h),a   ; ; ; ; ; ; ; ; ;61a8   (l0231h)=0
    ld a,(l0243h)   ; ; ; ; ; ; ; ; ;61ab
    push af         ; ; ; ; ; ; ; ; ;61ae \ Save (l0243h) ------+
    ld a,b          ; ; ; ; ; ; ; ; ;61af   78                  ;
    ld (l0243h),a   ; ; ; ; ; ; ; ; ;61b0   (l0243h)=           ;
    call s_0ecdh    ; ; ; ; ; ; ; ; ;61b3   cd cd 0e            ;
    ld hl,(l0235h)  ; ; ; ; ; ; ; ; ;61b6                       ;
    ld (l0237h),hl  ; ; ; ; ; ; ; ; ;61b9   (l0237h)=(l0235h)   ;
    pop af          ; ; ; ; ; ; ; ; ;61bc /               <-----+
    ld (l0243h),a   ; ; ; ; ; ; ; ; ;61bd   Restore (l0243h)
l61c0h:         ;<--+ ; ; ; ; ; ; ;
    call s_0ecdh      ; ; ; ; ; ; ; ;61c0   cd cd 0e
    ld a,(l0231h)     ; ; ; ; ; ; ; ;61c3   a=(l0231h)
    call s_6428h      ; ; ; ; ; ; ; ;61c6   cd 28 64
l61c9h:        ;<-----+ ; ; ; ; ; ;
    ld hl,(HeapPtr)     ; ; ; ; ; ; ;61c9
    dec hl              ; ; ; ; ; ; ;61cc
    dec hl              ; ; ; ; ; ; ;61cd
    dec hl              ; ; ; ; ; ; ;61ce
    dec hl              ; ; ; ; ; ; ;61cf
    ld (HeapPtr),hl     ; ; ; ; ; ; ;61d0   (HeapPtr)=(HeapPtr)-4
    ld hl,(l0217h)      ; ; ; ; ; ; ;61d3   2a 17 02
    ex de,hl            ; ; ; ; ; ; ;61d6   eb
l61d7h:     ;<------;   ; ; ; ; ; ;
    ld l,e          ;   ; ; ; ; ; ; ;61d7
    ld h,d          ;   ; ; ; ; ; ; ;61d8   hl=de
    inc hl          ;   ; ; ; ; ; ; ;61d9
    inc hl          ;   ; ; ; ; ; ; ;61da
    inc hl          ;   ; ; ; ; ; ; ;61db
    inc hl          ;   ; ; ; ; ; ; ;61dc   hl=hl+4
    ld b,4          ;   ; ; ; ; ; ; ;61dd   b=4
    call l0863h     ;   ; ; ; ; ; ; ;61df   Move B bytes from ^HL to ^DE
    ld hl,(HeapPtr) ;   ; ; ; ; ; ; ;61e2   2a 19 02
    call cmpHL.DE   ;   ; ; ; ; ; ; ;61e5   Compare HL with DE
    jp nc,l61d7h ;--+   ; ; ; ; ; ; ;61e8   if HL >= DE --> ...
l61ebh:     ;<--------; ; ; ; ; ; ;
    call s_6482h      ; ; ; ; ; ; ; ;61eb   cd 82 64
    ld a,b            ; ; ; ; ; ; ; ;61ee   78
    cp 0ch            ; ; ; ; ; ; ; ;61ef
    jp nz,l60b3h      ; ; ; ; ; ; ; ;61f1   if a.ne.0ch --> ...
    ld hl,(l01cah)    ; ; ; ; ; ; ; ;61f4
    ld de,0fff0h      ; ; ; ; ; ; ; ;61f7
    add hl,de         ; ; ; ; ; ; ; ;61fa
    ld (l01cah),hl    ; ; ; ; ; ; ; ;61fb   (l01cah)=(l01cah)-16
    jp l60b3h         ; ; ; ; ; ; ; ;61fe   --> ...`
                      ; ; ; ; ; ; ;
l6201h:         ;<----)-)-)-)-)-)-+
    ld hl,(HeapPtr)   ; ; ; ; ; ;   ;6201
    ld de,-8          ; ; ; ; ; ;   ;6204
    add hl,de         ; ; ; ; ; ;   ;6207
    ld (HeapPtr),hl   ; ; ; ; ; ;   ;6208   (HeapPtr)=(HeapPtr)-8
    ld hl,(l01cah)    ; ; ; ; ; ;   ;620b
    ld a,l            ; ; ; ; ; ;   ;620e
    or h              ; ; ; ; ; ;   ;620f
    jp nz,l6234h ;--; ; ; ; ; ; ;   ;6210   if(l01cah).ne.0 --> ...
    ld hl,(l0235h)  ; ; ; ; ; ; ;   ;6213
    ld (l0244h),hl  ; ; ; ; ; ; ;   ;6216   (l0244h)=(l0235h)
    ld a,(l0232h)   ; ; ; ; ; ; ;   ;6219
    or a            ; ; ; ; ; ; ;   ;621c
    jp z,l6440h     ; ; ; ; ; ; ;   ;621d   if (l0232h).eq.0 --> (l01cfh)=(l0237h); (TypeID)=(l01eeh); (l0231h)=(l0232h); ret
    ld hl,(l0237h)  ; ; ; ; ; ; ;   ;6220
    ld (l0235h),hl  ; ; ; ; ; ; ;   ;6223   (l0235h)=(l0237h)
    call s_63fbh    ; ; ; ; ; ; ;   ;6226   cd fb 63
    xor a           ; ; ; ; ; ; ;   ;6229
    ld (l0231h),a   ; ; ; ; ; ; ;   ;622a   (l0231h)=0
    ld hl,(l0235h)  ; ; ; ; ; ; ;   ;622d
    ld (l01cfh),hl  ; ; ; ; ; ; ;   ;6230   (l01cfh)=(l0235h)
    ret             ; ; ; ; ; ; ;   ;6233
                    ; ; ; ; ; ; ;
l6234h:     ;<------+ ; ; ; ; ; ;
    ld hl,(l0217h)    ; ; ; ; ; ;   ;6234   2a 17 02 
    ex de,hl          ; ; ; ; ; ;   ;6237   eb
l6238h:     ;<------; ; ; ; ; ; ;
    ld l,e          ; ; ; ; ; ; ;   ;6238
    ld h,d          ; ; ; ; ; ; ;   ;6239   hl=de
    ld bc,00008h    ; ; ; ; ; ; ;   ;623a
    add hl,bc       ; ; ; ; ; ; ;   ;623d   hl=hl+8
    ld b,4          ; ; ; ; ; ; ;   ;623e   b=4
    call l0863h     ; ; ; ; ; ; ;   ;6240   Move B bytes from ^HL to ^DE
    ld hl,(HeapPtr) ; ; ; ; ; ; ;   ;6243   2a 19 02    * . . 
    call cmpHL.DE   ; ; ; ; ; ; ;   ;6246   Compare HL with DE
    jp nz,l6238h ;--+ ; ; ; ; ; ;   ;6249   HL ne DE
    ld hl,(l0237h)    ; ; ; ; ; ;   ;624c   2a 37 02
    ex de,hl          ; ; ; ; ; ;   ;624f   eb
    ld a,(l0232h)     ; ; ; ; ; ;   ;6250   3a 32 02
    rrca              ; ; ; ; ; ;   ;6253   0f
    ld b,a            ; ; ; ; ; ;   ;6254   47
    ld hl,(l0217h)    ; ; ; ; ; ;   ;6255   2a 17 02
    ld a,(hl)         ; ; ; ; ; ;   ;6258   7e
    and 01fh          ; ; ; ; ; ;   ;6259   00011111b
    or b              ; ; ; ; ; ;   ;625b   b0
    ld (hl),a         ; ; ; ; ; ;   ;625c   77
    inc hl            ; ; ; ; ; ;   ;625d   23
    ld a,(l01eeh)     ; ; ; ; ; ;   ;625e   3a ee 01 
    ld (hl),a         ; ; ; ; ; ;   ;6261   77
    inc hl            ; ; ; ; ; ;   ;6262   23  #
    ld (hl),e         ; ; ; ; ; ;   ;6263
    inc hl            ; ; ; ; ; ;   ;6264   23  #
    ld (hl),d         ; ; ; ; ; ;   ;6265   (hl)=de
    jp l61ebh   ;-----+ ; ; ; ; ;   ;6266   --> ...
                        ; ; ; ; ;
l6269h:     ;<----------)-)-)-+ ;
    ld a,(l0232h)       ; ; ;   ;   ;6269
    or a                ; ; ;   ;   ;626c
    jp z,l6275h ;--;    ; ; ;   ;   ;626d   if (l0232h).eq.0 --> ...
    ld a,3         ;    ; ; ;   ;   ;6270
    ld (l0243h),a  ;    ; ; ;   ;   ;6272   (l0243h)=3
l6275h:     ;<-----+    ; ; ;   ;
    ld a,(l0231h)       ; ; ;   ;   ;6275 
    or a                ; ; ;   ;   ;6278
    jp z,l61c0h         ; ; ;   ;   ;6279   if (l0231h).eq.0 --> ...
    ld hl,l0243h        ; ; ;   ;   ;627c
    ld a,4              ; ; ;   ;   ;627f
    sub (hl)            ; ; ;   ;   ;6281
    ld (hl),a           ; ; ;   ;   ;6282   (l0243h)=4-(l0243h)
    dec a               ; ; ;   ;   ;6283
    jp z,l61c0h         ; ; ;   ;   ;6284   if (l0243h).eq.1 --> ...
    ld hl,(l0209h)      ; ; ;   ;   ;6287
    ex de,hl            ; ; ;   ;   ;628a
    ld hl,(l0235h)      ; ; ;   ;   ;628b
    call cmpHL.DE       ; ; ;   ;   ;628e   Compare HL with DE
    jp c,l61c0h         ; ; ;   ;   ;6291   if (l0235h) < (l0209h) --> ...
    xor a               ; ; ;   ;   ;6294
    ld (l0231h),a       ; ; ;   ;   ;6295   (l0231h)=0
    jp l62a6h  ;--;     ; ; ;   ;   ;6298   --> ...
                  ;     ; ; ;   ;
l629bh:    ;<-----)-----)-)-+   ;
    ld hl,l0231h  ;     ; ;     ;   ;629b
    ld a,(l0232h) ;     ; ;     ;   ;629e
    xor (hl)      ;     ; ;     ;   ;62a1
    ld (hl),a     ;     ; ;     ;   ;62a2   (l0231h)=(l0231h).xor.(l0232h) 
    jp l61c0h     ;     ; ;     ;   ;62a3   --> ...
                  ;     ; ;     ;
l62a6h:       ;<--+ <---)-+     ;
    call s_6453h        ;       ;   ;62a6   {(l0235h)<->(l0237h); (l01edh)<->l01eeh); (l01eah)<->(l01ebh)}
    jp l61c0h           ;       ;   ;62a9   --> ...
                        ;       ;
l62ach:     ;<----------+       ;
    ld hl,(l0237h)              ;   ;62ac
    ex de,hl                    ;   ;62af
    ld hl,(l0209h)              ;   ;62b0
    call subHL.DE               ;   ;62b3   hl=(l0209h)-(l0237h)
    jp c,l62d8h  ;--;           ;   ;62b6   if (l0206h) < 0 (l0236h) --> ...
    ld a,(hl)       ;           ;   ;62b9   7e
    and 0fh         ;           ;   ;62ba   00001111b
    cp 0dh          ;           ;   ;62bc
    jp c,l62d8h  ;--;           ;   ;62be   if a < 0dh --> ...
    cp 13h          ;           ;   ;62c1
    jp nc,l62d8h ;--;           ;   ;62c3   if a >= 013h --> ...
    ex de,hl        ;           ;   ;62c6   de=(l0209h)-(l0237h)
    ld hl,l04d6h    ;           ;   ;62c7   hl= Point to Table
    ld c,a          ;           ;   ;62ca
    ld b,0          ;           ;   ;62cb   bc=a
    add hl,bc       ;           ;   ;62cd   09
    ld b,(hl)       ;           ;   ;62ce   46
    ex de,hl        ;           ;   ;62cf   eb
    ld a,(hl)       ;           ;   ;62d0   7e
    and 0e0h        ;           ;   ;62d1   11100000b
    or b            ;           ;   ;62d3   b0
    ld (hl),a       ;           ;   ;62d4   77
    jp l61c9h       ;           ;   ;62d5   --> ...
                    ;           ;
l62d8h:     ;<------+           ;
    call s_6453h                ;   ;62d8   {(l0235h)<->(l0237h); (l01edh)<->l01eeh); (l01eah)<->(l01ebh)}
    ld a,(l01edh)               ;   ;62db
    ld (l01eeh),a               ;   ;62de   (l01eeh)=(l01edh)
    ld a,(l0231h)               ;   ;62e1
    or a                        ;   ;62e4
    call nz,s_6409h             ;   ;62e5   if (l0231h).ne.0 call ...
    ld hl,(l0235h)              ;   ;62e8
    ld (l0237h),hl              ;   ;62eb   (l0237h)=(l0235h)
    ld a,15h                    ;   ;62ee
    ld (l0243h),a               ;   ;62f0   (l0243h)=15h
    xor a                       ;   ;62f3
    ld (l0231h),a               ;   ;62f4   (l0231h)=0
    jp l61c0h                   ;   ;62f7   --> ...
                                ;
;?  No execution path to here   ;
    ld hl,(l0217h)              ;   ;62fa   2a 17 02
    inc hl                      ;   ;62fd   23
    inc hl                      ;   ;62fe   23
    inc hl                      ;   ;62ff   23
    inc hl                      ;   ;6300   23
    ld a,(hl)                   ;   ;6301   7e
    xor 080h                    ;   ;6302   10000000b
    ld (hl),a                   ;   ;6304   77
    jp l61c9h                   ;   ;6305   --> ...
                                ;
l6308h:             ;<----------+
    ld a,(l0243h)                   ;6308
    ld (l027ah),a                   ;630b   (l027ah)=(l0243h)
    ld hl,(l0217h)                  ;630e
    ld (l0278h),hl                  ;6311   (l0278h)=(l027ah)
    xor a                           ;6314
    ld (l027ch),a                   ;6315   (l027ch)=0
l6318h:    ;<---------------;
    ld a,(l01eah)           ;       ;6318
    dec a                   ;       ;631b
    jp z,l6336h ;-;         ;       ;631c   if (l01eah).eq.1 --> ...
    ld a,(l01ebh) ;         ;       ;631f
    or a          ;         ;       ;6322
    jp z,l6376h ;-)-----;   ;       ;6323   if (l01ebh).eq.0 --> ...
l6326h:      ;<---)-----)-; ;
    ld a,(l0231h) ;     ; ; ;   ;6326   a=(l0231h)
    call s_6428h  ;     ; ; ;   ;6329   cd 28 64
    call l6440h   ;     ; ; ;   ;632c   {(l01cfh)=(l0237h); (TypeID)=(l01eeh); (l0231h)=(l0232h);}
    call s_64dah  ;     ; ; ;   ;632f   cd da 64
    ld hl,l027ch  ;     ; ; ;   ;6332
    inc (hl)      ;     ; ; ;   ;6335   (l027ch)=(l027ch)+1
l6336h:     ;<----+ <-; ; ; ;
    ld hl,(l0217h)    ; ; ; ;   ;6336
    inc hl            ; ; ; ;   ;6339
    inc hl            ; ; ; ;   ;633a
    inc hl            ; ; ; ;   ;633b
    inc hl            ; ; ; ;   ;633c
    ld (l0217h),hl    ; ; ; ;   ;633d   (l0217h)=(l0217h)+4
    ex de,hl          ; ; ; ;   ;6340
    ld hl,(HeapPtr)   ; ; ; ;   ;6341
    dec hl            ; ; ; ;   ;6344
    dec hl            ; ; ; ;   ;6345
    dec hl            ; ; ; ;   ;6346
    dec hl            ; ; ; ;   ;6347
    ex de,hl          ; ; ; ;   ;6348
    call cmpHL.DE     ; ; ; ;   ;6349   Compare HL with DE
    jp nc,l635ch;-;   ; ; ; ;   ;634c   if (l0214h) >= (HeapPtr)-4 --> ...
l634fh:        ;<-)-; ; ; ; ;
    call s_63ceh  ; ; ; ; ; ;   ;634f   cd ce 63
    ld a,(l0243h) ; ; ; ; ; ;   ;6352
    ld hl,l027ah  ; ; ; ; ; ;   ;6355
    cp (hl)       ; ; ; ; ; ;   ;6358
    jp z,l6318h ;-)-)-)-)-)-+   ;6359   if (l0243h).eq.(l027ah) --> ...
l635ch:     ;<----+ ; ; ; ;
    ld hl,(l0278h)  ; ; ; ;     ;635c
    ld (l0217h),hl  ; ; ; ;     ;635f   (l0217h)=(l0278h)
    ld a,(l027ch)   ; ; ; ;     ;6362
    or a            ; ; ; ;     ;6365
    jp nz,l636fh;-; ; ; ; ;     ;6366   if (l027ch).ne.0 --> ...
    call s_63ceh  ; ; ; ; ;     ;6369   cd ce 63
    jp l6166h     ; ; ; ; ;     ;636c   --> ...
                  ; ; ; ; ;
l636fh:      ;<---+ ; ; ; ;
    xor a           ; ; ; ;     ;636f   a=0
    ld (l027ch),a   ; ; ; ;     ;6370   (l027ch)=0
    jp l634fh  ;----+ ; ; ;     ;6373   --> ...
                      ; ; ;
l6376h:      ;<-------)-+ ;
    ld hl,(l0209h)    ;   ;     ;6376
    push hl           ;   ;     ;6379 \ Save (l0209h)
    ld hl,(l0235h)    ;   ;     ;637a
    ex de,hl          ;   ;     ;637d
    ld hl,(l0237h)    ;   ;     ;637e
    call cmpHL.DE     ;   ;     ;6381   Compare HL with DE
    jp c,l6389h ;---; ;   ;     ;6384   if (l0237h) < (l0235h) --> ...
    pop de          ; ;   ;     ;6387 / Restore de=(l0209h)
    db 03eh         ; ;   ;     ;6388   ld a,0e1h (in the original) trap_ms ***
l6389h:         ;<--+ ;   ;
    pop hl            ;   ;     ;6389 / Restore hl=(l0209h)
    jp z,l6336h   ;---;   ;     ;638a   if (l0237h).eq.(l0235h) --> ...
    call cmpHL.DE     ;   ;     ;638d   Compare HL with DE
    jp nc,l6336h  ;---+   ;     ;6390   if HL >= DE --> ...
    jp l6326h  ;----------+     ;6393   --> ...
;
;
;
s_6396h:
    call s_6482h        ;6396   cd 82 64
    ld a,b              ;6399   78
    ld (l0243h),a       ;639a   (l0243h)=
    ld a,c              ;639d   79
    ld (l01edh),a       ;639e   (l01edh)=
    ld hl,(l0217h)      ;63a1   2a 17 02
    ld a,(hl)           ;63a4   7e
    and 080h            ;63a5   1000000b
    rlca                ;63a7   Multiply by 2
    ld (l0231h),a       ;63a8   (l0231h)=
    xor a               ;63ab   a=0
    ld (l01eah),a       ;63ac   (l01eah)=0
    inc hl              ;63af   23
    inc hl              ;63b0   23
    ld e,(hl)           ;63b1   5e
    inc hl              ;63b2   23
    ld d,(hl)           ;63b3   56
    ld hl,(l0209h)      ;63b4
    ex de,hl            ;63b7
    ld (l0235h),hl      ;63b8   (l0235h)=
    call cmpHL.DE       ;63bb
    ret c               ;63be   if (l0235h) < (l0209h) Return
    call ExtAttr        ;63bf   Extract Attributes from the symbol table
    dec a               ;63c2
    ret nz              ;63c3   if (KindID).ne.1 (Constant) Return
    ld a,(TypeID)       ;63c4
    or a                ;63c7
    ret nz              ;63c8   if (TypeID).ne.0 (INTEGER) Return
    inc a               ;63c9
    ld (l01eah),a       ;63ca   (l01eah)=(TypeID)+1
    ret                 ;63cd
;*
;*
;*
s_63ceh:
    ld hl,(l0217h)      ;63ce
    push hl             ;63d1 \ Save (l0214h) ------;
    inc hl              ;63d2                       ;
    inc hl              ;63d3                       ;
    inc hl              ;63d4                       ;
    inc hl              ;63d5                       ;
    ld (l0217h),hl      ;63d6   (l0217h)=(l0217h)+4 ;
    call s_6396h        ;63d9   cd 96 63            ;
    pop hl              ;63dc / Restore <-----------+
    ld (l0217h),hl      ;63dd   (l0217h)=
    ld hl,(l0235h)      ;63e0
    ld (l0237h),hl      ;63e3   (l0237h)=(l0235h)
    ld a,(l01edh)       ;63e6
    ld (l01eeh),a       ;63e9   (l01eeh)=(l01edh)
    ld a,(l0231h)       ;63ec
    ld (l0232h),a       ;63ef   (l0232h)=(l0231h)
    ld a,(l01eah)       ;63f2
    ld (l01ebh),a       ;63f5   (l01ebh)=(l01eah)
    jp s_6396h          ;63f8   --> ...
;*
;*
;*
s_63fbh:
    ld hl,(l0235h)      ;63fb
    ld (l0237h),hl      ;63fe   (l0237h)=(l0235h)
    ld a,0ch            ;6401
    ld (l0243h),a       ;6403   (l0243h)=0ch
    jp s_0ecdh          ;6406   --> ...
;*
;*
;*
s_6409h:
    call s_63fbh        ;6409   cd fb 63
    ld hl,(l0235h)      ;640c   hl=(l0235h)
    ex de,hl            ;640f               de=(l0235h)
    ld hl,(l0217h)      ;6410   hl=(l0217h)
    inc hl              ;6413
    inc hl              ;6414   hl=(l0217h)+2
    ld (hl),e           ;6415
    inc hl              ;6416
    ld (hl),d           ;6417   ((l0217h)+2)=(l0235h)
    jp s_63ceh          ;6418   --> ...
;
;
;
s_641bh:
    ld hl,(l0217h)      ;641b
    inc hl              ;641e
    inc hl              ;641f
    inc hl              ;6420
    inc hl              ;6421   hl=(l0217h)+4
    rra                 ;6422   1f
    ld a,(hl)           ;6423   7e
    rla                 ;6424   17
    rrca                ;6425   0f
    ld (hl),a           ;6426   77
    ret                 ;6427
;
;
;
s_6428h:
    call s_641bh        ;6428   cd 1b 64
    ld hl,(l0235h)      ;642b   2a 35 02
    ex de,hl            ;642e   eb
    ld hl,(l0217h)      ;642f
    inc hl              ;6432
    inc hl              ;6433
    inc hl              ;6434
    inc hl              ;6435
    inc hl              ;6436   hl=(l0217h)+5
    ld a,(l01edh)       ;6437   3a ed 01
    ld (hl),a           ;643a   77
    inc hl              ;643b   23
    ld (hl),e           ;643c   73
    inc hl              ;643d   23
    ld (hl),d           ;643e   72
    ret                 ;643f
;*
;*  (l01cfh)=(l0237h); (TypeID)=(l01eeh); (l0231h)=(l0232h)
;*
l6440h:
    ld hl,(l0237h)      ;6440
    ld (l01cfh),hl      ;6443   (l01cfh)=(l0237h)
    ld a,(l01eeh)       ;6446
    ld (TypeID),a       ;6449   (TypeID)=(l01eeh)
    ld a,(l0232h)       ;644c
    ld (l0231h),a       ;644f   (l0231h)=(l0232h)
    ret                 ;6452
;*
;*  (l0235h)<->(l0237h); (l01edh)<->l01eeh); (l01eah)<->(l01ebh)
;*
s_6453h:
    ld hl,(l0235h)      ;6453                               hl=(l0235h)
    ex de,hl            ;6456                                           de=(l0235h)
    ld hl,(l0237h)      ;6457                               hl=(l0237h)
    ld (l0235h),hl      ;645a   (l0235h)=(l0237h)
    ex de,hl            ;645d                               hl=(l0235h) de=(l0237h)
    ld (l0237h),hl      ;645e   (l0237h)=old value(l0235h)
    ld hl,l01edh        ;6461                               hl=l01edh
    ld de,l01eeh        ;6464                                           de=l01eeh
    ld b,(hl)           ;6467                   b=(l01edh)
    ld a,(de)           ;6468
    ld (hl),a           ;6469   (l01edh)=(l01eeh)
    ex de,hl            ;646a                               hl=l01eeh   de=l01edh
    ld (hl),b           ;646b   (l01eeh)=old value(l01edh)
    ld hl,l01eah        ;646c                               hl=l01eah
    ld de,l01ebh        ;646f                                           de=l01ebh
    ld b,(hl)           ;6472                   b=(l01eah) 
    ld a,(de)           ;6473
    ld (hl),a           ;6474   (l01eah)=(l01ebh)
    ex de,hl            ;6475                               hl=l01ebh   de=l01eah
    ld (hl),b           ;6476   (l01ebh)=old value(l01eah)
    ret                 ;6477
;
;   Entry Reg A = 0ch (0000 0110b)
;
s_6478h:
    ld b,a              ;6478   b= 0000 1100b (0ch)
    ld hl,(l0217h)      ;6479   2a 17 02
    ld a,0e0h           ;647c   a= 1110 0000b
    and (hl)            ;647e   a6
    or b                ;647f   b0
    ld (hl),a           ;6480   (l0217h)=
    ret                 ;6481
;
;
;
s_6482h:
    ld hl,(l0217h)      ;6482   2a 17 02    * . . 
    ld a,01fh           ;6485   3e 1f   > .
    and (hl)            ;6487   a6  . 
    ld b,a              ;6488   47  G
    inc hl              ;6489   23  #
    ld c,(hl)           ;648a   4e  N 
    ld hl,l04cah        ;648b   21 ca 04    ! . . 
    ld e,b              ;648e   58  X
    ld d,0              ;648f   16 00   . .
    add hl,de           ;6491   19  . 
    ld a,(hl)           ;6492   7e  ~ 
    ret                 ;6493
;
;
;
l6494h:
    ld hl,(l01b2h)      ;6494   2a b2 01    * . . 
    ex de,hl            ;6497   eb  . 
    ld hl,(l01b0h)      ;6498   2a b0 01    * . . 
    call s_64b4h        ;649b   cd b4 64    . . d 
    ld hl,(l01aeh)      ;649e   2a ae 01    * . . 
    call s_64b3h        ;64a1   cd b3 64    . . d 
    ld hl,(l01aah)      ;64a4   2a aa 01    * . . 
    call s_64b3h        ;64a7   cd b3 64    . . d 
    ld hl,(l01a6h)      ;64aa   2a a6 01    * . . 
    call s_64b3h        ;64ad   cd b3 64    . . d 
    ld hl,(l01a8h)      ;64b0   2a a8 01    * . . 
;
;
;
s_64b3h:
    ex de,hl            ;64b3   eb  . 
;
s_64b4h:
    ld (hl),e           ;64b4   73  s 
    inc hl              ;64b5   23  #
    ld (hl),d           ;64b6   72  r 
    inc hl              ;64b7   23  #
    ex de,hl            ;64b8   eb  . 
    ret                 ;64b9
;*
;*  Select COMMON block ?
;*
s_64bah:
    ld hl,(l0176h)      ;64ba                   hl=(l0176h)
    ex de,hl            ;64bd                                   de=(l0176h)
    ld hl,(EntryID)     ;64be                   hl=(EntryID)
    call cmpHL.DE       ;64c1
    ret z               ;64c4   if (EntryID).eq.(l0176h) Return
    ex de,hl            ;64c5                   hl=(l0176h)     de=(EntryID)
    ld hl,(l01cfh)      ;64c6                   hl=(l01cfh)
    push hl             ;64c9 \ Save (l01cfh)
    ex de,hl            ;64ca                   hl=(EntryID)     de=(l01cfh)
    ld (l0176h),hl      ;64cb   (l0176h)=(EntryID)
    call ExtAttr        ;64ce   Extract Attributes from the symbol table
    ld c,0001b          ;64d1   rel types - select COMMON BLOCK
    call RELITEM        ;64d3   Select common block
    pop hl              ;64d6 / hl=(l01cfh)
    jp ExtAttr          ;64d7   --> Extract Attributes from the symbol table
;
;
;
s_64dah:
    ld hl,(l0217h)      ;64da   2a 17 02
    ld a,(l0231h)       ;64dd   3a 31 02
    rrca                ;64e0   0f
    ld b,a              ;64e1   47
    ld a,(l0243h)       ;64e2   3a 43 02
    or b                ;64e5   b0
    ld (hl),a           ;64e6   77
    inc hl              ;64e7   23
    ld a,(TypeID)       ;64e8   Load value type variable
    ld (hl),a           ;64eb   77
    ex de,hl            ;64ec   eb
    ld hl,(l01cfh)      ;64ed   2a cf 01
    inc de              ;64f0   13
    ex de,hl            ;64f1   eb
    ld (hl),e           ;64f2   73
    inc hl              ;64f3   23
    ld (hl),d           ;64f4   72
    ret                 ;64f5
;*
;*  hl=hl-de
;*
subHL.DE:
    ld a,l              ;64f6
    sub e               ;64f7   Subtract LO
    ld l,a              ;64f8
    ld a,h              ;64f9
    sbc a,d             ;64fa   .. and HI
    ld h,a              ;64fb
    ret                 ;64fc
;*
;*  Search statements
;*
l64fdh:
    call s_5cceh        ;64fd   Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
    ld a,4              ;6500   a=4
    call GetStr         ;6502   Reading string length 4 characters
    ld hl,(l01e0h)      ;6505
    ld a,h              ;6508
    cp cr               ;6509
    jp z,Firstep        ;650b   if a.eq.cr --> First step of the compilation
    ld (l022eh),hl      ;650e   (l022eh)=(l01e0h) Copy 1 and 2 bytes statement
    ld hl,(l01deh)      ;6511
    ld (l022ch),hl      ;6514   (l022ch)=(l01deh) Copy 3 and 4 bytes statement
    ld hl,l032ah        ;6517   hl=pointer Statements table
;*
;*  Comparing with line of the table
;*
l651ah:           ;<-----;
    push hl              ;  ;651a   Save current pointer in table
    ld b,4               ;  ;651b   b=4 (number of checked characters)
    ld de,l022fh         ;  ;651d   Address 1 byte source string
l6520h:                  ;
      ld a,(hl)          ;  ;6520
      cp ' '             ;  ;6521
      jp z,l652bh ;--;   ;  ;6523   if (hl).eq.' ' --> ...
      ld a,(de)      ;   ;  ;6526
      cp (hl)        ;   ;  ;6527
      jp nz,l6560h ;-)-; ;  ;6528   if (de).ne.(hl) --> ...
l652bh:          ;<--+ ; ;
      inc hl           ; ;  ;652b   hl=hl+1
      dec de           ; ;  ;652c   de=de-1
      dec b            ; ;  ;652d   b=b-1
    jp nz,l6520h       ; ;  ;652e   if b.ne.0 --> ...
    ld c,(hl)          ; ;  ;6531   1 - Offset
    inc hl             ; ;  ;6532
    ld a,(hl)          ; ;  ;6533   2 - Type statement
    inc hl             ; ;  ;6534
    ld e,(hl)          ; ;  ;6535   3
    inc hl             ; ;  ;6536
    ld d,(hl)          ; ;  ;6537   4 de=address program processing statement
    ex de,hl           ; ;  ;6538
    ld (CurAdr),hl     ; ;  ;6539   Store the address program processing statement
    pop hl             ; ;  ;653c   Restore current pointer
    dec c              ; ;  ;653d
    jp m,l6559h ;----; ; ;  ;653e   if c < 1 --> Found statement length of 4 characters
    push af          ; ; ;  ;6541   Save Type statement
    ld b,0           ; ; ;  ;6542   b=0
    ld hl,l042ah     ; ; ;  ;6544   hl=pointer Table Continuation of statements
    add hl,bc        ; ; ;  ;6547   Calculate position in the table
l6548h:       ;<---; ; ; ;
    push hl        ; ; ; ;  ;6548
    call g_n_chr   ; ; ; ;  ;6549   Get next character
    pop hl         ; ; ; ;  ;654c
    xor (hl)       ; ; ; ;  ;654d   ae
    rla            ; ; ; ;  ;654e   17
    inc a          ; ; ; ;  ;654f   3c
    dec a          ; ; ; ;  ;6550   3d
    jp nz,err101   ; ; ; ;  ;6551   if ne.0 --> Error (101) Statement Unrecognizable or Misspelled
    inc hl         ; ; ; ;  ;6554   23
    jp nc,l6548h ;-+ ; ; ;  ;6555   if >= --> Compare the following symbol
    pop af           ; ; ;  ;6558   Restore Type statement
                     ; ; ;
;*  Found statement  ; ; ;
                     ; ; ;
l6559h:         ;<---+ ; ;
    call s_5e97h       ; ;  ;6559   cd 97 5e
    ld hl,(CurAdr)     ; ;  ;655c   Load address program processing statement
    jp (hl)            ; ;  ;655f   Switch to processing --> ...
                       ; ;
l6560h:         ;<-----+ ;
    pop hl               ;  ;6560   Restore pointer in table
    ld de,00008h         ;  ;6561
    add hl,de            ;  ;6564   hl=hl+8
    ld de,l042ah         ;  ;6565   de=Adress first byte located after the table
    call cmpHL.DE        ;  ;6568
    jp c,l651ah     ;----+  ;656b   if HL < DE --> Comparing with the next line of the table
err101:
    call err.msg            ;656e   Error (101)
    db 101                  ;6571   Statement Unrecognizable or Misspelled
;*
;*  ENTRY
;*    Reg HL - Par
;*
l6572h:
    ld bc,0010bh            ;6572   Address_modes CSEG, REL type - set LOCATION COUNTER
;*
;*  ENTRY
;*    Reg HL - Par
;*    Reg  B - Address_modes
;*    Reg  C - REL type
;*
s_6575h:
    ld a,b                  ;6575
    cp 2                    ;6576
    ld a,1                  ;6578   a=1
    jp nz,l657eh ;--;       ;657a   if Address_modes.ne.2 (DSEG) -->   trap_ms
    db 0feh         ;       ;657d   cp 0afh (in the original)          trap_ms
l657eh:         ;<--+
    xor a                   ;657e   a=0
    ld (l01a3h),a           ;657f   (l01a3h)=0 (or 1)
    ex de,hl                ;6582   de=Par
    ld hl,(PrgSiz)          ;6583   Load Program size
    ld (l021eh),hl          ;6586   (l021eh)=(PrgSiz)
    ex de,hl                ;6589   hl=Par
    ld (PrgSiz),hl          ;658a   (PrgSiz)=Par Save Program size
    ex de,hl                ;658d
    jp RELITEM              ;658e   Give CSEG location counter
;*
;*
;*
s_6591h:
    pop hl                  ;6591 / e1
    ld (l0260h),hl          ;6592   (l0260h)=
    ex de,hl                ;6595   eb
    ld (l025ch),hl          ;6596   (l025ch)
    ex de,hl                ;6599   eb
    ld hl,(l020ch)          ;659a
    ld (l025eh),hl          ;659d   (l025eh)=(l020ch)
    jp l65b6h   ;-------;   ;65a0   --> ...
                        ;
l65a3h:                 ;
    ld hl,(l025ch)      ;   ;65a3   2a 5c 02
    push hl             ;   ;65a6 \ e5
    ld hl,(l025eh)      ;   ;65a7   2a 5e 02
    ex de,hl            ;   ;65aa   eb
    ld hl,(l0209h)      ;   ;65ab   2a 09 02
    call subHL.DE       ;   ;65ae   hl=hl-de
    pop de              ;   ;65b1 / d1
    dec hl              ;   ;65b2
    dec hl              ;   ;65b3   hl=hl-2
l65b4h:   ;<--------;   ;
    dec hl          ;   ;   ;65b4   2b
l65b5h:      ;<-----)-; ;
    dec hl          ; ; ;   ;65b5   2b
l65b6h:         ;<--)-)-+
    push de         ; ;     ;65b6 \ Save de
    ex de,hl        ; ;     ;65b7   eb
    ld hl,(HeapEnd) ; ;     ;65b8   2a 15 02
    inc hl          ; ;     ;65bb   23
    ex de,hl        ; ;     ;65bc   eb
    call cmpHL.DE   ; ;     ;65bd   Compare HL with DE
    pop de          ; ;     ;65c0 / Restore de
    jp c,l65e1h ;---)-)-;   ;65c1   da e1 65
    dec hl          ; ; ;   ;65c4   2b
    dec hl          ; ; ;   ;65c5   2b
    ld a,(hl)       ; ; ;   ;65c6   7e
    cp d            ; ; ;   ;65c7   ba
    jp nz,l65b4h ;--+ ; ;   ;65c8   if a.ne d --> ...
    dec hl            ; ;   ;65cb   hl=hl-1
    ld a,(hl)         ; ;   ;65cc   7e
    sub e             ; ;   ;65cd   93
    jp nz,l65b5h ;----+ ;   ;65ce   c2 b5 65
    inc hl              ;   ;65d1   23
    inc hl              ;   ;65d2   23
    inc hl              ;   ;65d3   23
    push hl             ;   ;65d4 \ e5
    ex de,hl            ;   ;65d5   eb
    ld hl,(l0209h)      ;   ;65d6   2a 09 02
    call subHL.DE       ;   ;65d9   hl=hl-de
    ld (l025eh),hl      ;   ;65dc   (l025eh)=
    pop de              ;   ;65df / d1
    xor a               ;   ;65e0   a=0
l65e1h:         ;<------+
    ld hl,(l0260h)          ;65e1   2a 60 02
    push hl                 ;65e4 \ e5
    ex de,hl                ;65e5   eb
    ret                     ;65e6
;
;?                           !! No execution path to here !!
    push hl                 ;65e7 \ 
    ld bc,2                 ;65e8   bc=2
    call ChkMem             ;65eb   Test Allocate A bytes of memory
    ld hl,(l01b0h)          ;65ee   2a b0 01
    inc hl                  ;65f1   23
    pop de                  ;65f2   d1
    ld (hl),e               ;65f3   73
    inc hl                  ;65f4   23
    ld (hl),d               ;65f5   72
    ld (l01b0h),hl          ;65f6   22 b0 01
    ret                     ;65f9
;*
;*  Ending parsing statement
;*
l65fah:
    ld hl,(HeapPtr)         ;65fa
    ex de,hl                ;65fd
    ld hl,(HeapEnd)         ;65fe
    call subHL.DE           ;6601   hl=hl-de
    ld de,190h              ;6604   ????
    call cmpHL.DE           ;6607   Compare HL with DE
    call c,s_41f7h          ;660a   if ((HeapEnd)-(HeapPtr)) < 190h call ...
    ld a,(l0299h)           ;660d
    cp cr                   ;6610
    jp z,l6619h ;---;       ;6612   if (l0299h).eq.cr --> Skip error message
err102:             ;
    call err.msg    ;       ;6615   Error (102)
    db 102          ;       ;6618   Illegal Statement Completion
l6619h:        ;<---+
    ld hl,(l0264h)          ;6619
    ld a,h                  ;661c
    or l                    ;661d
    jp z,Firstep            ;661e   if(l0264h).eq.0 --> First step of the compilation
l6621h:            ;<---;
    ld hl,(l01a4h)      ;   ;6621   2a a4 01
    ld bc,00000h        ;   ;6624   bc=0 counter
l6627h:     ;<--------; ;
      ld de,-10       ; ;   ;6627
      add hl,de       ; ;   ;662a   hl=hl-10
      ld (l01b0h),hl  ; ;   ;662b   22 b0 01
      ld de,l68f7h    ; ;   ;662e   Address of the first byte of the data area
      call cmpHL.DE   ; ;   ;6631   Compare HL with DE
      jp c,Firstep    ; ;   ;6634   if (l01b0h) < l68f7h --> First step of the compilation
      push hl         ; ;   ;6637 \ e5
      push bc         ; ;   ;6638 \ c5
      call s_5609h    ; ;   ;6639   cd 09 56
      ld hl,(l0264h)  ; ;   ;663c
      ex de,hl        ; ;   ;663f
      ld hl,(l01b2h)  ; ;   ;6640
      call cmpHL.DE   ; ;   ;6643   Compare HL with DE
      jp z,l6650h ;-; ; ;   ;6646   if (l01b2h).eq.(l0264h) --> ...
      ld b,h        ; ; ;   ;6649
      ld c,l        ; ; ;   ;664a   bc=hl
      pop hl        ; ; ;   ;664b / e1
      pop hl        ; ; ;   ;664c / e1
    jp l6627h   ;---)-+ ;   ;664d   --> ...
                    ;   ;
l6650h:        ;<---+   ;
    ld a,(DO_Flg)       ;   ;6650
    or a                ;   ;6653
    jp z,l665bh  ;--;   ;   ;6654   if (DO_Flg).eq.0 --> skip error message
    call err.msg    ;   ;   ;6657   Warning (1)
    db 1            ;   ;   ;665a   Illegal DO Termination
l665bh:        ;<---+   ;
    call s_41f7h        ;   ;665b   cd f7 41
    ld a,(l0222h)       ;   ;665e
    or a                ;   ;6661
    jp z,l6686h  ;--;   ;   ;6662   if (l0222h).eq.0 --> ...
    ld hl,(l0167h)  ;   ;   ;6665
    ld a,h          ;   ;   ;6668
    or l            ;   ;   ;6669
    jp z,l6686h  ;--;   ;   ;666a   if (l0167h).eq.0 --> ...
    ld (DataID),hl  ;   ;   ;666d   (DataID)=(l0167h)
    xor a           ;   ;   ;6670
    ld (TypeID),a   ;   ;   ;6671   (TypeID)=0 (INTEGER)
    ld (SegmID),a   ;   ;   ;6674   (SegmID)=0 (CSEG) Save Flag Address mode
    ld h,a          ;   ;   ;6677
    ld l,a          ;   ;   ;6678   hl=0
    ld (l0167h),hl  ;   ;   ;6679   (l0167h)=0
    call s_5853h    ;   ;   ;667c   cd 53 58
    xor a           ;   ;   ;667f   a=0
    ld (l029ah),a   ;   ;   ;6680   (l029ah)=0
    ld (l0222h),a   ;   ;   ;6683   (l0222h)=0
l6686h:        ;<---+   ;
    pop bc              ;   ;6686 / c1
    pop hl              ;   ;6687 / e1
    ld a,b              ;   ;6688
    or c                ;   ;6689   test bc
    jp nz,l6693h ;--;   ;   ;668a   if bc.ne.0 --> ...
    call s_369ah    ;   ;   ;668d   cd 9a 36
    jp l6621h ;-----)---+   ;6690   --> ...
                    ;
l6693h:        ;<---+
    ld h,b                  ;6693
    ld l,c                  ;6694   hl=bc
    ld (l01b2h),hl          ;6695   (l01b2h)=bc
    call l6494h             ;6698   cd 94 64
    call err.msg            ;669b   Error (103)
    db 103                  ;669e   Illegal DO Nesting
;*
;*  Check the stack
;*
ChkStack:
    push de                 ;669f
    push hl                 ;66a0
    ld hl,-20               ;66a1   hl=[ffec]
    add hl,sp               ;66a4       hl=SP-20
    ex de,hl                ;66a5                   de=SP-20
    ld hl,(TopDat)          ;66a6       hl=(TopDat)
    ex de,hl                ;66a9       hl=SP-20    de=(TopDat)
    call cmpHL.DE           ;66aa   Compare HL with DE
    pop hl                  ;66ad   
    pop de                  ;66ae   
    ret nc                  ;66af   if(SP-20 >= (TopDat)) Return
    call err.msg            ;66b0   Error (134)
    db 134                  ;66b3   Stack Overflow
;*
;*  First step of the compilation
;*
Firstep:
    ld hl,00000h                ;66b4   hl=0
    ld (l0264h),hl              ;66b7   (l0264h)=0
    ld hl,l010dh                ;66ba
    ld (hl),0                   ;66bd   (l010dh)=0
    call s_14dbh                ;66bf   g_n_chr; (l0173h)=chr
    jp c,l674ah  ;--------;     ;66c2   if chr Special character --> ...
    jp p,l6705h  ;---;    ;     ;66c5   if chr Letter --> ...
    call PrLabel     ;    ;     ;66c8   Processing label
    ld a,(ScopeID)   ;    ;     ;66cb
    or a             ;    ;     ;66ce
    jp z,l66d6h  ;-; ;    ;     ;66cf   if(ScopeID).eq.0 --> Skip error message
    call err.msg   ; ;    ;     ;66d2   Warning (0)
    db 0           ; ;    ;     ;66d5   Duplicate Statement Label
                   ; ;    ;
l66d6h:      ;<----+ ;    ;
    ld hl,(l01cfh)   ;    ;     ;66d6
    push hl          ;    ;     ;66d9 \
    ld (l0264h),hl   ;    ;     ;66da   (l0264h)=(l01cfh)
    call s_41f7h     ;    ;     ;66dd   cd f7 41
    call s_3923h     ;    ;     ;66e0   cd 23 39
    pop hl           ;    ;     ;66e3 / hl=(l01cfh)
    call ExtAttr     ;    ;     ;66e4   Extract Attributes from the symbol table
    call s_5853h     ;    ;     ;66e7   cd 53 58
    ld a,(TypeID)    ;    ;     ;66ea
    or a             ;    ;     ;66ed
    jp nz,l66f4h ;-; ;    ;     ;66ee   if (TypeID).ne.0 (INTEGER) --> ...
    ld (l020eh),a  ; ;    ;     ;66f1   (l020eh)=0
l66f4h:      ;<----+ ;    ;
    ld hl,(PrgSiz)   ;    ;     ;66f4   Load Program size
    ld (DataID),hl   ;    ;     ;66f7   (DataID)=(PrgSiz)
    ld hl,ScopeID    ;    ;     ;66fa
    ld (hl),2        ;    ;     ;66fd   (ScopeID)=2
    call PutAttr     ;    ;     ;66ff   Put Attributes in Symbol table
    jp l670ch  ;---; ;    ;     ;6702   --> ...
                   ; ;    ;
l6705h:   ;<-------)-+<-; ;
    xor a          ;    ; ;     ;6705   a=0
    ld (l020eh),a  ;    ; ;     ;6706   (l020eh)=0
    call s_3923h   ;    ; ;     ;6709   cd 23 39
l670ch:     ;<-----+    ; ;
    ld a,(l0222h)       ; ;     ;670c
    or a                ; ;     ;670f
    jp z,l6739h ;----;  ; ;     ;6710   if (l0222h).eq.0 --> ...
    ld hl,(l0167h)   ;  ; ;     ;6713
    ld a,h           ;  ; ;     ;6716
    or l             ;  ; ;     ;6717
    jp z,l6739h ;--; ;  ; ;     ;6718   if (l0167h).eq.0 --> ...
    push hl        ; ;  ; ;     ;671b \ 
    call s_41f7h   ; ;  ; ;     ;671c   cd f7 41
    pop hl         ; ;  ; ;     ;671f /
    ld (DataID),hl ; ;  ; ;     ;6720   (DataID)=(l0167h) 
    xor a          ; ;  ; ;     ;6723
    ld (TypeID),a  ; ;  ; ;     ;6724   (TypeID)=0 (INTEGER) 
    ld (SegmID),a  ; ;  ; ;     ;6727   (SegmID)=0 (CSEG)    Save Flag Address mode
    ld h,a         ; ;  ; ;     ;672a
    ld l,a         ; ;  ; ;     ;672b
    ld (l0167h),hl ; ;  ; ;     ;672c   (l0167h)=0
    call s_5853h   ; ;  ; ;     ;672f   cd 53 58
    xor a          ; ;  ; ;     ;6732
    ld (l029ah),a  ; ;  ; ;     ;6733   (l029ah)=0
    ld (l0222h),a  ; ;  ; ;     ;6736   (l0222h)=0
l6739h:      ;<----+-+  ; ;
    ld hl,00000h        ; ;     ;6739
    ld (l020fh),hl      ; ;     ;673c   (l020fh)=0
    ld a,(l0299h)       ; ;     ;673f
    or a                ; ;     ;6742
    jp z,l6755h ;---;   ; ;     ;6743   if(l0299h).eq.0 --> ...
    call err.msg    ;   ; ;     ;6746   Error (100)
    db 100          ;   ; ;     ;6749   Illegal Statement Number
                    ;   ; ;
l674ah:     ;<------)---)-+
    or a            ;   ;       ;674a
    jp z,l6705h ;---)---;       ;674b   if chr.eq.0 --> ...
    xor a           ;   ;       ;674e
    ld (l0173h),a   ;   ;       ;674f   (l0173h)=0
    jp l6705h   ;---)---+       ;6752   --> ...
                    ;
l6755h:          ;<-+
    ld a,(PosStm)               ;6755
    ld (l0290h),a               ;6758   (l0290h)=(PosStm)
    ld (l01d1h),a               ;675b   (l01d1h)=(PosStm)
    ld hl,00000h                ;675e   hl=0
    ld (CurAdr),hl              ;6761   (CurAdr)=0
;*
;*  Parse END
;*
    ld bc,l6788h                ;6764   bc= point to l6788h
    push bc                     ;6767 \ save to return
    call g_n_chr                ;6768   Get next character
    cp 'E'                      ;676b
    ret nz       ;--;           ;676d   if chr.ne.'E' Return to l6788h
    call g_n_chr    ;           ;676e   Get next character
    cp 'N'          ;           ;6771
    ret nz       ;--;           ;6773   if chr.ne.'N' Return to l6788h
    call g_n_chr    ;           ;6774   Get next character
    cp 'D'          ;           ;6777
    ret nz       ;--;           ;6779   if chr.ne.'D' Return to l6788h
    call g_n_chr    ;           ;677a   Get next character
    cp '/'          ;           ;677d
    ret nz       ;--;           ;677f   if chr.ne.'/' Return to l6788h
    ld a,0bh        ;           ;6780   a=0bh
    call s_5e97h    ;           ;6782   cd 97 5e
    jp l5176h       ;           ;6785   --> Completion compile the module
                    ;
l6788h:         ;<--+
    call s_5cceh                ;6788   Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
    ld a,(l0290h)               ;678b
    ld (l01d1h),a               ;678e   (l01d1h)=(l0290h)
    ld b,0ffh                   ;6791   b=0ffh
l6793h:         ;<--;
    push bc         ;           ;6793 \
    call g_n_chr    ;           ;6794   Get next character
    pop bc          ;           ;6797 /
l6798h:     ;<------)---------;
    cp ')'          ;         ; ;6798
    jp z,l67ebh   ;-)-;       ; ;679a   if chr.eq.')' --> ...
    cp '('          ; ;       ; ;679d
    jp z,l67f7h  ;--)-)-----; ; ;679f   if chr.eq.'(' --> ...
    cp ','          ; ;     ; ; ;67a2
    jp z,l67f8h ;---)-)---; ; ; ;67a4   if chr.eq.',' --> ...
    cp '/'          ; ;   ; ; ; ;67a7
    jp z,l64fdh     ; ;   ; ; ; ;67a9   if chr.eq.'/' --> Search statement
    cp '='          ; ;   ; ; ; ;67ac
    jp nz,l6793h ;--+ ;   ; ; ; ;67ae   if chr.ne.'=' --> ...
    or b              ;   ; ; ; ;67b1
    jp p,l64fdh       ;   ; ; ; ;67b2   if b > 0 --> Search statement
    call s_1cbbh      ;   ; ; ; ;67b5   cd bb 1c
    call s_5cceh      ;   ; ; ; ;67b8   Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
    ld a,(l0299h)     ;   ; ; ; ;67bb
    cp ','            ;   ; ; ; ;67be
    jp z,l0df0h       ;   ; ; ; ;67c0   if (l0298h).eq.',' --> Parse DO statement
    call PrName       ;   ; ; ; ;67c3   Processing name
    ld a,(l0299h)     ;   ; ; ; ;67c6
    cp '='            ;   ; ; ; ;67c9
    jp z,l67d6h  ;--; ;   ; ; ; ;67cb   if (l0299h).eq.'=' --> ...
    ld a,(KindID)   ; ;   ; ; ; ;67ce
    cp 4            ; ;   ; ; ; ;67d1
    jp nz,l467dh    ; ;   ; ; ; ;67d3   if (KindID).eq.4 --> ...
l67d6h:       ;<----+ ;   ; ; ;
    ld a,9            ;   ; ; ; ;67d6   a=9
    call s_5e97h      ;   ; ; ; ;67d8   cd 97 5e
    ld a,(l0290h)     ;   ; ; ; ;67db
    ld (l01d1h),a     ;   ; ; ; ;67de   (l01d1h)=(l0290h)
    call s_5cceh      ;   ; ; ; ;67e1   Init variables (PosStm),(l01d1h)=(l0173h)=0,Clear buffer ^l02b5h
    xor a             ;   ; ; ; ;67e4   a=0
    call s_14e2h      ;   ; ; ; ;67e5   cd e2 14
    jp l09ebh         ;   ; ; ; ;67e8   Clear (l029ah) & (DO_Flg) -> Ending parsing
                      ;   ; ; ;
l67ebh:     ;<--------+   ; ; ;
    dec b                 ; ; ; ;67eb   b=b-1
l67ech:        ;<-------; ; ; ;
    push bc             ; ; ; ; ;67ec
    call g_n_chr        ; ; ; ; ;67ed   Get next character
    pop bc              ; ; ; ; ;67f0
    jp nc,l64fdh        ; ; ; ; ;67f1   if chr Letter or Digit --> Search statement
    jp l6798h     ;-----)-)-)-+ ;67f4   --> ...
                        ; ; ; ;
l67f7h:        ;<-------)-)-+ ;
    inc b               ; ;   ; ;67f7   b=b+1
l67f8h:      ;<---------)-+   ;
    inc b               ;     ; ;67f8   b=b+1
    dec b               ;     ; ;67f9
    jp nz,l64fdh        ;     ; ;67fa   if b.ne.0 --> Search statement
    push bc             ;     ; ;67fd \ c5
    call s_1cbbh        ;     ; ;67fe   cd bb 1c
    ld a,(l01ceh)       ;     ; ;6801
    inc a               ;     ; ;6804
    jp nz,l6819h ;----; ;     ; ;6805   if (l01ceh).ne.1 --> ...
l6808h:      ;<---;   ; ;     ;
    call s_1a9eh  ;   ; ;     ; ;6808   cd 9e 1a
    ld b,a        ;   ; ;     ; ;680b   Save a
    ld a,(PosStm) ;   ; ;     ; ;680c   3a 07 01
    cp 73         ;   ; ;     ; ;680f
    jp z,l6819h ;-)-; ; ;     ; ;6811   if (PosStm).eq.73 --> ...
    ld a,b        ; ; ; ;     ; ;6814   Restore a
    or a          ; ; ; ;     ; ;6815
    jp nz,l6808h;-+ ; ; ;     ; ;6816   if b.ne.0 --> ...
l6819h:     ;<------+-+ ;     ;
    pop bc              ;     ; ;6819 / c1
    ld a,1              ;     ; ;681a
    ld (l0173h),a       ;     ; ;681c   (l0173h)=1
    ld a,(l0243h)       ;     ; ;681f
    cp 2                ;     ; ;6822
    ld a,02ah           ;     ; ;6824
    jp z,l6798h  ;------)-----+ ;6826   if (l0243h).eq.2 { a=02ah --> ...}
    jp l67ech ;---------+       ;6829   --> ...
;*
;*  Processing SUBROUTINE (SUBROUTINE name(par1,par2,...,parn))
;*
PrSubroutine:
    ld a,1              ;682c
    ld (SubrFlg),a      ;682e   (SubrFlg)=1 (Subroutine)
;*
;*  Processing FUNCTION (FUNCTION name(par1,par2,...,parn))
;*
PrFunction:
    ld a,0ffh           ;6831   a=0ffh
l6833h:
    push af             ;6833 \ Save (tmpvar)
    ld a,(l024eh)       ;6834
    or a                ;6837
    jp nz,err127        ;6838   if(l024eh).ne.0 --> Error (127) Statement Out of Sequence
    ld a,1              ;683b
    ld (l0262h),a       ;683d   (l0262h)=1
    ld (MainFlg),a      ;6840   (MainFlg)=1 (Subprogram)
    call PrName         ;6843   Processing name
    pop af              ;6846 / Restore (tmpvar)
    or a                ;6847
    jp m,l684eh   ;-;   ;6848   if (tmpvar) < 0 --> ...
    ld (TypeID),a   ;   ;684b   (TypeID)=(tmpvar) Save value type variable
l684eh:         ;<--+
    call s_0a10h        ;684e   cd 10 0a
    ld a,2              ;6851
    ld (ScopeID),a      ;6853   (ScopeID)=2
    call PutAttr        ;6856   Put Attributes in Symbol table
    ld hl,(l01cfh)      ;6859
    ld (l0268h),hl      ;685c   (l0268h)=(l01cfh)
    call s_58adh        ;685f   Put name program to REL file
    ld c,0              ;6862   REL type - ENTRY SYMBOL
    call RELITEM        ;6864
    call s_58eeh        ;6867   cd ee 58
    ld a,(SubrFlg)      ;686a   Load flag Subroutine
    or a                ;686d
    jp nz,l687fh ;--;   ;686e   if (SubrFlg).ne.0 (Subroutine) --> ...
    ld hl,l02abh    ;   ;6871
    ld a,(hl)       ;   ;6874
    push af         ;   ;6875 \
    ld (hl),8       ;   ;6876   (l02abh)=8
    call s_0d04h    ;   ;6878   cd 04 0d
    pop af          ;   ;687b /
    ld (l02abh),a   ;   ;687c   (l02abh)=(l02abh)
l687fh:         ;<--+
    call s_190fh        ;687f   Processing of actual parameters subprogram
    jp l09ebh           ;6882   --> Clear (l029ah) & (DO_Flg) -> Ending parsing
;*
;*  Extract Attributes from the symbol table, entry (l031fh)
;*
s_6885h:
    ld hl,(l031fh)      ;6885   hl=(l031fh)
    jp ExtAttr          ;6888   --> Extract Attributes from the symbol table
;*
;*  Calculate address next symbol in the Symbols table;
;*  if (l01cfh).<=.(l0209h) Extract Attributes from the symbol table
;*
s_688bh:
    ld hl,(l01cfh)      ;688b
    ld a,(SizeID)       ;688e
    cpl                 ;6891
    sub 5               ;6892
    ld c,a              ;6894
    ld b,0ffh           ;6895
    add hl,bc           ;6897
    ld (l01cfh),hl      ;6898   (l01cfh)=(l01cfh)-(SizeID)-6
    ex de,hl            ;689b
    ld hl,(l0209h)      ;689c
    call cmpHL.DE       ;689f   Compare HL with DE
    ccf                 ;68a2
    ret c               ;68a3   if (l0209h) >= (l01cfh) Return
    jp s_54c8h          ;68a4   --> Extract Attributes from the symbol table, entry( l01cfh)
;*
;*  Check ','
;*
ChComma:
    ld a,','            ;68a7
    jp ch.chr           ;68a9   Check character (a character for check)
;*
;*  Check '('
;*
s_68ach:
    ld a,'('            ;68ac
;*
;*  Check character (a character for check)
;*
ch.chr:
    ld hl,l0299h        ;68ae 
    cp (hl)             ;68b1
    ret z               ;68b2   if a.eq.(l0299h) Return
err126:
    call err.msg        ;68b3   Error (126)
    db 126              ;68b6   Illegal Character for Syntax
;
err137:
    call err.msg        ;68b7   Error (137)
    db 137              ;68ba   File Not Found
;*
;*
;*
l68bbh:
    ld a,(l02abh)       ;68bb
    ld l,a              ;68be
    ld h,0              ;68bf   hl=(l02abh)
    ld de,00001h        ;68c1   de=1
    ld a,(KindID)       ;68c4
    cp 4                ;68c7
    ret nz              ;68c9   if (KindID).ne.4 (Array) Return
    push hl             ;68ca \ Save hl
    call s_556ah        ;68cb   cd 6a 55
    ld a,(l0230h)       ;68ce   3a 30 02 
    cpl                 ;68d1   2f
    ld hl,l026ah        ;68d2
    ld e,(hl)           ;68d5
    inc hl              ;68d6               hl=hl+1
    ld d,(hl)           ;68d7   de=(l026ah)
    inc hl              ;68d8               hl=hl+1
    inc a               ;68d9   a=-(l0230h)
l68dah:     ;<------;
      inc a         ;   ;68da   a=a+1
      jp z,l68edh ;-)-; ;68db   if a.eq.0 --> ...
      push af       ; ; ;68de \ --------------;
      ld c,(hl)     ; ; ;68df                 ;
      inc hl        ; ; ;68e0   hl=hl+1       ;
      ld b,(hl)     ; ; ;68e1   bc=(hl)       ;
      inc hl        ; ; ;68e2   hl=hl+1       ;
      push hl       ; ; ;68e3 \ ------------; ;
      call s_5798h  ; ; ;68e4   cd 98 57    ; ;
      ex de,hl      ; ; ;68e7   eb          ; ;
      pop hl        ; ; ;68e8 / <-----------+ ;
      pop af        ; ; ;68e9 / <-------------+
    jp l68dah   ;---+ ; ;68ea   --> ...
                      ;
l68edh:   ;<----------+
    ld b,d              ;68ed
    ld c,e              ;68ee   bc=de
    ex de,hl            ;68ef   eb 
    ex (sp),hl          ;68f0   e3
    ex de,hl            ;68f1   eb
    call s_5798h        ;68f2   cd 98 57
    pop de              ;68f5 / d1
    ret                 ;68f6

;#################
;# END MODULE    #
;#################

;#################
;# START MODULE  #
;#################
;
;   Table service data in the symbol table
;
l68f7h:
    db 0,0,0,0              ;68f7   (l01b0h)(l01a4h)(l0214h)(HeapPtr) [66c6]
    dw 0,0                  ;68fb
    db 11h                  ;68ff   00 010 001
    db 4                    ;6900
offs0   equ $-l68f7h        ;0ah
;
    db 0ffh,0ffh,0ffh,0ffh  ;6901
    dw 0,0                  ;6905
    db 11h                  ;6909   00 010 001
    db 4                    ;690a                    [FA0E]
offs1   equ $-l68f7h        ;14h
;
    db 0,0,0,0              ;690b
    dw 0,0                  ;690f
    db 1                    ;6913   00 000 001
    db 4                    ;6914   (l02b0h)         [FA18]
offs2   equ $-l68f7h        ;1eh
;
    db 1,0,0,0              ;6915
    dw 0,0                  ;6919
    db 1                    ;691d   00 000 001
    db 4                    ;691e   (l023eh)         [FA2C]
offs3   equ $-l68f7h        ;28h
;
    db 2,0,0,0              ;691f
    dw 0,0                  ;6923
    db 1                    ;6927   00 000 001
    db 4                    ;6928   (l02a0h)         [FA36]
offs4   equ $-l68f7h        ;32h
;
    db 0,0,0,0              ;6929
    dw 0,0                  ;692d
    db 9                    ;6931   00 001 001
    db 4                    ;6932   (l02b2h)         [FA40]
offs5   equ $-l68f7h        ;3ch
;
    db 0,0,0,0,0,0,0,0      ;6933
    dw 0,0                  ;693b
    db 019h                 ;693f   00 011 001
    db 8                    ;6940   (l02aeh)         [FA4E]
offs6   equ $-l68f7h        ;4ah
;
    db 0,0,0,81h            ;6941
    dw 0,0                  ;6945
    db 9                    ;6949   00 001 001
    db 4                    ;694a   (l0240h)         [FA58]
offs7   equ $-l68f7h        ;54h
;
    db 0,0,0,0,0,0,0,81h    ;694b
    dw 0,0                  ;6953
    db 19h                  ;6957   00 011 001
    db 8                    ;6958   (l023ch)(l031ch) [FA66]
lent1   equ $-l68f7h        ;62h
;
;   Table Intrinsic Functions in the symbol table
;
        ;-Name
        ;
IntrFun:
    db 'SBA',   0,0, 0,0, 0dh, 3     ;6959  'ABS'  [fa67]
    db 'SBAI',  0,0, 0,0, 05h, 4     ;6962  'IABS' [fa70]
    db 'TNIA',  0,0, 0,0, 0dh, 4     ;696c  'AINT'
    db 'TNI',   0,0, 0,0, 05h, 3     ;6976  'INT'
    db 'TNIDI', 0,0, 0,0, 05h, 5     ;697f  'IDINT'
    db 'DOMA',  0,0, 0,0, 0dh, 4     ;698a  'AMOD'
    db 'DOM',   0,0, 0,0, 05h, 3     ;6994  'MOD'
    db 'TAOLF', 0,0, 0,0, 0dh, 5     ;699d  'FLOAT'
    db 'XIFI',  0,0, 0,0, 05h, 4     ;69a8  'IFIX'
    db 'NGIS',  0,0, 0,0, 0dh, 4     ;69b2  'SIGN'
    db 'NGISI', 0,0, 0,0, 05h, 5     ;69bc  'ISIGN'
    db 'MID',   0,0, 0,0, 0dh, 3     ;69c7  'DIM'
    db 'MIDI',  0,0, 0,0, 05h, 4     ;69d0  'IDIM'
    db 'ELGNS', 0,0, 0,0, 0dh, 5     ;69da  'SNGLE'
    db 'PXE',   0,0, 0,0, 0dh, 3     ;69e5  'EXP'
    db 'GOLA',  0,0, 0,0, 0dh, 4     ;69ee  'ALOG'
    db '01GOLA',0,0, 0,0, 0dh, 6     ;69f8  'ALOG10'
    db 'NIS',   0,0, 0,0, 0dh, 3     ;6a04  'SIN'
    db 'SOC',   0,0, 0,0, 0dh, 3     ;6a0d  'COS'
    db 'HNAT',  0,0, 0,0, 0dh, 4     ;6a16  'TANH'
    db 'TRQS',  0,0, 0,0, 0dh, 4     ;6a20  'SQRT'
    db 'NATA',  0,0, 0,0, 0dh, 4     ;6a2a  'ATAN'
    db '2NATA', 0,0, 0,0, 0dh, 5     ;6a34  'ATAN2'
    db 'KEEP',  0,0, 0,0, 15h, 4     ;6a3f  'PEEK'
    db 'PNI',   0,0, 0,0, 15h, 3     ;6a49  'INP'
    db 'SBAD',  0,0, 0,0, 1dh, 4     ;6a52  'DABS'
    db 'NGISD', 0,0, 0,0, 1dh, 5     ;6a5c  'DSIGN'
    db 'ELBD',  0,0, 0,0, 1dh, 4     ;6a67  'DBLE'
    db 'PXED',  0,0, 0,0, 1dh, 4     ;6a71  'DEXP'
    db 'GOLD',  0,0, 0,0, 1dh, 4     ;6a7b  'DLOG'
    db '01GOLD',0,0, 0,0, 1dh, 6     ;6a85  'DLOG10'
    db 'NISD',  0,0, 0,0, 1dh, 4     ;6a91  'DSIN'
    db 'SOCD',  0,0, 0,0, 1dh, 4     ;6a9b  'DCOS'
    db 'TRQSD', 0,0, 0,0, 1dh, 5     ;6aa5  'DSQRT'
    db 'NATAD', 0,0, 0,0, 1dh, 5     ;6ab0  'DATAN'
    db '2NATAD',0,0, 0,0, 1dh, 6     ;6abb  'DATAN2'
    db 'DOMD',  0,0, 0,0, 1dh, 4     ;6ac7  'DMOD'
    db '0I$',   0,0, 0,0, 0dh, 3     ;6ad1  '$I0'   Transfers integers into the I/O buffer
    db '1I$',   0,0, 0,0, 0dh, 3     ;6ada  '$I1'   Transfers real numbers
    db '2I$',   0,0, 0,0, 0dh, 3     ;6ae3  '$I2'   Transfers logicals
    db '4I$',   0,0, 0,0, 0dh, 3     ;6aec  '$I4'   Transfers extended integers (4 bytes)
    db '3I$',   0,0, 0,0, 0dh, 3     ;6af5  '$I3'   Transfers double precision numbers
    db '1XAMD', 0,0, 0,0, 1dh, 5     ;6afe  'DMAX1'
    db '1NIMD', 0,0, 0,0, 1dh, 5     ;6b09  'DMIN1'
    db '0NIMA', 0,0, 0,0, 0dh, 5     ;6b14  'AMIN0'
    db '1NIMA', 0,0, 0,0, 0dh, 5     ;6b1f  'AMIN1'
    db '0NIM',  0,0, 0,0, 05h, 4     ;6b2a  'MIN0'
    db '1NIM',  0,0, 0,0, 05h, 4     ;6b34  'MIN1'
    db '1XAM',  0,0, 0,0, 05h, 4     ;6b3e  'MAX1'
    db '0XAM',  0,0, 0,0, 05h, 4     ;6b48  'MAX0'
    db '1XAMA', 0,0, 0,0, 0dh, 5     ;6b52  'AMAX1'
    db '0XAMA', 0,0, 0,0, 0dh, 5     ;6b5d  'AMAX0'

lent2   equ $-IntrFun                ;0020fh

;#################
;# END MODULE    #
;#################

    end




